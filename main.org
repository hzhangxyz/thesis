#+LATEX_CLASS: thesis
#+OPTIONS: title:nil
#+OPTIONS: toc:nil

#+begin_src emacs-lisp :exports none :results none
  (add-to-list 'org-latex-classes
               '("thesis"
                 "\\documentclass{ustcthesis}\\input{ustcsetup.tex}
                  [NO-DEFAULT-PACKAGES]
                  [NO-PACKAGES]"
                 ("\\chapter{%s}" . "\\chapter*{%s}")
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
  (setq org-latex-pdf-process
        '("xelatex -interaction nonstopmode -output-directory %o %f"
          "bibtex %b"
          "xelatex -interaction nonstopmode -output-directory %o %f"
          "xelatex -interaction nonstopmode -output-directory %o %f"))
  (setq org-format-latex-options (plist-put org-format-latex-options :scale 4.0))
#+end_src

#+begin_export latex
\maketitle
\copyrightpage
\frontmatter
#+end_export

#+begin_export latex
\ustcsetup{
  keywords  = {张量网络态，强关联系统，量子多体问题，投影纠缠对态},
  keywords* = {Tensor network state, Strongly correlated systems, Quantum many-body problems, PEPS},
}
#+end_export

#+begin_export latex
\begin{abstract}
摘要 TODO
\end{abstract}

\begin{abstract*}
abstract TODO
\end{abstract*}
#+end_export

#+begin_export latex
\tableofcontents
\listoffigures
\listoftables
#+end_export

#+begin_export latex
\newenvironment{ustcnotation}{\begin{notation}\begin{notationlist}{2em}}{\end{notationlist}\end{notation}}
#+end_export

#+MACRO: ED 严格对角化
#+MACRO: MC 蒙特卡洛
#+MACRO: QMC 量子 {{{MC}}}
#+MACRO: Ansatz 拟设
#+MACRO: NQS 神经网络量子态
#+MACRO: TNS 张量网络态
#+MACRO: MPS 矩阵乘积态
#+MACRO: PEPS 投影纠缠对态
#+MACRO: iTEBD 逐块虚时间演化
#+MACRO: SU 简单更新
#+MACRO: DMRG 密度矩阵重整化
#+MACRO: SR 随机重构型
#+MACRO: SSE 随机序列展开
#+MACRO: DQMC 行列式 {{{QMC}}}
#+MACRO: SC 超导

#+attr_latex: :environment ustcnotation
- ED :: {{{ED}}} (Exact Diagonalization)
- MC :: {{{MC}}} (Monte Carlo)
- QMC :: {{{QMC}}} (Quantum Monte Carlo)
- Ansatz :: {{{Ansatz}}} (Ansatz)
- NQS :: {{{NQS}}} (Neural Quantum States)
- TNS :: {{{TNS}}} (Tensor Network States)
- MPS :: {{{MPS}}} (Matrix Product States)
- PEPS :: {{{PEPS}}} (Projected Entangled Pair States)
- iTEBD :: {{{iTEBD}}} (Imaginary Time-evolving Block Decimation)
- SU :: {{{SU}}} (Simple Update)
- DMRG :: {{{DMRG}}} (Density Matrix Renormalization Group)
- SR :: {{{SR}}} (Stochastic Reconfiguration)
- SSE :: {{{SSE}}} (Stochastic Series Expansion)
- DQMC :: {{{DQMC}}} (Determinant Quantum Monte Carlo)
- SC :: {{{SC}}} (Superconductivity)

#+MACRO: F 费米
#+MACRO: B 玻色
#+MACRO: AL 纠缠熵面积定律
#+MACRO: DS 直接采样
#+MACRO: NG 自然梯度
#+MACRO: Hilbert 希尔伯特
#+MACRO: T 张量
#+MACRO: TN 张量网络
#+MACRO: L6 六角晶格
#+MACRO: L4 方形晶格
#+MACRO: Hubbard 哈伯德
#+MACRO: Hamiltonian 哈密顿量

#+begin_export latex
\mainmatter
#+end_export

* 绪论 <<sec:绪论>>

上世纪发展的朗道 {{{F}}} 液体理论和基于自发对称性破缺的相变理论在强关联系统中失效。
在这种系统中，粒子之间的相互作用非常强，使得传统微扰方法难以给出准确结果。
因此，对这类系统的性质分析主要依赖于数值方法。
故发展针对强关联系统的数值方法成了近年来备受关注的研究方向之一。

强关联系统的数值求解受制于巨大的{{{Hilbert}}}空间维度，其随着系统尺寸增大而呈指数增长。
因此，传统的 {{{ED}}} 方法（ED）仅适用于约30个格点的有限系统求解。
在某些特殊的强关联系统中，{{{QMC}}} 方法(QMC)能够给出优异结果，但有阻错的系统存在符号问题，为了收敛它必须指数地增加采样量。
另一大类方法则使用 {{{Ansatz}}} (Ansatz)函数来表示波函数，如何用有限数据量表示庞大的 {{{Hilbert}}} 空间中的向量是这类数值方法的关键点。

近年来，除了一些传统的有偏 {{{Ansatz}}} 和 {{{NQS}}} （NQS） {{{Ansatz}}} ，{{{TNS}}} (TNS) {{{Ansatz}}}备受到极大关注。
2003年，Vidal提出了{{{MPS}}}作为最早的{{{TNS}}} [[cite:Vidal2003]] 。
这种方法使用一维张量链来表示一维系统的波函数，特别适合满足 {{{AL}}} 的系统。
Verstaete随后将其推广至二维系统，即 {{{PEPS}}} (PEPS) [[cite:Verstraete2004]] ，同样适用于满足 {{{AL}}} 的二维系统。
Vidal针对 {{{MPS}}} 提出了 {{{iTEBD}}} (iTEBD) [[cite:Vidal2004,Vidal2007]] ，能有效获得一维系统的基态。
然而在处理二维系统时，优化 {{{PEPS}}} 变得十分困难， {{{iTEBD}}} 算法难以获得精确结果。
2008年，向涛通过在二维系统的 {{{iTEBD}}} 算法中引入简单环境得到 {{{SU}}}(SU)方法 [[cite:Jiang2008]] ，实现在计算效率不减的情况下近似获得基态结果。
获得系统基态后，为计算相关物理量观测值，需要对二维双层张量网络进行收缩。
Sandvik于2007年提出了采样方法 [[cite:Sandvik2007]] ，通过仅收缩二维单层张量网络，便能计算观测量。
2017年，采样方法被用于计算能量的梯度 [[cite:Liu2017]] ，从而可用采样方法直接优化 {{{Ansatz}}} 波函数。
近几年，{{{DS}}} 方法 [[cite:Vieijra2021]] 和 {{{NG}}} 法 [[cite:Neuscamman2012]] 被引入，极大提升了采样效率和优化效率。

本论文将介绍近些年我们对基于采样的张量网络方法的发展与应用。主要结构安排如下：
+ 第 [[ref:sec:绪论]] 章为绪论，即本章。
+ 第 [[ref:sec:张量和张量网络]] 章详细介绍 {{{T}}} 和 {{{TN}}} 的基础理论。
+ 第 [[ref:sec:张量网络态算法]] 章介绍多种基于 {{{TNS}}} 的算法。
+ 第 [[ref:sec:神威优化]] 章介绍在国产神威系统上对 {{{TNS}}} 的程序优化工作。
+ 第 [[ref:sec:软件]] 章介绍 {{{TNS}}} 计算套件的设计和开发。
+ 第 [[ref:sec:超导]] 章介绍在 {{{L6}}} 上的 {{{Hubbard}}} 模型基态中寻找 {{{SC}}} (SC) 相的工作。
+ 第 [[ref:sec:有限温]] 章介绍一种有限温算法以及其测试结果。
+ 第 [[ref:sec:总结与展望]] 章进行总结与展望。

本论文将一直使用爱因斯坦求和约定。
本论文将一直从 $0$ 开始计数而不是 $1$ 开始计数。

* {{{T}}} 和 {{{TN}}} <<sec:张量和张量网络>>

** {{{MPS}}} (MPS)

*** {{{MPS}}} 的形式

数值模拟量子多体问题的根本困难在于系统的{{{Hilbert}}}空间的维度随着系统尺寸的增大指数上升。
比如对于自旋系统，由 $N$ 个自旋 $\frac{1}{2}$ 的格点构成的晶格系统的 {{{Hilbert}}} 空间维度高达 $2^N$ ，为了表示这个系统的状态，需要 $2^N$ 维的向量作为波函数。
所以不做任何近似的严格表示这个波函数，并精确求解系统的本征态，只适用于很小的系统。
而White在1992年提出了{{{DMRG}}}(DMRG)方法 [[cite:White1992]] 成功地求解了各种一维模型的低能态性质。
后来Vidal提出 {{{MPS}}} (MPS) [[cite:Vidal2003]] ，人们认识到{{{DMRG}}}方法可以被认为是对 {{{MPS}}} {{{Ansatz}}}的波函数进行优化的过程。

首先介绍{{{T}}}， $R$阶的张量 可以被简单地认为是多个线性空间上的 $R$ 阶多线性映射：
\begin{equation}
\hat T : V_0 \otimes V_1 \otimes V_2 \cdots V_{R-1} \to \mathbb{K} .
\end{equation}
其中 $V_r$ 是 $\mathbb{K}$ 上的线性空间， $r=0,1,2,\cdots R-1$ , 记 $\mathrm{rank}(\hat T) = R$ 。
而本论文中， $\mathbb{K}$ 只会取 $\mathbb{R}$ 或者 $\mathbb{C}$ ， $V_r$ 也一定是定义了内积的有限维线性空间，
所以可以使用一个高维数组来表示一个张量，即
\begin{equation}
\hat T (
\sum_{i_0=0}^{D_0-1} a_0^{i_0} e_0^{i_0},
\sum_{i_1=0}^{D_1-1} a_1^{i_1} e_1^{i_1},
\cdots
\def\rrr{{R-1}}
\sum_{i_\rrr=0}^{D_{R-1}-1} a_\rrr^{i_\rrr} e_\rrr^{i_\rrr}
)
=
T^{i_0,i_1,\cdots,i_\rrr} a_0^{i_0} a_1^{i_1} \cdots a_\rrr^{i_\rrr},
\end{equation}
其中 $D_r = \mathrm{dim}(V_r)$ ， 记 $\mathrm{rank}(T) = R$ 。
为了表达上的简便，我们直接称呼 $T$ 为张量， 即使严格的说张量应是其所表示的 $\hat T$ 。

{{{MPS}}} 使用一个张量链来表示高维的向量。
以自旋 $\frac{1}{2}$ 系统为例子，一个长度为 $L$ 的自旋系统波函数
\begin{equation}\label{eq:一维系统波函数}
|\Psi\rangle = T^{\sigma_0,\sigma_1,\cdots,\sigma_{L-1}} |\sigma_0 \sigma_1 \cdots \sigma_{L-1}\rangle ,
\end{equation}
可以被使用 {{{MPS}}} 作为 {{{Ansatz}}} 来表示：
\begin{equation}\label{eq:一维系统波函数的MPS展开}
T^{\sigma_0,\sigma_1,\cdots,\sigma_{L-1}} =
(A_0 ^ {\sigma_0})_{v_1}
(A_1 ^ {\sigma_1})_{v_1 v_2}
(A_2 ^ {\sigma_2})_{v_2 v_3}
\cdots (A_{L-1} ^ {\sigma_{N-1}})_{v_{N-1}} ,
\end{equation}
其中 $\sigma_i$ 为第 $i$ 个格点处的自旋，可以取 $\uparrow$ 或者 $\downarrow$。
从公式 [[eqref:eq:一维系统波函数的MPS展开]] 中看到，MPS表示的波函数在一个构型下的分量，是一连串的矩阵乘积，这是矩阵乘积态(MPS)名称由来。

在 {{{MPS}}} {{{Ansatz}}} 中，除了最左边和最右边的格点外，第 $i$ 个格点处的 $(A_i^{\sigma_i})_{v_i v_{i+1}}$ 是一个三阶张量，它有一个物理指标 $\sigma_i$
和两个虚拟指标 $v_i$ 和 $v_{i+1}$ 。
其中物理指标 $\sigma_i$ 可以取 $\uparrow$ 或者 $\downarrow$，其维度是 $2$ ，通常使用 $d$ 标记。
而虚拟指标的维度是一个可调节的参数，通常用 $D$ 表示。
这些指标被称作虚拟指标是因为他们并不是真正的物理指标。
对于其他类型的系统，一个格点处的物理维度并不一定是 $2$ ，如 $t-J$ 模型中 $d=3$ ， {{{Hubbard}}} 模型中 $d=4$ 。

*** {{{AL}}} 与 {{{MPS}}}

在 $D$ 不变的情况下，{{{MPS}}} 可以使用随着系统尺寸线性上升的参数来表示维度指数上升的波函数。
而固定 $D$ 的 {{{MPS}}} 正合适表示满足 {{{AL}}} 的态。

一个量子态分割成两个部分A和B后，A部分和B部分之间的纠缠熵是
\begin{equation}\label{eq:纠缠熵}
S_{A|B} = - \mathrm{tr} (\hat\rho_A \ln \hat\rho_A) = - \mathrm{tr} (\hat\rho_B \ln \hat\rho_B) = - \sum_{v=0}^{V-1} \lambda_v \ln \lambda_v,
\end{equation}
其中 $\hat\rho_A$ 和 $\hat\rho_B$ 是A部分和B部分的约化密度矩阵，$\lambda_v$ 是他们的本征值， $V$ 为约化密度矩阵的维度。
纠缠熵最大的情况下，所有的本征值相等，即 $\lambda_v = \frac{1}{V}$，此时 $S_{A|B} = \ln V$ 。
而约化密度矩阵的维度随着较小系统的尺寸指数上升，不妨假设A部分比B部分更小， 有$S_{A|B} \propto |A|$ ，其中 $|X|$ 为X部分的体积。
而当系统满足{{{AL}}}时，纠缠熵有更强的约束， 即
\begin{equation}\label{eq:面积定律}
S_{A|B} \propto |\partial A| = |\partial B|,
\end{equation}
其中 $|\partial X|$ 表示X的边界大小。

对于公式 [[eqref:eq:一维系统波函数的MPS展开]] 表示的 {{{MPS}}}， 切割为长度为 $X$ 和 $Y$ 的两部分， $X+Y=L$ ，X部分的约化密度矩阵为
\begin{equation}\label{eq:MPS切割后的约化密度矩阵}
\begin{aligned}
(\hat\rho_X)_{\sigma_0,\sigma_1,\cdots,\sigma_{X-1}}^{\sigma'_0,\sigma_2,\cdots,\sigma'_{X-1}} =&
(A_0 ^ {\sigma_0})_{v_1}
\cdots
(A_{X-1} ^ {\sigma_{X-1}})_{v_{X-1} v_X}
(A_X ^ {\sigma_X})_{v_X v_{X+1}}
\cdots
(A_{L-1} ^ {\sigma_{N-1}})_{v_{N-1}}
\\
&
(A_0 ^ {\sigma'_0})^\dag_{v'_1}
\cdots
(A_{X-1} ^ {\sigma'_{X-1}})^\dag_{v'_{X-1} v'_X}
(A_X ^ {\sigma_X})^\dag_{v'_X v'_{X+1}}
\cdots
(A_{L-1} ^ {\sigma_{N-1}})^\dag_{v'_{N-1}} .
\end{aligned}
\end{equation}
注意到
\begin{equation}
\begin{aligned}
(\hat\rho_X)_{\sigma_0,\sigma_1,\cdots,\sigma_{X-1}}^{\sigma'_0,\sigma_2,\cdots,\sigma'_{X-1}} =&
(A_0 ^ {\sigma_0})_{v_1}
\cdots
(A_{X-1} ^ {\sigma_{X-1}})_{v_{X-1} v_X}
\\
&
M_{v_X, v_X'}
\\
&
(A_0 ^ {\sigma'_0})^\dag_{v'_1}
\cdots
(A_{X-1} ^ {\sigma'_{X-1}})^\dag_{v'_{X-1} v'_X},
\end{aligned}
\end{equation}
其中
\begin{equation}
\begin{aligned}
M_{v_X, v_X'} =&
(A_X ^ {\sigma_X})_{v_X v_{X+1}}
\cdots
(A_{L-1} ^ {\sigma_{N-1}})_{v_{N-1}}
\\
&
(A_X ^ {\sigma_X})^\dag_{v'_X v'_{X+1}}
\cdots
(A_{L-1} ^ {\sigma_{N-1}})^\dag_{v'_{N-1}} ,
\end{aligned}
\end{equation}
而 $M_{v_X,v'_X}$ 是一个 $D \times D$ 的矩阵，所以密度矩阵 $\hat \rho_X$ 的秩不大于 $D$ ，则其可表示的最大纠缠熵为 $S = \ln D$ ，即一个常数。
而满足 {{{AL}}} 的一维系统，两部分的边界是零维的点，大小也是常数，所以 {{{MPS}}} {{{Ansatz}}} 能够表示的一维系统恰好是满足一维情况下 {{{AL}}} 的系统。

由于{{{MPS}}}对{{{AL}}}恰到好处的掌握，{{{MPS}}} 可以较高效地表示满足 {{{AL}}} 的系统的波函数。
一维情况下，局部 {{{Hamiltonian}}} 构成的有能隙系统的基态是满足 {{{AL}}} 的，所以一个固定 $D$ 的 {{{MPS}}} 可以很好地表示此类系统的基态。
而对于无能隙的系统，有 $S \propto \alpha \ln L$ ，即纠缠熵随着系统的尺寸对数上升，而 $S \propto \ln D$ ，所以应取 $D \propto L ^\alpha$ ，
对于 $\alpha$ 较小的情况， 所需的 $D$ 随着系统尺寸增长缓慢，我们依然可以通过计算相当大的系统来了解接近热力学极限时系统的性质。

*** {{{TN}}} 的图形标记

由于 {{{TNS}}} 中各个 {{{T}}} 通常有复杂的运算关系，使用爱因斯坦求和约定不能直观地展示张量之间的关系，人们通常使用图形标记法来表示一张 {{{TN}}}。
图形标记法中，使用一个闭合的图形表示一个 {{{T}}} ，图形上的每一条边表示张量的一个指标，两个张量之间彼此相连的边表示这两个指标将要求和。
因此，张量的一个指标有时也被称呼为张量的一个边。
图 [[ref:fig:张量的图形标记法]] 中展示了一些基本的例子。

#+begin_export latex
\begin{figure}
\centering
\input{tikz/graphical_notation.tikz}
\caption{张量的图形标记法}
\label{fig:张量的图形标记法}
\note{注：
(a)是一个标量 $A$ ，即0阶张量；
(b)是一个向量 $A_i$ ，即1阶张量，有一个指标 $i$ ；
(c)是一个矩阵 $A_{ij}$ ，即2阶张量，有两个指标 $i$ 和 $j$ ；
(d)表示矩阵 $A_{ij}$ 和向量 $B_j$ 的乘积，即 $A_{ij} B_{j}$ ；
(e)表示两个矩阵相乘，即 $A_{ij} B_{jk}$ ；
(f)中三个矩阵彼此相连，表示了 $A_{ij} B_{jk} C_{ji}$ 。
}
\end{figure}
#+end_export

使用图形标记法表示的公式 [[eqref:eq:一维系统波函数的MPS展开]] 所展示的 {{{MPS}}} 在 $L=5$ 时如图 [[ref:fig:图形标记法表示的长度为5的MPS]] 所示。
{{{TN}}} 的图形标记法直观地展示了张量之间的连接关系。

#+begin_export latex
\begin{figure}
\centering
\input{tikz/mps.tikz}
\caption{图形标记法表示的长度为$5$的MPS}
\label{fig:图形标记法表示的长度为5的MPS}
\end{figure}
#+end_export

** 投影纠缠对态 (PEPS)

*** {{{PEPS}}}的表示

{{{MPS}}} 成功地处理一维系统后，有一些将 {{{MPS}}} 直接应用于二维系统的尝试，如图 [[ref:fig:用于表示二维系统的MPS和PEPS]] (a)所示。
但是二维系统中，对于满足 {{{AL}}} 的系统，纠缠熵 $S \propto L$ ，其中 $L$ 为边界的长度。
这意味者{{{MPS}}}的虚拟指标维度 $D$ 需要随着系统增大而增大。
时至今日，这种方法通常被用于长条形的准一维系统的求解，而对于真正的二维系统， {{{MPS}}} 无法胜任。
Verstraete在表示二维系统的 {{{MPS}}} 上额外加上了行间的边从而得到了{{{PEPS}}} [[cite:Verstraete2004]] ，如图 [[ref:fig:用于表示二维系统的MPS和PEPS]] (b)所示。
因为图形标记法中的形象，我们称呼物理指标所在的边为物理边，其他张量之间彼此相连的边为虚拟边。

#+begin_export latex
\begin{figure}
\centering
\input{tikz/mps_to_peps.tikz}
\caption{用于表示二维系统的 矩阵乘积态 和 投影纠缠对态 }
\label{fig:用于表示二维系统的MPS和PEPS}
\note{注：固定 虚拟指标维度 $D$ 的 矩阵乘积态 只能表示常数的纠缠熵，通过在行间加上额外的边可以得到 投影纠缠对态， 投影纠缠对态 可以满足二维系统的面积定律。}
\end{figure}
#+end_export

一张 {{{PEPS}}} 中划分出一个区域X，其与外界相连的边的数目正比与区域的周长，即边的数目 $N \propto |\partial X|$ 。
类似 {{{MPS}}} 的情况，计算约化密度矩阵时有同样的形式：
\begin{equation}\label{eq:PEPS中计算约化密度矩阵}
(\hat\rho_{X})_{s_{X, 0}, s_{X, 1}, \cdots} ^ {s'_{X, 0}, s'_{X, 1}, \cdots} =
T_{s_{X,0}, s_{X,1}, \cdots}^{v_0, v_1, \cdots v_{N-1}}
M_{v_0, v_1, \cdots v_{N-1}}^{v'_0, v'_1, \cdots v'_{N-1}}
T^{\dag {s'_{X,0}, s'_{X,1}, \cdots}}_{v'_0, v'_1, \cdots v'_{N-1}} , 
\end{equation}
其中， $s_{X,i}$ 为区域X中各个物理指标， $v_i$ 为区域X和外部相连的边的指标。
公式 [[eqref:eq:PEPS中计算约化密度矩阵]] 中间有一个 $D^N$ 维度的矩阵$M$，其中 $D$ 是 {{{PEPS}}} 中虚拟指标的维度。
而 $S = \ln D^N = N \ln D \propto |\partial X|$ ，所以 {{{PEPS}}} 可以满足二维系统的 {{{AL}}} 。

*** 投影纠缠对

使用一张 {{{TN}}} 作为 {{{Ansatz}}} 表示波函数时，我们可以有两种阐述方式。第一种是数学上的分解，即对于任意一个 $R$ 个粒子的系统，波函数
\begin{equation}
|\Psi\rangle = T_{i_{T,0}, i_{T,1}, \cdots, i_{T,R-1}} |i_0 i_1 \cdots i_{R-1} \rangle ,
\end{equation}
中 $T$ 作为一个 $R$ 阶张量，可以被分解为一张张量网络：
\begin{equation}
\begin{aligned}
T_{i_{T,0}, i_{T,1}, \cdots, i_{T, R-1}} = &
\prod_{n=0}^{N-1} (A_n)_{i_{A_n, 0} i_{A_n, 1} \cdots i_{A_n, \mathrm{rank}(A_n) -1}}
\\ &
\prod_{b=0}^{B-1} \delta^{i_{A_{V_b^0},E_b^0}}_{i_{A_{V_b^1},E_b^1}}
\\ &
\prod_{r=0}^{R-1} \delta^{i_{T,r}}_{i_{A_{V'_r},E'_r}} .
\end{aligned}
\end{equation}
这张张量网络中有 $N$ 个张量，即 $A_n$ ，其中 $n = 0, 1, \cdots N-1$ 。
张量 $A_n$ 的阶数是 $\mathrm{rank}(A_n)$ ，它的指标被记作 $i_{A_n, j}$ ，其中 $j = 0, 1, \cdots \mathrm{rank}(A_n) - 1$ 。
这张张量网络内部有 $B$ 个边连接两个张量，第 $b$ 个边所连接的是第 $V_b^0$ 个张量的第 $E_b^0$ 个边和第 $V_b^1$ 个张量的第 $E_b^1$ 个边，其中 $b=0,1,\cdots B-1$
而这些张量中，有 $R$ 个边没有被收缩，而是作为物理边出现在张量 $T$ 中，
张量 $T$ 的第 $r$ 个边在张量网络中是第 $V'_r$ 个张量的第 $E'_r$ 个边，其中 $r = 0, 1, \cdots R-1$ 。
这张张量网络中，由 $A_n$ ， $n=0, \cdots N-1$ 组成，由 $V_b^0, V_b^1, V'_r, E_b^0, E_b^1, E'_r$ ， $b=0,\cdots B-1, r=0,\cdots R-1$ 表示张量的图结构。
通过不同的张量网络图结构，可以构造出不同类型的张量网络。

另一种阐述方式是将张量网络态视为对一群纠缠对所构成的母态的投影。
先把波函数写成产生算符的形式：
\begin{equation}\label{eq:一般的波函数}
|\Psi\rangle = T_{i_{T,0}, i_{T,1}, \cdots, i_{T,R-1}} \prod_{r=0}^{R-1} c_r^{\dag i_{T,r}} |\Omega\rangle ,
\end{equation}
其中 $|\Omega\rangle$ 是真空态，  $c_r^{\dag i_{T,r}}$ 是第 $r$ 个粒子处，产生第 $i_{T,r}$ 个构型的算符。
需要注意的是，对于一些系统， $c_r^{\dag i_{T,r}}$ 不一定是单个粒子的产生算符，而可能是多个粒子产生算符的复合。
然后将波函数视为对一个母态的投影：
\begin{equation}
|\Psi\rangle = P M |\Omega\rangle ,
\end{equation}
其中 $P$ 为投影算符， $M$ 为制备母态的算符。
而母态为众多组纠缠对的组合：
\begin{equation}
M = 
\prod_{b=0}^{B-1} a_{b,0}^{\dag d_b} a_{b,1}^{\dag d_b}
,
\end{equation}
其中第 $b$ 组纠缠对由 $a_{b,0}^{\dag d_b}$ 和 $a_{b,1}^{\dag d_b}$ 生成， 这里 $d_b$ 取值范围为 $0, 1, \cdots D_b - 1$ ，其中 $D_b$ 为这组纠缠对的个数。
而投影算符被定义为：
\begin{equation}
\begin{aligned}
P = 
\prod_{n=0}^{N-1} & (A_n)_{i_{A_n, 0} i_{A_n, 1} \cdots i_{A_n, \mathrm{rank}(A_n) -1}} \\
&
\prod_{j=0}^{\mathrm{rank}(A_n) - 1} \left\{
\begin{aligned}
&a^{i_{A_n, j}}_{X_{A_n,j},Y_{A_n, j}} \ & \text{如果 $A_n$ 的第 $j$ 个边为虚拟边}, \\
&c^{\dag i_{A_n,j}}_{Z_{A_n,j}} \ & \text{如果 $A_n$ 的第 $j$ 个边为物理边},
\end{aligned}
\right.
\end{aligned}
\end{equation}
其中 $A_n$ 的第 $j$ 个边，如果是物理边，则是 $|\Psi\rangle$ 的第 $Z_{A_n,j}$ 个边，
如果是虚拟边，则将湮灭掉第 $X_{A_n,j}$ 组纠缠对中粒子，而 $Y_{A_n,j}$ 取 $0$ 或 $1$ ，标记其湮灭的是纠缠对中靠前的还是靠后的粒子。
这种解释方式中，将张量网络的虚拟边用纠缠对表示，投影算子中湮灭同一个纠缠对的两个部分是彼此相连的张量。
每个张量通过湮灭掉纠缠对并产生物理的粒子，实现了将多组纠缠对投影到物理空间的操作，这便是投影纠缠对态的名称由来。
值得注意的是，虽然对纠缠对的投影可以阐述任意图结构的张量网络，但是我们提到“投影纠缠对态”时，都是特指方格形的张量网络的。

在张量网络态的投影纠缠对阐述中，投影部分既有湮灭算符也有产生算符，这不够好看。
我们可以再引入一个虚拟的粒子，得到：
\begin{equation}\label{eq:投影纠缠对阐述的一般张量网络}
\left\{
\begin{aligned}
P &= 
\prod_{n=0}^{N-1} (A_n)_{i_{A_n, 0} i_{A_n, 1} \cdots i_{A_n, \mathrm{rank}(A_n) -1}}
\prod_{j=0}^{\mathrm{rank}(A_n) - 1} 
a^{i_{A_n, j}}_{X_{A_n,j},Y_{A_n, j}} , \\
M &=
\prod_{b=0}^{B-1} a_{b,0}^{\dag d_b} a_{b,1}^{\dag d_b}
\prod_{r=0}^{R-1} a_{r+B,0}^{\dag d_{r+B}} c_r^{\dag d_{r+B}} ,
\end{aligned}
\right.
\end{equation}
这样我们依然可以将公式 [[eqref:eq:一般的波函数]] 表示为母态上的投影，即 $|\Psi\rangle = P M |\Omega\rangle$ 。
这种变型的投影纠缠对阐述将每个张量中各个边平等地对待，图结构的信息完全放置在母态生成算符 $M$ 中。

** 对称性张量和费米子张量 <<sec::对称性张量和费米子张量>>

*** 对称性张量 <<sec:::对称性张量>>

当一个系统的哈密顿量拥有某个对称性时，其基态要么满足这个对称性，要么自发破缺从而是简并的。
对称性变换使用一个紧致群 $G$ 来描述，
如果公式 [[eqref:eq:一般的波函数]] 表示的基态波函数满足这个对称性，我们有
\begin{equation}\label{eq:对称性张量}
U_g^{\otimes R} T_{i_{T,0},\cdots, i_{T,R-1}} = T_{i_{T,0},\cdots, i_{T,R-1}} ,
\end{equation}
其中 $g \in G$ ，
$U_g^{\otimes R} = \bigotimes_{r=0}^{R-1} U_g^r$ ， $U_g^r$ 为 $g$ 在张量的第 $r$ 个指标的线性空间上的表示。
满足公式 [[eqref:eq:对称性张量]] 的张量被称作对称性张量 [[cite:Singh2010]] ，图 [[ref:fig:对称性张量和对称性张量网络]] (a)使用图形标记法展示了此关系。
需要注意对称性张量和对称矩阵完全不同，对称矩阵是做交换两个指标的转置变换下不变的矩阵，对称性张量是在每个指标中各自做相同的群元素代表的群变换下不变的张量。

#+begin_export latex
\begin{figure}
\centering
\input{tikz/symmetry.tikz}
\caption{对称性张量和对称性张量网络}
\label{fig:对称性张量和对称性张量网络}
\note{注：
(a)中，对张量做一个对称性变换相当与在张量的每个指标上作用上这个指标上 $g$ 的群表示矩阵，因为是群是紧致的，我们可以给张量找到一组合适的基使得矩阵是酉的。
(b)中，如果张量网络中的每个张量都是对称性张量，我们可以在每个张量的周围都加上群的变换矩阵，而不改变张量网络的值，得到等式的左侧；
而两个张量彼此相互收缩的线性空间是相互共轭的，所以他们的群表示是互逆的，所有的虚拟边上的两个矩阵可以相互抵消而不改变张量网络的值，得到等式的右侧；
所以原有的张量网络等于只在物理边上做群变换，即整个张量网络的收缩结果是对称性张量。}
\end{figure}
#+end_export

从图 [[ref:fig:对称性张量和对称性张量网络]] (b) 中可以很明显看出，对称性张量收缩结果仍然是对称性张量。
所以对于一个已知满足某个对称性的波函数，使用张量网络表示时，可以使用限制更强的拟设：张量网络态中每个张量都是对称性张量。
波函数的物理指标有明确的物理意义，所以给定对称群的群表示是固定的。
而对于一个张量网络态，我们可以将每个虚拟指标所在的线性空间也看作对称群的一个表示空间，
从而我们可以对张量网络态中的每个张量各自做对称性变换，这样每个张量都可以被设置为对称性张量。
值得注意的是，这种虚拟指标所在空间的群表示是任意的。

一个对称性张量的每个边所在的空间都是群的表示空间，空间 $V$ 可以分解为
\begin{equation}
V \cong \bigoplus_{s} d_s V^{s} \cong \bigoplus_{s} (D^{s} \otimes V^{s}),
\end{equation}
其中 $V^s$ 是群的第 $s$ 个不可约表示空间， $d_s$ 是他的重数，这里 $D^s$ 是 $d_s$ 维的简并空间。

我们可以使用 $U_g^r$ 来作张量的第 $r$ 个指标的基，每个指标的空间 $V^r = \bigoplus_s (D^{r,s} \otimes V^s)$ 中，使用 $(s,\alpha_s, m_s)$ 来作为基底。
其中 $s$ 标记了不同的不可约表示， $\alpha_s$ 是简并空间的指标，即 $\alpha_s = 0,1,\cdots d_s-1$ ，而 $m_s$ 是这个不可约表示空间中的指标。

在这个基下，一个张量是一个对称性张量的条件是
+ 0阶 :: 标量显然是一个对称性张量。
+ 1阶 :: 其非零元素只能位于平凡的不可约表示中，即 $s=0$ ，而 $m_0=0$ 。
+ 2阶 :: 其非零元素的两个指标需要在相同的不可约表示空间中，且两者的 $m_s$ 相反，即张量需要满足形式
\begin{equation}
T_{(s_0,\alpha_{s_0},m_{s_0}),(s_1,\alpha_{s_1},m_{s_1})} =
P_{(s_0,\alpha_{s_0}),(s_1,\alpha_{s_1})} \delta_{s_0,s_1}
\begin{pmatrix} s_0 \\ m_{s_0} \quad m_{s_1} \end{pmatrix},
\end{equation}
其中括号是Wigner 1-jm符号。
+ 3阶 :: 张量需要满足形式
\begin{equation}
T_{(s_0,\alpha_{s_0},m_{s_0}),(s_1,\alpha_{s_1},m_{s_1}),(s_2,\alpha_{s_2},m_{s_2})} =
P_{(s_0, \alpha_{s_0}),(s_1, \alpha_{s_1}),(s_2, \alpha_{s_2})}
\begin{pmatrix}
s_0 & s_1 & s_2 \\
m_0 & m_1 & m_2
\end{pmatrix},
\end{equation}
其中括号是Wigner 3-jm符号。
+ 更高阶 :: 张量需要可以被分解为多个3阶对称性张量收缩的形式。

如上所示，一般对称群的对称性张量结构十分复杂，但对于Abel群来说，情况却十分简单。
Abel群的不可约表示一定是1维的，所以恒有 $m_s=0$ ,故我们将 $m_s$ 省略，使用 $(s,\alpha_s)$ 作为基。
此时 $R$ 阶的对称性张量需要满足
\begin{equation}
U_g^{\otimes R} T_{(s_0,\alpha_{s_0}),(s_1,\alpha_{s_1}),\cdots (s_{R-1},\alpha_{s_{R-1}})} =
T_{(s_0,\alpha_{s_0}),(s_1,\alpha_{s_1}),\cdots (s_{R-1},\alpha_{s_{R-1}})},
\end{equation}
而 $U_g^{\otimes R}$ 中每个项目 $U_g^r = U_g^{s_r}$ ，作为一个一维的酉矩阵，就是一个复数。
所以我们得到：
\begin{equation}
T_{(s_0,\alpha_{s_0}),(s_1,\alpha_{s_1}),\cdots (s_{R-1},\alpha_{s_{R-1}})}
\prod_r^{R-1}U_g^{s_r}
=
T_{(s_0,\alpha_{s_0}),(s_1,\alpha_{s_1}),\cdots (s_{R-1},\alpha_{s_{R-1}})}.
\end{equation}
为此，张量需要满足形式：
\begin{equation}\label{eq:Abel对称性张量的原始形式}
T_{(s_0,\alpha_{s_0}),(s_1,\alpha_{s_1}),\cdots (s_{R-1},\alpha_{s_{R-1}})} =
P_{(s_0, \alpha_{s_0}),(s_1, \alpha_{s_1}),\cdots (s_{R-1}, \alpha_{s_{R-1}})}
C(s_0,s_1,\cdots s_{R-1}) ,
\end{equation}
其中
\begin{equation}
C(s_0, s_1, \cdots s_{R-1}) = \left\{\begin{aligned}
1 \quad & \text{如果对于任意$g$有}  \quad \prod_{r=0}^{R-1} U_g^{s_r} = 1 ,\\
0 \quad & \text{其他情况},
\end{aligned}\right.
\end{equation}
是对称群决定的对称性条件。
将公式 [[eqref:eq:Abel对称性张量的原始形式]] 稍作变形得到：
\begin{equation}\label{eq:Abel对称性张量的形式}
T_{(s_0,\alpha_{s_0}),(s_1,\alpha_{s_1}),\cdots (s_{R-1},\alpha_{s_{R-1}})} =
\left(P_{s_0,s_1,\cdots,s_{R-1}}\right)_{\alpha_{s_0},\alpha_{s_1},\cdots \alpha_{s_{R-1}}}
R(s_0,s_1,\cdots s_{R-1}) .
\end{equation}
可见Abel群的对称性张量是一个分块的张量，其中分块方案由对称性条件和张量每个边上的不可约表示分解决定。

物理中常见的群是 $Z(2)$ 群和 $U(1)$ 群。
对于 $Z(2)$ 群， $g=e$ 表示不变， $g=z$ 表示反转。
群表示 $0$ 中 $U_e^0 = U_z^0 = +1$ ，另一个群表示 $1$ 中 $U_e^1 = +1$ ， $U_z^1 = -1$ 。
所以 $Z(2)$ 群的对称性条件是：
\begin{equation}\label{eq:Z2对称性条件}
C(s_0, s_1, \cdots s_{R-1}) = \left\{\begin{aligned}
1 \quad & \text{如果}  \quad \bigoplus_{r=0}^{R-1} s_r = 0 ,\\
0 \quad & \text{如果}  \quad \bigoplus_{r=0}^{R-1} s_r = 1 ,
\end{aligned}\right.
\end{equation}
其中 $\bigoplus$ 为异或运算。

而对于 $U(1)$ 群， $g=\theta$ 表示旋转 $\theta$ 。
群表示使用一个整数 $s$ 来标记， $U_\theta^s = \mathrm{e}^{\mathrm{i} s \theta}$ 。
所以 $U(1)$ 群的对称性条件是：
\begin{equation}
C(s_0, s_1, \cdots s_{R-1}) = \left\{\begin{aligned}
1 \quad & \text{如果}  \quad \sum_{r=0}^{R-1} s_r = 0 ,\\
0 \quad & \text{如果}  \quad \sum_{r=0}^{R-1} s_r \neq 0 .
\end{aligned}\right.
\end{equation}

对于 $U(1)$ 群和 $Z(2)$ 的乘积群，可以使用各个子群的群表示的乘积来表示这个群的群表示。
比如对于 $U(1) \times Z(2)$ 群，群元素为 $g=(\theta, p)$ ，其中 $p=e=+1$ 表示不变， $p=z=-1$ 表示反转。
群表示可以标记为 $s=(z, b)$ 其中 $z$ 为整数， $b=0$ 或 $1$ ，而 $U_{\theta,p}^{z, b} = \mathrm{e}^{\mathrm{i} z \theta} p^b$ 。
对称性条件 $C=1$ 的条件为
\begin{equation}
\begin{aligned}
1 &= \prod_{r=0}^{R-1} U_{\theta,p}^{z_r, b_r} \\
&= \prod_{r=0}^{R-1} \mathrm{e}^{\mathrm{i} z_r \theta} p^{b_r} \\
&= \mathrm{e}^{\mathrm{i} \sum_{r=0}^{R-1} z_r \theta} p^{\sum b_r} \quad \forall \theta, p ,
\end{aligned}
\end{equation}
即 $\sum_{r=0}^{R-1} z_r = 0$ 且 $\bigoplus_{r=0}^{R-1} b_r = 0$ 。
故而有
\begin{equation}
\begin{aligned}
&C_{U(1)\times Z(2)} ( (z_0, b_0), (z_1, b_1), \cdots (z_{R-1}, b_{R-1}) ) \\
= &C_{U(1)} (z_0, z_1, \cdots z_{R-1}) C_{Z(2)} (b_0, b_1, \cdots b_{R-1}),
\end{aligned}
\end{equation}
可见对于乘积群，对称性张量非零的条件是满足所有子群的对称性条件：对称性条件为各个子群的对称性条件的乘积：
\begin{equation}
C_{\prod_i G_i} = \prod_i C_{G_i} .
\end{equation}

综上所述，Abel群的对称性张量是一个由对称性条件决定的分块张量，由对称性张量所构成的张量网络整体依然满足这个对称性。
对于已知满足某个对称性的波函数来说，使用对称性张量所构成的张量网络来表示能够很好的减少网络参数。

*** 费米子张量 <<sec:::费米子张量>>

费米子系统中，由于反对易的性质，大部分用于表示费米子系统波函数的方法需要进行Jordan-Wigner变换，即：
\begin{equation}\label{eq:Jordan-Wigner变换}
\left\{
\begin{aligned}
f_i^\dag &= \mathrm{e} ^{+\mathrm{i} \pi \sum_{j=0}^{i-1} a_j^\dag a_j}  a_i^\dag \\
f_i &= \mathrm{e} ^{-\mathrm{i} \pi \sum_{j=0}^{i-1} a_j^\dag a_j}  a_i .
\end{aligned}
\right.
\end{equation}
其中 $a_i^\dag$ 和 $a_i$ 为硬核玻色子的产生湮灭算符，或者说是自旋的上升下降算符。
通过此变换，构造出来的 $f_i^\dag$ 和 $f_i$ 拥有费米子的反对易性质。
这意味这，我们可以将费米子系统的哈密顿量中所有的粒子算符，使用公式 [[eqref:eq:Jordan-Wigner变换]] 进行替换，从而得到了一个非玻色子的系统。

Jordan-Wigner变换要求给所有的费米子模式排列成一维序列，并让所有的产生湮灭算符添加一个包含序列前面所有粒子粒子数的相位表达式。
对于一维的近临相互作用来说，这种情况不会有太大问题，因为相位表达式中大部分项目都会相互抵消，
比如：
\begin{equation}
\begin{aligned}
f_{i+1}^\dag f_i
&= \mathrm{e}^{+\mathrm{i}\pi \sum_{j=0}^{i} a_j^\dag a_j} a_{i+1}^\dag \mathrm{e}^{-\mathrm{i} \pi \sum_{j=0}^{i-1} a_j^\dag a_j} a_i \\
&= \mathrm{e}^{+\mathrm{i}\pi a_i^\dag a_i} a_{i+1}^\dag a_i ,
\end{aligned}
\end{equation}
可见一维情况的近临相互作用经过Jordan-Wigner变换后依然是近临相互作用。

但是对于二维系统来说，将所有物理边排列成一行后，原本行间的近临相互作用变成了长程的相互作用，如：
\begin{equation}
f_{i+1,j}^\dag f_{i,j} = \mathrm{e} ^ {+\mathrm{i}\pi (\sum_{k=j}^{L_2-1} a_{i,k}^\dag a_{i,k} + \sum_{k=0}^{j-1} a_{i+1,k}^\dag a_{i+1,k})} a_{i+1,j}^\dag a_{i,j} .
\end{equation}
所以即使只有近临相互作用的二维系统，进行Jordan-Wigner变换时，也会引入大量的交换费米子产生的相位符号，并且这是多体且长程的。
当应用Jordan-Wigner变换于张量网络态时，这种长程相互作用，会极大地削弱张量网络态的表示能力。

一种针对费米子的张量网络态可以解决这个问题 [[cite:Dong2019]] 。
考虑公式 [[eqref:eq:投影纠缠对阐述的一般张量网络]] ，这种张量网络态的阐述中，
使用母态中的纠缠对建立关联，并使用投影算子将母态投影到真实的物理空间中。
如果直接将母态中的物理产生算符替换成真实的费米子产生算符，会破坏原本的网络中，
各个张量和各个边所表示的收缩运算可以随意交换次序的性质。
我们但是我们可以退而求其次，假设包含物理粒子的物理纠缠对，即表示物理边的每组纠缠对
\begin{equation}
P_{\text{物理}, r} = a_{r+B,0}^{\dag d_{r+B}} c_r^{\dag d_{r+B}} ,
\end{equation}
整体呈现没有费米子的性质。
即设 $a_{r+B}^{\dag d_{r+B}}$ 和 $c_r^{\dag d_{r+B}}$ 对于不同的 $d_{r+B}$ 始终拥有相同的费米子奇偶性。
这样的话，母态中产生物理粒子的部分，即张量网络中的物理边，整体是一个玻色的算符，可以随意交换顺序。
类似的，对于每组虚拟纠缠对
\begin{equation}
P_{\text{虚拟}, b} = a_{b,0}^{\dag d_b} a_{b,1}^{\dag d_b} ,
\end{equation}
我们也可以将其中的某些替换成费米子的纠缠对，这样依然可以保持这些纠缠对整体的玻色性质。
然而，当我们将物理纠缠对和虚拟纠缠对中一部分粒子替换为费米子后，
投影算符中的湮灭算符也对应地变成了费米子，
整体并不能再随意交换了。

考虑到凝聚态物理中，大部分系统的费米子数目是守恒的，即系统至少满足 $U(1)$ 对称性。
我们可以将这个条件先弱化为 $Z(2)$ 对称性，按照 [[ref:sec:::对称性张量]] 中的结论，
我们可以使用 $Z(2)$ 对称性张量来构成表示这个系统的张量网络态。
此时，每个张量网络中的每个张量都是在 $Z(2)$ 对称性变化下不变的分块张量，
公式 [[eqref:eq:投影纠缠对阐述的一般张量网络]] 中投影算符可以写为：
\begin{equation}
\begin{aligned}
P_{\text{投影}, n} =
&(A_{n, (s_0, s_1, \cdots s_{R-1})})_{\alpha_{s_0}, \alpha_{s_1}, \cdots \alpha_{s_{R-1}}} \\
&C(s_0, s_1, \cdots s_{R-1}) \\
&\prod_{j=0}^{\mathrm{rank}(A_n) - 1} 
a^{(s_j, \alpha_{s_j})}_{X_{A_n,j},Y_{A_n, j}} ,
\end{aligned}
\end{equation}
由于只涉及到单个张量，这里为了便利省略了指标中表示张量所有的标记，即将 $s_{A_n,j}$ 写成了 $s_{j}$ 。

这里的 $C(s_0, s_1,\cdots s_{R-1})$ 为公式 [[eqref:eq:Z2对称性条件]] 所描述的 $Z(2)$ 群的对称性条件。
容易验证，当 $C(s_0, s_1, \cdots s_{R-1}) \neq 0$ 时，湮灭算子部分
\begin{equation}
\prod_{j=0}^{\mathrm{rank}(A_n) - 1} 
a^{(s_j, \alpha_{s_j})}_{X_{A_n,j},Y_{A_n, j}}
\end{equation}
一定是玻色的。
这保证了投影算子的每个非零项都是玻色的，所以投影算子整体是玻色的，
从而我们可以对正常的张量一样，随意交换投影算子。

由此可见，我们可以使用 $Z(2)$ 对称性的张量加上含有费米子的纠缠对湮灭算符，
作为费米子张量来构造用于描述费米子系统的张量网络。
这种情况下，我们必须使用纠缠对阐述来理解张量网络态，因为我们需要在母态中包含含有费米子的纠缠对产生算符。

对于费米子张量来说，我们也可以使用更强的 $U(1)$ 对称性，因为更强的对称性对分块有着更强的限制，
对称性条件依然能保证有费米子性质的元素一定为零。
而为了确保费米子张量的可交换性质，一定存在某个对称性。为了区分，我们将这种对称性前面加上词缀 `fermi-' ，
如 fermi-$U(1)$ 对称性 或者 fermi-$Z(2)$ 对称性。
而纠缠对中体现对称性的粒子不是费米子时，我们在对称性前面加上词缀 `bose-' ，如
bose-$U(1)$ 对称性或者bose-$Z(2)$ 对称性。
同样，我们可以将这些对称群进行乘积，比如 fermi-$U(1) \times$ bose-$U(1)$ 对称性，
其可以同时描述电子数和z方向自旋的守恒。

综上所述，费米子张量由某个群的对称性张量和含有费米子的纠缠对构成。
对称性张量即分块的张量，他的每个边上的每个维度都有一个对称群表示的属性，这些属性共同确定了张量分块的方案。
而一组纠缠对的性质中，每个纠缠对是否是费米的性质可以完全由张量边上的对称群表示确定，
但是每个张量边上的湮灭算子到底湮灭的是纠缠对中靠前的那个粒子还是靠后的那个粒子是不确定的。
为此，我们需要给每个边额外加上一个属性，标记这个边对应的产生算符处于纠缠对中的哪一个。
本论文中，使用一个名为费米箭头的布尔数标记纠缠对中的先后顺序：0表示在纠缠对中靠前，1表示在纠缠对中靠后。
当两个张量的边相连时，两个张量的边湮灭的是纠缠对中的两个粒子，必然一个靠前一个靠后，
所以彼此相连的两个边上的费米箭头必然一个为0一个为1。

** 费米子张量上的张量操作 <<sec::费米子张量上的张量操作>>

费米子张量中，
对称性张量的各种张量操作过程中与寻常的张量没有差别，
而纠缠对中引入费米子却会改变几乎所有的张量操作，
现在我们需要对各种张量运算一个一个考虑费米子的影响。

*** 张量转置

张量转置是寻常张量中特别普遍的操作。寻常的张量转置仅仅是数据的重新排列，
但是对于费米子张量，边的顺序关系到了湮灭算符的顺序：
交换湮灭算符时，会产生符号。

考虑投影子
\begin{equation}
P_n = 
(A_n)_{i_{0} i_{1} \cdots}
a_0^{i_0} a_1^{i_1} \cdots ,
\end{equation}
交换相邻的两个湮灭算符，如第 $j$ 和第 $j+1$ 个湮灭算符时，如果 $p(a_j^{i_j}) p(a_{j+1}^{i_{j+1}}) = 1$ 则会产生符号，
如果为 $0$ 则不会产生符号，
其中
\begin{equation}
p (a) = \left\{\begin{aligned}
1  \quad & \text{如果} a \text{是费米的} \\
0  \quad & \text{如果} a \text{是玻色的} .
\end{aligned}\right.
\end{equation}
为了简单表述，我们称呼这时产生了 $p(a_j^{i_j}) p(a_{j+1}^{i_{j+1}})$ 个符号。

注意到费米子张量是分块的张量，每个分块上的边上有着相同的对称群表示，所以他们湮灭算符的费米子奇偶性也是一样的，
故张量转置时，每个分块产生的符号数是一样的，这为具体实现提供了很大的便利，
因为我们可以一个分块一个分块地分析符号，而不必每个元素单独分析一遍。

当进行更加复杂的转置时，可以分解为多个近临的湮灭算符交换，容易验证：
\begin{equation}
\begin{aligned}
P_n &= 
(A_n)_{i_{0} i_{1} \cdots}
a_0^{i_0} a_1^{i_1} \cdots \\
&= (A'_n)_{i_{s_0} i_{s_1} \cdots} a_{s_0}^{i_{s_0}} a_{s_1}^{i_{s_1}} \cdots ,
\end{aligned}
\end{equation}
其中 $s_0, s_1, \cdots$ 为一个排列，描述了如何转置，而 $A'_n$ 满足：
\begin{equation}
(A'_n)_{i_{s_0} i_{s_1}\cdots} = (A_n)_{i_0 i_1 \cdots} (-1)^{\sum_{j<k,s_j>s_k} p(a_j^{i_j}) p(a_k^{i_k})} .
\end{equation}

*** 张量的共轭

共轭用于将波函数从希尔伯特空间转换到对偶空间，从而进行内积运算。
寻常的张量网络所表示的态进行共轭可以表示为每个张量都取共轭后所组成的张量网络。
对于费米子张量网络，依然有类似的性质。

考虑波函数 $P M | \Omega\rangle$ ，其中 $P$ 和 $M$ 为公式 [[eqref:eq:投影纠缠对阐述的一般张量网络]] 所展示，
求共轭得到 $\langle \Omega | M^\dag P^\dag$ ，其中
\begin{equation}
\left\{
\begin{aligned}
M^\dag &=
\prod_{b=0}^{B-1} a_{b,1}^{d_b} a_{b,0}^{d_b}
\prod_{r=0}^{R-1} c_r^{d_{r+B}} a_{r+B,0}^{d_{r+B}} , \\
P^\dag &= 
\prod_{n=0}^{N-1} (A_n)^\dag_{i_{A_n, 0} i_{A_n, 1} \cdots i_{A_n, \mathrm{rank}(A_n) -1}}
\prod_{j=\mathrm{rank}(A_n) - 1}^{0}
a^{\dag i_{A_n, j}}_{X_{A_n,j},Y_{A_n, j}} . \\
\end{aligned}
\right.
\end{equation}
这里 $P^\dag$ 可以先恢复所有的产生算符的顺序得到
\begin{equation}
P^\dag = 
\prod_{n=0}^{N-1} (-1)^{\sum_{j<k} p(a_j^{i_j}) p(a_k^{i_k})}
(A_n)^\dag_{i_{A_n, 0} i_{A_n, 1} \cdots i_{A_n, \mathrm{rank}(A_n) -1}}
\prod_{j=0}^{\mathrm{rank}(A_n) - 1}
a^{\dag i_{A_n, j}}_{X_{A_n,j},Y_{A_n, j}} . \\
\end{equation}
然而现在，无论是纠缠对的母态 $M^\dag$ 还是投影子中的产生算符，都不符合费米子张量的形式，下面我们一步步地恢复原本的形式。

当计算某个物理量时，真正计算的是
\begin{equation}
\langle \Psi^\dag_1 |O| \Psi_2 \rangle = \langle \Omega | P^\dag_1 M^\dag_1 O M_2 P_2 | \Omega \rangle ,
\end{equation}
考虑其中某组虚拟粒子所在的子空间，表达式为
\begin{equation}
\langle \Omega | a^{d_1} a^{\dag d_2} a^{d_3} a^{\dag d_4} | \Omega \rangle  ,
\end{equation}
其中 $a^{d_1}$ ， $a^{d_2}$ ， $a^{d_3}$ ， $a^{d_4}$ 分别是  $P^\dag_1$ ， $M^\dag_1$ ， $M_2$ ， $P_2$ 中这组粒子的算符，
注意这些算符中的上标 $d_i$ 指的是不同的粒子。
我们可以将共轭空间中的虚拟粒子替换成新的虚拟粒子，其结果依然不变，得到
\begin{equation}
\langle \Omega | a^{d_1} a^{\dag d_2} a^{d_3} a^{\dag d_4} | \Omega \rangle =
\langle \Omega | a'^{d_1} a'^{\dag d_2} a^{d_3} a^{\dag d_4} | \Omega \rangle .
\end{equation}
综上，我们考虑共轭后的张量网络时，可以完全不考虑希尔伯特空间中相同的虚拟粒子的影响。

而对于连接两个张量 $P_x$ 和 $P_y$ 的虚拟边，考虑每个元素，我们可以将湮灭算符对往后面移动：
\begin{equation}
\begin{aligned}
&\overbrace{\left(\cdots (a'_1 a'_0) \cdots\right)}^{M^\dag}
\underbrace{\cdots \overbrace{\left(\cdots a_0^{\prime \dag} \cdots\right)}^{P^\dag_x} \cdots \overbrace{\left(\cdots a_1^{\prime \dag} \cdots\right)}^{P^\dag_y} \cdots}_{P^\dag} \\
= &\left(\cdots\right)\cdots \left(\cdots a'_1 a'_0 a_0^{\prime \dag} \cdots\right) \cdots \left(\cdots a_1^{\prime \dag} \cdots\right)\cdots \\
= &\left(\cdots\right)\cdots \left(\cdots a'_1 \cdots\right) \cdots \left(\cdots a'_0 a_0^{\prime \dag} a_1^{\prime \dag} \cdots\right)\cdots \\
= &\left(\cdots\right)\cdots \left(\cdots a'_1 \cdots\right) \cdots \left(\cdots a'_0 \cdots\right)\cdots (a_0^{\prime \dag} a_1^{\prime \dag}) .
\end{aligned}
\end{equation}
可见所有的虚拟边的共轭，都可以看作正常的费米子张量的费米箭头进行了翻转。

类似的，对于物理边，考虑每一个元素，我们一样可以将 $M^\dag$ 中的算符向后一定：
\begin{equation}
\begin{aligned}
&\overbrace{\left(\cdots (c a') \cdots\right)}^{M^\dag}
\underbrace{\cdots \overbrace{\left(\cdots a'^\dag \cdots\right)}^{P^\dag_n} \cdots}_{P^\dag} \\
= &\left(\cdots\right) \cdots \left(\cdots c a' a'^\dag \cdots\right) \cdots \\
= &\left(\cdots\right) \cdots \left(\cdots a' a'^\dag c \cdots\right) \cdots \\
= &\left(\cdots\right) \cdots \left(\cdots a' \cdots\right) \cdots (a'^\dag c) .
\end{aligned}
\end{equation}
而 $(a'^\dag c)$ 最终将和原空间中的 $(a^\dag c^\dag)$ 组合， 恢复张量网络的求和的形式，相关项目为：
\begin{equation}
\begin{aligned}
\sum_{d'} a'^{\dag {d'}} c^{d'} \sum_d a^{\dag d} c^{\dag d}
&= \sum_{d d'} a^{\dag d} a'^{\dag {d'}} c^{d'} c^{\dag d} \\
&= \sum_{d d'} a^{\dag d} a'^{\dag d'} \delta_{d d'} \\
&= \sum_{d} a^{\dag d} a'^{\dag d} .
\end{aligned}
\end{equation}
这意味这，我们可以简单地认为物理的产生算符在表示整个 $\langle \Psi_1 | O | \Psi_2 \rangle$ 的张量网络中是一个普通的边，
他对应的纠缠对中的产生算副靠前，而类似的，共轭空间中的湮灭算符在纠缠对中靠后。
这样不必再像公式 [[eqref:eq:投影纠缠对阐述的一般张量网络]] 中的 $M$ 那样将物理边和虚拟边分开对待。

综上所述，当我们对一个费米子张量进行共轭时，我们需要
1. 对每个元素取共轭；
2. 加上一个全转置的符号 $(-1)^{\sum_{j<k} p(a_j^{i_j}) p(a_k^{i_k})}$ ；
3. 将所有的费米箭头翻转。

*** 翻转费米箭头

费米箭头用于表示纠缠对中产生算符的顺序，而调换产生算符的顺序常用于其他运算的预处理中。
考虑两个投影子以及母态中的纠缠对产生算符：
\begin{equation}
\begin{aligned}
P M =
&(A_n)_{i_{0} i_{1} \cdots} a_0^{i_0} a_1^{i_1} \cdots \\
&(B_n)_{j_{0} j_{1} \cdots} b_0^{j_0} b_1^{j_1} \cdots \\
& a_x^{\dag d} b_y^{\dag d} ,
\end{aligned}
\end{equation}
其中 $A$ 的第 $x$ 个边与 $B$ 的第 $y$ 个边相连，
交换纠缠对中的两个产生算符得到
\begin{equation}
\begin{aligned}
P M =
&(A_n)_{i_{0} i_{1} \cdots} a_0^{i_0} a_1^{i_1} \cdots \\
&(B_n)_{j_{0} j_{1} \cdots} b_0^{j_0} b_1^{j_1} \cdots \\
& (-1)^{p(a_x^{\dag d}) p(b_y^{\dag d})} b_y^{\dag d} a_x^{\dag d} .
\end{aligned}
\end{equation}
可见当我们翻转两个张量彼此相连的边上的费米箭头时，只产生了一个符号，
不妨将它放置在 $A$ 中，得到：
\begin{equation}
\begin{aligned}
P M =
& (-1)^{p(a_x^{i_x})} (A_n)_{i_{0} i_{1} \cdots} a_0^{i_0} a_1^{i_1} \cdots \\
&(B_n)_{j_{0} j_{1} \cdots} b_0^{j_0} b_1^{j_1} \cdots \\
& b_y^{\dag d} a_x^{\dag d} ,
\end{aligned}
\end{equation}
其中我们用到了
\begin{equation}\label{eq:翻转箭头时的符号推导}
\begin{aligned}
p(a_x^{\dag d}) p(b_y^{\dag d}) &= p(a_x^{\dag d}) ^ 2 \\
&= p(a_x^{\dag d}) \\
&= p(a_x^{i_x}) .
\end{aligned}
\end{equation}
公式 [[eqref:eq:翻转箭头时的符号推导]] 中第一行的等式来自纠缠对中两个粒子拥有相同的费米子奇偶性；
第二行的等式来自对于任意 $a$ ， $p(a)$ 取 $0$ 或者 $1$ ；
第三行的等式来自于整个张量网络中在 $a_x$ 这个粒子的子空间上的分量为
\begin{equation}
\langle \Omega | a^{i_x} a_x^{\dag d} |\Omega\rangle = \delta_{i_x, d} ,
\end{equation}
从而 $i_x \neq d$ 时，张量网络整体都为 $0$ 的事实。

类似的，我们也可以将符号放置在 $B$ 中，从而得到：
\begin{equation}
\begin{aligned}
P M =
& (A_n)_{i_{0} i_{1} \cdots} a_0^{i_0} a_1^{i_1} \cdots \\
& (-1)^{p(b_y^{j_y})}(B_n)_{j_{0} j_{1} \cdots} b_0^{j_0} b_1^{j_1} \cdots \\
& b_y^{\dag d} a_x^{\dag d} .
\end{aligned}
\end{equation}
在实现费米子张量时，我们需要注意在一个网络内翻转费米箭头时，只能会产生一个符号，需要选择放在相连接的两个张量中的哪一个内。
而对于复数张量，我们完全可以产生半个符号即：
\begin{equation}
\begin{aligned}
P M =
& \mathrm{i}^{p(a_x^{i_x})} (A_n)_{i_{0} i_{1} \cdots} a_0^{i_0} a_1^{i_1} \cdots \\
& \mathrm{i}^{p(b_y^{j_y})}(B_n)_{j_{0} j_{1} \cdots} b_0^{j_0} b_1^{j_1} \cdots \\
& b_y^{\dag d} a_x^{\dag d} .
\end{aligned}
\end{equation}

*** 边的合并与拆分

对于寻常张量，边的合并与拆分是很常见的，比如将矩阵视为一个向量，实际上就是将二阶张量的两个边合并为一个边的过程。
对于寻常的稠密张量，边的合并与拆分并不需要真正的数据移动或变换，但是对于对称性张量来说，数据移动是不可避免的。
假设相邻的两个边，其对称群表示分别是 $(s_0^0, s_0^1, \cdots s_0^{d_0-1})$ 和 $(s_1^0, s_1^1, \cdots s_1^{d_1-1})$ ，
其中 $d_0$ 和 $d_1$ 分别是两个边的总维度。
合并成一个边后，群表示为：
\begin{equation}
\begin{aligned}
( &S(s_0^0, s_1^0), S(s_0^0, s_1^1), \cdots S(s_0^0, s_1^{d_1-1}), \\
  &S(s_0^1, s_1^0), S(s_0^1, s_1^1), \cdots S(s_0^1, s_1^{d_1-1}), \\
  &\cdots \\
  &S(s_0^{d_0-1}, s_1^0), S(s_0^{d_0-1}, s_1^{d_0-1}), \cdots S(s_0^{d_0-1}, s_1^{d_1-1})) ,
\end{aligned}
\end{equation}
其中 $S$ 满足：
\begin{equation}
U_g^{s_0} U_g^{s_1} = U_g^{S(s_0, s_1)} , \forall g \in G .
\end{equation}

不难看出，对于 $Z(2)$ 群来说，群表示使用 $0$ 和 $1$ 标记， $S$ 则是布尔异或运算，其构成了表示空间上的 $Z(2)$ 群；
而对于 $U(1)$ 群来说，群表示使用整数标记， $S$ 则是整数加法运算，其构成了表示空间上的 $Z$ 群。
对于更加复杂的Abel群，群表示空间为子群的群表示空间的乘积，
我们可以直接使用子群们的表示空间群的乘积来得到自己的表示空间群，从而得到 $S$ 运算。
当我们得到合并后的边的对称群表示后，我们通常需要再交换各个维度，将相同对称群表示的维度放在一起，从而保证张量的分块数目尽可能地少。

而对于费米子张量，边上的对称群表示需要按照对称性张量的规则做变换外，纠缠对也需要进行变换。
仍然以合并两个相邻的边为例，考虑：
\begin{equation}
\begin{aligned}
P M =
&(A_n)_{i_{0} i_{1} \cdots} \left(\cdots a_x^{i_x} a_{x+1}^{i_{x+1}} \cdots\right)\\
&(B_n)_{j_{0} j_{1} \cdots} \left(\cdots b_y^{j_y} b_{y+1}^{j_{y+1}} \cdots\right) \\
&\left( a_x^{\dag d_0} b_y^{\dag d_0} \right) \left( a_{x+1}^{\dag d_1} b_{y+1}^{\dag d_1} \right) ,
\end{aligned}
\end{equation}
当我们合并边时，纠缠对也需要合并，得到：
\begin{equation}
\begin{aligned}
P M =
&(A_n)_{i_{0} i_{1} \cdots} \left(\cdots a_x^{i_x} a_{x+1}^{i_{x+1}} \cdots\right)\\
&(B_n)_{j_{0} j_{1} \cdots} \left(\cdots b_y^{j_y} b_{y+1}^{j_{y+1}} \cdots\right) \\
&
(-1)^{p(b_y^{d_0}) p(b_{y+1}^{d_1})}
(a_x^{d_0}a_{x+1}^{d_1})^\dag
(b_y^{d_0} b_{y+1}^{d_1})^\dag
.
\end{aligned}
\end{equation}
类似翻转费米箭头的情况，我们可以选择将产生的单个符号放在 $A$ 中或者 $B$ 中：
\begin{equation}
\begin{aligned}
PM=
&
(-1)^{p(a_x^{i_x}) p(a_{x+1}^{i_{x+1}})}
(A_n)_{i_{0} i_{1} \cdots} \left(\cdots a_x^{i_x} a_{x+1}^{i_{x+1}} \cdots\right)\\
&
(B_n)_{j_{0} j_{1} \cdots} \left(\cdots b_y^{j_y} b_{y+1}^{j_{y+1}} \cdots\right) \\
&
(a_x^{d_0}a_{x+1}^{d_1})^\dag
(b_y^{d_0} b_{y+1}^{d_1})^\dag
,
\end{aligned}
\end{equation}
或者
\begin{equation}
\begin{aligned}
PM=
&(A_n)_{i_{0} i_{1} \cdots} \left(\cdots a_x^{i_x} a_{x+1}^{i_{x+1}} \cdots\right)\\
&
(-1)^{p(b_y^{j_y}) p(b_{y+1}^{j_{y+1}})}
(B_n)_{j_{0} j_{1} \cdots} \left(\cdots b_y^{j_y} b_{y+1}^{j_{y+1}} \cdots\right) \\
&
(a_x^{d_0}a_{x+1}^{d_1})^\dag
(b_y^{d_0} b_{y+1}^{d_1})^\dag
.
\end{aligned}
\end{equation}

如果要合并并非相连的两个边，需要进行张量的转置，
而如果要合并费米箭头不一致的两个边，需要先对费米箭头进行翻转。
容易验证，对于合并连续的 $l$ 个边，其产生的符号等于这些合并的边的全转置产生的符号：
\begin{equation}
\begin{aligned}
PM=
&
(-1)^{\sum_{m<n} p(a_m^{i_m}) p(a_n^{i_n})}
(A_n)_{i_{0} i_{1} \cdots} \left(\cdots a_x^{i_x} a_{x+1}^{i_{x+1}} \cdots a_{x+l-1}^{i_{x+l-1}} \cdots\right)\\
&
(B_n)_{j_{0} j_{1} \cdots} \left(\cdots b_y^{j_y} b_{y+1}^{j_{y+1}} \cdots b_{y+l-1}^{j_{y+l-1}} \cdots\right) \\
&
(a_x^{d_0}a_{x+1}^{d_1}\cdots a_{x+l-1}^{d_{l-1}})^\dag
(b_y^{d_0} b_{y+1}^{d_1}\cdots b_{y+l-1}^{d_{l-1}})^\dag
,
\end{aligned}
\end{equation}
或者
\begin{equation}
\begin{aligned}
PM=
&
(A_n)_{i_{0} i_{1} \cdots} \left(\cdots a_x^{i_x} a_{x+1}^{i_{x+1}} \cdots a_{x+l-1}^{i_{x+l-1}} \cdots\right)\\
&
(-1)^{\sum_{m<n} p(b_m^{j_m}) p(b_n^{j_n})}
(B_n)_{j_{0} j_{1} \cdots} \left(\cdots b_y^{j_y} b_{y+1}^{j_{y+1}} \cdots b_{y+l-1}^{j_{y+l-1}} \cdots\right) \\
&
(a_x^{d_0}a_{x+1}^{d_1}\cdots a_{x+l-1}^{d_{l-1}})^\dag
(b_y^{d_0} b_{y+1}^{d_1}\cdots b_{y+l-1}^{d_{l-1}})^\dag
,
\end{aligned}
\end{equation}


值得一提的是，这些产生算符组合而来的复合粒子产生算符依然可以作为张量网络中的纠缠对，因为依然有
\begin{equation}
(b_y^{d'_0} b_{y+1}^{d'_1}\cdots b_{y+l-1}^{d'_{l-1}})
(b_y^{d_0} b_{y+1}^{d_1}\cdots b_{y+l-1}^{d_{l-1}})^\dag
=
\delta_{d_0 d'_0}
\delta_{d_1 d'_1}
\cdots
\delta_{d_{l-1} d'_{l-1}}
\end{equation}

在计算 $\sum_{m<n} p_m p_n$ 原本的两层循环可以使用一个技巧压缩为一层循环：
\begin{equation}
\begin{aligned}
\sum_{m<n} p_m p_n
&= \frac{\sum_{m,n} p_m p_n - \sum_{n} p_n^2}{2} \\
&= \frac{(\sum_{n} p_n)^2 - \sum_{n} p_n}{2} .
\end{aligned}
\end{equation}
由于它出现在 $-1$ 的指数上，我们只关注它的二进制第一位，即只关注$(\sum_{n} p_n)^2 - \sum_{n} p_n$ 的二进制第二位，
而对于任意 $x$ ， $x^2 - x$ 的二进制第二位和 $x$ 的二进制第二位相同，所以
\begin{equation}
(-1)^{\sum_{m<n} p_m p_n}
=
(-1)^{ \frac{2 \& \sum_n{p_n} }{ 2 }} ,
\end{equation}
其中 $\&$ 为按位与。

对于边的拆分，由于它是边的合并的逆运算，其产生的符号和边的合并产生的符号完全一样。

*** 张量的收缩

张量的收缩即将两个相连的张量的公共边的所有维度进行求和。
为了收缩两个费米子张量，我们可以按照合并边、做含有费米子的矩阵乘法，拆分边的思路来实现费米子张量的收缩。
接下来，我们介绍一种具体的方案。

对于两个费米子张量 $A$ 和 $B$ ，它们的边分为两组，即公共边和自由边：公共边连接了彼此，而其他边都是自由边。为了进行收缩，我们依次做：
+ 张量转置：将 $A$ 中所有的自由边放置在左侧，公共边放置在右侧，而 $B$ 中所有的公共边放置在左侧，自由边放置在右侧。
+ 翻转费米箭头：
  将 $A$ 中所有自由边的费米箭头翻转到位置 $0$ ，如果产生符号，则符号不放在本张量中；
  将 $A$ 中所有公共边的费米箭头翻转到位置 $1$ ，如果产生符号，则符号放在本张量中；
  将 $B$ 中所有自由边的费米箭头翻转到位置 $0$ ，如果产生符号，则符号不放在本张量中；
  将 $B$ 中所有公共边的费米箭头翻转到位置 $0$ ，如果产生符号，则符号不放在本张量中。
+ 边的合并：合并 $A$ 和 $B$ 中所有的公共边和自由边， 得到
\begin{equation}
\left\{
\begin{aligned}
P_A &= A_{i_0 i_1} a_0^{i_0} a_1^{i_1} ,\\
P_B &= B_{j_0 j_1} b_0^{j_0} b_1^{j_1} ,\\
M &= b_0^{\dag d} a_1^{\dag d} ,
\end{aligned}
\right.
\end{equation}
  其中，
  $A$ 的自由边合并时如果产生符号，则不放在本张量中；
  $A$ 的公共边合并时如果产生符号，则放在本张量中；
  $B$ 的自由边合并时如果产生符号，则不放在本张量中；
  $B$ 的公共边合并时如果产生符号，则不放在本张量中；
+ 矩阵乘法：直接进行矩阵乘法：
\begin{equation}
\begin{aligned}
P_A P_B M
&=
A_{i_0 i_1}a_0^{i_0} a_1^{i_1}
B_{j_0 j_1}b_0^{j_0} b_1^{j_1}
b_0^{\dag d} a_1^{\dag d} \\
&=
A_{i_0 i_1}
B_{j_0 j_1}
\delta_{j_0 i_1}
a_0^{i_0}
b_1^{j_1}.
\end{aligned}
\end{equation}
+ 边的拆分：拆分剩下的两个自由边，恢复张量原本的形状，产生的符号一律不放在本张量中。
+ 翻转费米箭头：
  将费米箭头翻转到 $A$ 和 $B$ 中原本的位置，产生的符号一律不放在本张量中。

在这个方案中，公共边的合并与费米箭头翻转产生的符号都放且仅放在张量 $A$ 中了。
而对于自由边的合并与第一次费米箭头翻转，完全和自由边的拆分与第二次翻转相互抵消。
由此，我们可以将费米子的张量收缩转换成对称性矩阵的矩阵乘法，即分块的矩阵乘法。

*** 张量的分解

张量的分解即张量变形为矩阵后的矩阵分解，包括QR分解，奇异值分解等。
作为张量收缩的逆操作，我们完全可以讲张量收缩的方案倒过来，作为张量分解的方案，除了最中间的矩阵乘法，替换为矩阵分解。
下面我们介绍一种张量分解的方案。

对于矩阵 $A$ ，我们要将它分解为 $A = B \prod_{k=0}^{K-1} C_k D$ 。
对于奇异值分解，我们有
\begin{equation}
\left\{
\begin{aligned}
B &= U \\
D &= V \\
K &= 1 \\
C_0 &= S.
\end{aligned}
\right.
\end{equation}
对于QR分解，我们有
\begin{equation}
\left\{
\begin{aligned}
B &= Q \\
D &= R \\
K &= 0 .
\end{aligned}
\right.
\end{equation}
对于LQ分解，我们有
\begin{equation}
\left\{
\begin{aligned}
B &= L \\
D &= Q \\
K &= 0 .
\end{aligned}
\right.
\end{equation}
为了进行张量的分解，我们沿着反方向的矩阵收缩过程，依次做：
+ 张量转置：
  将 $A$ 中的各个边调整到合适的位置，即最终出现在 $B$ 中的边放在左侧，而最终出现在 $D$ 中的边放在右侧。
+ 翻转费米箭头：
  讲张量 $A$ 中所有的费米箭头翻转到位置 $0$ ，如果产生了符号，则符号不放置在张量中。
+ 边的合并：
  将 $A$ 中所有最终出现在 $B$ 中的边合并成一个边，而最终出现在 $D$ 中的边合并成另一个边，如果产生了符号，则符号不放置在张量中。
+ 矩阵分解：直接进行矩阵分解：
\begin{equation}
\begin{aligned}
A_{i_0 i_1} a_0^{i_0} a_1^{i_1} =
&\left( B_{i_0 j_1} \prod_{j=0}^{K-1} C_{j_k, j_{k+1}} D_{j_K, i_1} \right) a_0^{i_0} a_1^{i_1}\\
=
&B_{i_0, j_0} a_0^{i_0} b_0^{j_0} \\
&\prod_{k=0}^{K-1} C_{j'_k, j_{k+1}} c_0^{j'_k} b_1^{j_{k+1}} \\
&D_{j'_{K}, i_1} c_K^{j'_K} a_1^{i_1} \\
&\prod_{k=0}^{K} c_k^{\dag d} b_k^{\dag d} .
\end{aligned}
\end{equation}
+ 边的拆分：拆分 $B$ 和 $D$ 中原先在 $A$ 中的边，恢复边原来的形状，如果产生了符号，则符号不放置在张量中。
+ 翻转费米箭头：将 $B$ 和 $D$ 中原先在 $A$ 中的边上的费米箭头翻转到原本的位置，如果产生了符号，则符号不放置在张量中。

类似张量的收缩，这种方法中，边的合并与第一次翻转费米箭头完全和边的拆分与第二次翻转费米箭头相互抵消。
而在矩阵分解的步骤中，在结果中选取合适的费米箭头，可以让计算成直接的分块张量分解，而没有任何其他的费米子性质。

*** 张量的迹

虽然大部分时候，求迹操作是多余的，但是求迹确实是一个基本操作。
为了对费米子张量进行求迹，我们可以将要求迹的两个边转置到相邻的位置上，并保证费米箭头为 $1$ 的边在费米箭头为 $0$ 的边的前方。
如此，对于将要对第 $x$ 个和第 $x+1$ 个边求迹的张量 $A$ ：
\begin{equation}
\def\a#1{a_{#1}^{i_{#1}}}
P_A = A_{i_0 i_1 \cdots i_{x-1} i_x i_{x+1} i_{x+2} \cdots} \a{0} \a{1} \cdots \a{x-1} \a{x} \a{x+1} \a{x+2} \cdots,
\end{equation}
我们可以得到
\begin{equation}
\def\a#1{a_{#1}^{i_{#1}}}
P_A \left(a_{x+1}^{\dag d} a_{x}^{\dag d} \right) = \left(\delta_{i_x i_{x+1}} A_{i_0 i_1 \cdots i_{x-1} i_{x} i_{x+1} i_{x+2}\cdots} \right) \a{0} \a{1} \cdots \a{x-1} \a{x+1} \cdots
\end{equation}
其中
\begin{equation}
\def\a#1{a_{#1}^{i_{#1}}}
\a{x} \a{x+1}a_{x+1}^{\dag d} a_{x}^{\dag d}
= \delta_{i_{x+1} d} \delta_{i_x d} = \delta_{i_x i_{x+1}} .
\end{equation}

*** 恒等张量

#+begin_export latex
\begin{figure}
\centering
\input{tikz/tensor-exp.tikz}
\caption{张量指数的幂展开}
\label{fig:张量指数的幂展开}
\note{注：张量的指数由幂展开所定义。
不同于矩阵，两个矩阵 $A$ 和 $B$ 相乘只有 $A B$ ，而张量相互收缩时，需要指定收缩时边的关系，即哪两个边应当彼此相连。
而幂展开中含有多个张量的收缩，所以在定义张量的指数时需要给定边之间的对应关系。
}
\end{figure}
#+end_export

有时我们需要得到一个恒等的张量，比如在计算张量的指数时，需要通过进行幂展开：
\begin{equation}
\mathrm{e}^{A} = \sum_{n=0}^{\infty} \frac{1}{n!} A^n ,
\end{equation}
其中的 $A^0$ 为恒等张量， 而 $A^n, n>0$  为多个 $A$ 的收缩。
以一个四阶张量 $A$ 为例，其指数的图形标记如图 [[ref:fig:张量指数的幂展开]] 所示。

恒等的费米子张量需要保证讲其插入两个相连的张量中结果不变，即：
\begin{equation}\label{eq:恒等张量的定义}
(a^{\dag d} b^{\dag d}) = I (a^{\dag d} a^{\prime \dag d}) (b^{\prime \dag d} b^{\dag d}) ,
\end{equation}
易得：
\begin{equation}\label{eq:恒等张量的结果}
I = \delta_{i j} b^{\prime i} a^{\prime j} .
\end{equation}
这里 $(a^{\dag d} b^{\dag d})$ 为表示两个相连张量所连接的边的纠缠对，
当我们插入恒等费米子张量时，我们实际上将这个纠缠对切割成了两个纠缠对，然后使用恒等张量这个投影子对这两个纠缠对进行投影，其结果应当保持不变。

根据公式 [[eqref:eq:恒等张量的定义]] 和公式 [[eqref:eq:恒等张量的结果]] 所展示，
恒等的费米子张量在将费米箭头在位置 $0$ 处的边放置在费米箭头在位置 $1$ 处的边前方时，费米子张量内部的对称性张量正好是寻常的恒等张量。

** 对称性张量网络态和费米子张量网络态

根据
[[ref:sec::对称性张量和费米子张量]]
和
[[ref:sec::费米子张量上的张量操作]]
中的介绍，我们知道对称性张量和费米子张量与寻常的张量一样，可以进行各种张量运算，且与寻常的张量一样，无论是张量还是张量操作都可以随意交换顺序。
通过将一张张量网络态中的张量替换成对称性张量或者费米子张量，我们可以得到用于表示某个特定对称群下不变的波函数或者是费米子的波函数。

本章节中，张量分为寻常的张量，对称性张量和费米子张量，这是为了引入时的便利而划分的。
但这种分类并不合理，因为寻常的张量也可以看作是平凡群下的对称性张量，而费米子张量在不做各种张量操作时，也能体现对称性张量的性质。
现在更改一下不同张量类型的名称约定，这将应用于本论文的整个下文中。
无论是何种张量，都认为是对称性张量，而寻常的张量，则称作是平凡群下的对称性张量。
对称性张量根据纠缠对中，体现对称性的粒子是否存在费米子，分为费米子对称性张量和非费米子对称性张量。
为了简单起见，费米子对称性张量也被称呼费米子张量，为非费米子张量也被称呼为玻色子对称性张量或者玻色子张量。

在第 [[sec:张量网络态算法]] 章我们将介绍与具体张量类型无关的各种张量网络态算法，其中提到的张量都指对称性张量。

* 张量网络态算法 <<sec:张量网络态算法>>

** 虚时间演化算法

*** 严格波函数的虚时间演化算法

对于一个正定的矩阵，其最大本征值以及对应的本征态可以通过幂法迭代就得，即给定任意初始态 $x_0$ 后，使用
\begin{equation}\label{eq:幂法迭代}
x_{n} = M x_{n-1} , \quad n > 0,
\end{equation}
进行迭代， $x_n$ 随着 $n \to \infty$ 会收敛到最大本征值对应的本征态上。

这是因为使用 $M$ 的本征态 $e_i$ 做基对 $x_0$ 分解后，我们得到：
\begin{equation}
x_0 = e_i a_0^i,
\end{equation}
而矩阵 $M$ 分解得到：
\begin{equation}
M = e_i \lambda_i e_i^\dag,
\end{equation}
其中 $\lambda_i$ 为 $M$ 的本征值 ， $\lambda_0 > \lambda_1 > \lambda_2 > \cdots > 0$ 。
公式 [[eqref:eq:幂法迭代]] 写在此基下为：
\begin{equation}
\begin{aligned}
x_{n} &= e_i a_{n}^i \\
&= M x_{n} \\
&= e_{i'} \lambda_{i'} e_{i'}^\dag e_i a_{n-1}^i \\
&= e_{i'} \lambda_{i'} \delta_{i i'} a_{n-1}^i \\
&= e_{i} \lambda_{i} a_{n-1}^i \\
&= e_{i} \lambda_{i}^n a_0^i ,
\end{aligned}
\end{equation}
即 $a_{n}^i = \lambda_i ^{n} a_0^i$ 。
最大本征值对应的本征态分量相比与其他本征态，比值为：
\begin{equation}\label{eq:幂法的系数比值}
\frac{\lambda_0^n a_0^0}{\lambda_i^n a_0^i} = \left(\frac{\lambda_0}{\lambda_i}\right)^n \frac{a_0^0}{a_0^i} , \quad i>0,
\end{equation}
而 $\frac{\lambda_0}{\lambda_i} > 1$ ， 故 $n \to \infty$ 时，只要 $a_0^0 \neq 0$ ， 即初态含有最大本征值的分量，公式 [[eqref:eq:幂法的系数比值]] 会趋向无穷大，可见最后将收敛到最大本征值对应的本征态。

对于哈密顿量为 $H$ 的系统，为了求得基态，可以使用 $M = \mathrm{e}^{- \tau H}$ 作为幂法中的矩阵进行迭代， 其中 $\tau > 0$ 。
$H$ 的本征值为 $\varepsilon_i$ ， $\varepsilon_0 < \varepsilon_1 < \varepsilon_2 < \cdots$ ，则 $M$ 的本征值为
$\lambda_i = \mathrm{e}^{- \tau \varepsilon_i}$ , $\lambda_0 > \lambda_1 > \lambda_2 > \cdots > 0$ 。
所以使用 $\mathrm{e}^{-\tau H}$ 迭代后，可以得到系统的基态，即：
\begin{equation}\label{eq:幂法虚时间演化}
\lim_{n\to\infty} \mathrm{e}^{-n\tau H} |\psi^0\rangle = |\psi^*\rangle ,
\end{equation}
其中 $| \psi^0 \rangle$ 为任意不和基态完全正交的初态， $|\psi^*\rangle$ 为基态。

如果将系统的无穷温时的密度矩阵 $\rho^0 = I$ 置入初态的位置，则迭代 $n$ 步后为：
\begin{equation}
\rho^n = \mathrm{e}^{-n \tau H} I = \mathrm{e}^{-\beta H} ,
\end{equation}
其中 $\beta = n \tau$ 。
而这便是系统温度为 $\frac{1}{\beta}$ 时的密度矩阵，可见，虚时间演化算法可以看成对系统的降温过程。

*** 逐块虚时间演化算法

严格的虚时间演化算法只能计算粒子数最多约 30 的系统，对于更大的系统，态空间的维度指数上升，无法严格表示波函数。
对于一维只有近临相互作用的系统，表示为矩阵乘积态后，可以使用逐块虚时演化算法求得基态。

对于哈密顿量 $H = H_0 + H_1 + \cdots H_{N-1}$ ，虚时间演化作用的算符是
\begin{equation}\label{eq:多项的Hamiltonian演化算符}
U = \mathrm{e}^{-\tau (H_0 + H_1 + \cdots H_{N-1})}.
\end{equation}
我们希望可以将其化为多个局部的算符作用的乘积，类似：
\begin{equation}
\def\expH#1{\mathrm{e}^{-\tau H_{#1}}}
U = \expH{0} \expH{1} \cdots \expH{N-1},
\end{equation}
然而由于各个 $H_n$ 之间彼此不对易，矩阵指数无法直接拆开。
为了解决这个问题，我们需要使用矩阵指数的Trotter展开。

Trotter展开将矩阵和的指数变为矩阵指数的乘积。
对于矩阵 $M = M_0 + M_1$ ，考虑指数展开：
\begin{equation}
\left\{
\begin{aligned}
\mathrm{e}^{x M} &= I + x M + O (x^2), \\
\mathrm{e}^{x M_0} \mathrm{e}^{x M_1} & = (I + x M_0 + O(x^2)) (I + x M_1 + O(x^2)) ,
\end{aligned}
\right.
\end{equation}
展开得到：
\begin{equation}
\left\{
\begin{aligned}
\mathrm{e}^{x M} &= I + x (M_0 + M_1) + O (x^2), \\
\mathrm{e}^{x M_0} \mathrm{e}^{x M_1} & = I + x (M_0 + M_1) + O(x^2) ,
\end{aligned}
\right.
\end{equation}
所以我们有：
\begin{equation}
\mathrm{e}^{x (M_0 + M_1)} = \mathrm{e}^{x M_0} \mathrm{e}^{x M_1} + O(x^2),
\end{equation}
这便是一阶的Trotter展开。

而为了让误差更小，我们可以利用二阶的Trotter展开。考虑指数展开：
\begin{equation}
\left\{
\begin{aligned}
\mathrm{e}^{x M}
= &I + x M + \frac{1}{2} x^2 M^2 + O (x^3), \\
\mathrm{e}^{\frac{x}{2} M_0} \mathrm{e}^{x M_1} \mathrm{e}^{\frac{x}{2} M_0}
 =
&(I + \frac{1}{2} x M_0 + \frac{1}{8} x^2 M_0^2 + O(x^3)) \\
&(I + x M_1 + \frac{1}{2} x^2 M_1^2 + O(x^3))\\
&(I + \frac{1}{2} x M_0 + \frac{1}{8} x^2 M_0^2 + O(x^3))
,
\end{aligned}
\right.
\end{equation}
展开得到：
\begin{equation}
\left\{
\begin{aligned}
\mathrm{e}^{x M}                                                             = &I + x (M_0 + M_1) + \\
                                                                               &\frac{1}{2} x^2 (M_0^2 + M_1^2 + M_0 M_1 + M_1 M_0) + O (x^3), \\
\mathrm{e}^{\frac{x}{2} M_0} \mathrm{e}^{x M_1} \mathrm{e}^{\frac{x}{2} M_0} = &I + x (M_0 + M_1) + \\
                                                                               &\frac{1}{2} x^2 (M_0^2 + M_1^2 + M_0 M_1 + M_1 M_0) + O (x^3),
\end{aligned}
\right.
\end{equation}
所以我们有：
\begin{equation}
\mathrm{e}^{x (M_0 + M_1)} = \mathrm{e}^{\frac{x}{2} M_0} \mathrm{e}^{x M_1} \mathrm{e}^{\frac{x}{2} M_0}+ O(x^3),
\end{equation}
这便是二阶的Trotter展开。

对于多个矩阵相乘的情况， $M=M_0 + M_1 + \cdots M_{N-1}$ ，连续使用二阶的Trotter展开可得：
\begin{equation}\label{eq:多项求和的Trotter展开}
\begin{aligned}
\mathrm{e}^{x (M_0 + M_1 + \cdots M_{N-1})}
=&\mathrm{e}^{\frac{x}{2} M_0} \mathrm{e}^{x (M_1 + M_2 + \cdots M_{N-1})} \mathrm{e}^{\frac{x}{2} M_0}+ O(x^3) \\
=&\mathrm{e}^{\frac{x}{2} M_0}(
\mathrm{e}^{\frac{x}{2} M_1}
\mathrm{e}^{x (M_2 + M_3 + \cdots M_{N-1})}
\mathrm{e}^{\frac{x}{2} M_1} + O(x^3))
\mathrm{e}^{\frac{x}{2} M_0}
+O(x^3) \\
=&\cdots \\
=&\mathrm{e}^{\frac{x}{2} M_0}
\mathrm{e}^{\frac{x}{2} M_1}
\cdots
\mathrm{e}^{\frac{x}{2} M_{N-2}}
\mathrm{e}^{\frac{x}{2} M_{N-1}} \\
&
\mathrm{e}^{\frac{x}{2} M_{N-1}}
\mathrm{e}^{\frac{x}{2} M_{N-2}}
\cdots
\mathrm{e}^{\frac{x}{2} M_1}
\mathrm{e}^{\frac{x}{2} M_0}
+O(N x^3), \\
\end{aligned}
\end{equation}
将公式 [[eqref:eq:多项的Hamiltonian演化算符]] 代入公式 [[eqref:eq:多项求和的Trotter展开]] ，我们可以得到：
\begin{equation}\label{eq:逐块虚时间演化算法的最终公式}
\begin{aligned}
U
=&\mathrm{e}^{-\tau (H_0 + H_1 + \cdots H_{N-1})} \\
=&\mathrm{e}^{\frac{-\tau}{2} H_0}
\mathrm{e}^{\frac{-\tau}{2} H_1}
\cdots
\mathrm{e}^{\frac{-\tau}{2} H_{N-2}}
\mathrm{e}^{\frac{-\tau}{2} H_{N-1}} \\
&
\mathrm{e}^{\frac{-\tau}{2} H_{N-1}}
\mathrm{e}^{\frac{-\tau}{2} H_{N-2}}
\cdots
\mathrm{e}^{\frac{-\tau}{2} H_1}
\mathrm{e}^{\frac{-\tau}{2} H_0}
+O(N \tau^3). \\
\end{aligned}
\end{equation}
公式 [[eqref:eq:逐块虚时间演化算法的最终公式]] 即为逐块虚时间演化算法的核心公式。

矩阵乘积态上进行逐块虚时间演化时，每次仅需要在原有的MPS上作用 $U_i=\mathrm{e}^{\frac{-\tau}{2}H_i}$ 。
如图 [[ref:fig:朴素的itebd]] (a)，对于仅有近临相互作用的系统，所有的 $U_i$ 只会作用在两个相邻的张量上，标记为第 $x$ 个张量和第 $y$ 个张量。
我们可以直接收缩 $U_i$ 以及第 $x$ 个张量 $A_x$ 和 第 $y$ 个张量 $A_y$ ，得到一个大张量 $U_i A_x A_y$ ，如图 [[ref:fig:朴素的itebd]] (b)。
随后，为了恢复MPS矩阵乘积的形式，我们需要对收缩后的四阶张量进行分解，进行SVD分解后，MPS如图 [[ref:fig:朴素的itebd]] (c) 。
最后，将多余的奇异值矩阵 $s$ 收缩到左侧的 $u$ 张量或者右侧的 $v$ 张量中，从而完全恢复MPS的形式，即图 [[ref:fig:朴素的itebd]] (d)。

#+begin_export latex
\begin{figure}
\centering
\input{tikz/trivial_itebd.tikz}
\caption{MPS上朴素的逐块虚时间演化}
\label{fig:朴素的itebd}
\note{注：(a) 作用在 $A_x$ 和 $A_y$ 上的 $U_i$ ； (b) 收缩三个张量 ；(c) 对收缩后的张量进行SVD分解；  (c) 收缩奇异值张量，恢复MPS的形式。
}
\end{figure}
#+end_export

作用上 $U_i$ 后， 分解后得到的 $A'_x$ 和 $A'_y$ 张量之间的指标的维度从原来的 $D$ 上升至 $Dd$ ，这使得演化过程不可持续。
为此，我们可以舍弃SVD得到的奇异值矩阵中较小的奇异值，仅保留最大的 $D$ 个奇异值，从而保证经过以此 $U_i$ 演化后，MPS的所有指标的维度不变。

SVD后舍弃小的奇异值，是低秩近似的实现。
对于 $m \times n$ 的矩阵 $A$ ，进行SVD分解得到 $A = U S V^T$ ，那么 $A_k = \sum_{i=1}^{k} S_i U_i V_i^T$ 是秩为 $k$ 的矩阵中，希尔伯特-施密特范数下，最接近 $A$ 的矩阵。
而希尔伯特-施密特范数是将矩阵视作向量后的 $2$ 范数，MPS中，张量的组合最后会得到希尔伯特空间中的向量，因而我们应当在这里考虑希尔伯特-施密特范数。
具体的证明如下，令 $\sigma_i (A)$ 为 $A$ 的第 $i$ 个奇异值。
易得，$|A-A_k|^2=\sum_{i=k+1}^{n} \sigma_i(A)$ ，这里不妨设 $m \le n$ 。
由于 $\sigma_1$ 本身可以作为矩阵的谱范数，对于 $B=B' + B''$ ， 我们有 $\sigma_1(B) \le \sigma_1(B') + \sigma_1(B'')$ 。
而对于任意 $i$ 和 $j$ ，有
\begin{equation}
\begin{aligned}
\sigma_i(B') + \sigma_j(B'')
&= \sigma_1(B' - B'_{i-1}) + \sigma_1(B''-B''_{j-1}) \\
&\ge \sigma_1(B - B'_{i-1} - B''_{j-1}) \\
&\ge \sigma_1(B - B_{i+j-2}) \\
&= \sigma_{i+j-1}(B) .
\end{aligned}
\end{equation}
由于任意秩为 $k$ 的矩阵 $C$ ，有 $\sigma_{k+1}(C) = 0$ ，我们有 $\sigma_i(A-C) + \sigma_{k+1}(C) = \sigma_i(A-C) \ge \sigma_{k+i}(A)$ 。
故, $|A-C|^2 = \sum_{i=1}^{n} \sigma_i(A-C)^2 \ge \sum_{i=k+1}^{n}\sigma_i(A)^2 = |A-A_k|^2$ 。
即 $A_k$ 是秩为 $k$ 的矩阵中最接近 $A$ 的矩阵。

在进行低秩近似时，矩阵两侧插入酉矩阵不影响近似的结果，所以我们在MPS中进行SVD时，如果能保证两侧的整体为酉矩阵，那么SVD的近似不仅是当前两个张量的低秩近似，而且还是整个MPS的低秩近似。
实际操作过程中，例如正在将演化算子作用在相邻的格点 $x$ 和 $y$ 时，其中 $x+1=y$ ，可以自 $i=0$ 开始，对格点张量进行 QR 分解， $Q$ 张量保留物理指标和左侧指标，$R$ 保留右侧指标。
随后$R$ 张量向第 $i+1$ 个格点处的张量收缩，由于 QR 分解产生的指标维度为 $Q$ 和 $R$ 保留指标维度的最小值， 而 $R$ 右侧指标维度为MPS自身的截断 $D$ ，进行一步这样的操作后，没有破坏MPS的形式和维度截断。
随后 令 $i=1$ ，执行相同的操作，QR分解并把 $R$ 张量向右收缩。
一直迭代到 $i=x-1$ ，此时对于所有的 $i<x$ ， $i$ 处的格点张量都是酉的。
类似的，再令 $j=L-1$ ，从右向左迭代地进行LQ分解并将 $L$ 向左收缩，最后 所有 $j>y$ ， $j$ 处的格点张量也都是酉的。
这种MPS的形式被称为正则形式。
对于只有近邻相互作用的系统， 公式 [[eqref:eq:逐块虚时间演化算法的最终公式]] 中， 我们可以调整作用的顺序，使得连续作用的两个演化算符总是有共同格点的，
比如 $H_0$ 作用在第 $0$ 和 第 $1$ 个格点， $H_1$ 作用在第 $1$ 和 第 $2$ 个格点，他们有共同的第 $1$ 个格点。
当我们在为了作用 $H_i$ 算子而将MPS转变为正则系统，当前算子收缩上两个格点后并SVD分解得到三个张量时，我们可以直接将截断后的奇异值矩阵向下一次作用的哈密顿量的两个近邻格点之一上收缩，从而保证下次作用时，MPS依然是正则形式。

*** 简单更新算法 <<sec:::简单更新>>

逐块虚时间演化算法中，主要误差来源于SVD分解时的低秩近似。
虽然一维的情况下，保证更新时两侧的环境都为酉可以使得单步近似达到最优，但是对于二维系统来说，我们无法将环境通过简单的变换转化为酉的。

对于一维MPS链，除了通过QR分解和LQ分解保证的正则形式，还有一种 $\Gamma-\Lambda$ 的正则形式 [[cite:Vidal2003]]
其在公式 [[eqref:eq:一维系统波函数的MPS展开]] 中每两个 $A$ 中插入一个对角矩阵 $\Lambda$ ，并记 $A$ 为 $\Gamma$ ，得到
\begin{equation}
T^{\sigma_0,\sigma_1,\cdots,\sigma_{L-1}} =
(\Gamma_0 ^ {\sigma_0})_{v_1} (\Lambda_0)_{v_1}
(\Gamma_1 ^ {\sigma_1})_{v_1 v_2} (\Lambda_1)_{v_2}
(\Gamma_2 ^ {\sigma_2})_{v_2 v_3} (\Lambda_2)_{v_3}
\cdots (\Gamma_{L-1} ^ {\sigma_{N-1}})_{v_{N-1}} ,
\end{equation}
对于每个对角矩阵 $\Lambda_i$ ，其左侧和右侧整体都是酉的。
这种 $\Gamma-\Lambda$ 形式可以直接通过普通的MPS进行多次SVD得到。
在这种形式的MPS上进行逐块虚时间演化时，作用在 $\Gamma_x$ 和 $\Gamma_{y}$ 两个格点上的演化算子，只需要收缩再 $\Lambda_{x-1}$, $\Lambda_{y}$ 以及这两个 $\Gamma$ 张量中间的 $\Lambda_{x}$ 即可保证系统其余部分都是酉的，从而能够使用SVD进行全局的低秩近似。
经过演化算符的作用，并进行SVD后依然可以保证当前两个格点的两侧是酉的。
而在其他格点看来，只是远处有两个的格点作用上了一个酉矩阵，依然不改变原来的酉的性质。

这种方法被推广为二维，被称为简单更新 [[cite:Jiang2008]] ，其可以以较少的代价获取仅有近邻相互作用的二维系统中接近基态的投影纠缠对态。
简单更新方案中，投影纠缠对态中每个相连的张量中间插入了一个对角矩阵，类比 $\Gamma-\Lambda$ 形式中的 $\Lambda$ ，通常被称为环境张量。

图 [[ref:fig:su]] (a1-a4) 展示了简单更新的步骤。
当演化两个相邻格点 $A$ 和 $B$ 时，首先将 $A$ 和 $B$ 周围和之间的七个对角张量收缩，并作用上演化算子得到张量 $C$ 。
随后进行SVD分解，产生的奇异值矩阵作为 $A$ 和 $B$ 之间新的环境。
而之前在 $A$ 和 $B$ 周围的六个环境通过让 USV后的 $A'$ 和 $B'$ 收缩自己的逆来 直接恢复，从而维护了含有环境张量的投影纠缠对态的形式。

图 [[ref:fig:su]] (b1-b4) 展示了一种改进的简单更新方案。
程序存储的数据中， 个点张量已经收缩过自身四周的所有环境了。
演化两个相邻格点 $A$ 和 $B$ 时，只需要收缩 $A$ 、  $B$ 和他们中间的环境张量的逆即可。
作用上演化算子后，依然进行SVD，得到 $A$ 和 $B$ 中间新的环境张量。
此时 $A$ 和 $B$ 只需要乘上新的环境变量即可恢复含有环境张量、但格点张量已经收缩过四周环境张量的投影纠缠对态的形式。
这种方案在单步演化过程中，可以减少十次环境的收缩操作。

#+begin_export latex
\begin{figure}
\centering
\includegraphics[width=0.8\textwidth]{su-scheme.pdf}
\caption{简单更新的步骤}
\note{注：
简单更新优化过程的示意图中涉及两个张量，$A$ 和 $B$。绿色菱形代表环境张量，而黄色菱形代表其逆。圆圈表示张量网络中的节点。
在左侧面板中，传统的一步虚时间演化过程如下图所示：
(a1) 张量 $A$ 和 $B$ 与所有相关环境张量及时间演化门的收缩。
(a2) 由此收缩得到的张量 $C$。
(a3) 对步骤 (a2) 中的张量进行SVD分解得到的张量。
(a4) 通过与环境张量的逆（以黄色菱形表示）进行收缩，恢复为 (a1) 中的原始构型。
在右侧面板中，我们展示了一种改进的一步简单更新演化方案：
存储的张量 $A$ 和 $B$ 已经包含了必要的环境信息。
(b1) 张量 $A$、张量 $B$、它们之间的环境逆和时间演化门的收缩。
(b2) 步骤 (b1) 的结果，与传统方法的 (a2) 结果等效。
(b3) 通过对步骤 (b2) 中的张量进行SVD分解得到的结果张量，与传统方法中的 (a3) 等效。
(b4) 与新的环境（以绿色菱形表示）进行收缩，恢复步骤 (b1) 中的原始张量形式。这个方案比标准步骤节省了十次环境收缩操作。
}
\label{fig:su}
\end{figure}
#+end_export

** 采样方法 <<sec::各种采样方法>>

张量网络态可以有效表示服从面积定律的态函数，但是各种张量网络的优化算法难以得到精确的基态，而受限于虚拟指标的维度，严格计算包括能量在内的观测量也有着难以忍受的复杂度。
通过采样方法即蒙特卡罗方法，可以有效减少在张量网络态上计算观测量和能量时的计算复杂度 [[cite:Sandvik2007,Liu2017]] 。
传统上，我们通常使用马尔可夫链进行Metropolis采样，这种采样方法普适性强，但是有意样本之间有有限关联，有效的样本数比实际样本数更少。
近年来，直接采样方法 [[cite:Vieijra2021]] 通过避免样本之间的关联而提高了采样的效率。
而自然梯度法 [[cite:Neuscamman2012]] 的引入则提高了优化的效率，使得变分蒙特卡罗方法不再依赖简单更新的结果作为初态，使得优化无法进行简单更新的长程关联系统称为可能。

*** 基于采样的观测量计算

对于观测量 $O$ ，我们可以将其分解为多项之和 $O = \sum_i O_i$ ，比如整体的 $z$ 方向自旋 $S_z = \sum_{i} S_z^i$ ，其中 $i$ 遍历所有的格点，而 $S_z^i$ 是 $i$ 格点处的自旋算符。
通常，量子多体系统很少涉及四体以上的相互作用，我们可以认为每个 $O_i$ 只作用在较少个格点上。
而无论是计算观测量，还是计算梯度，都可以看作计算单项 $O_i$ 或其梯度后，再计算简单的多项之和，所以不改变问题难度，本章的下文中， $O$ 仅代表观测量的一项。

使用 $O$ 对 $|\psi\rangle$ 进行测量时，观测量为 $\langle O \rangle=\frac{\langle \psi | O | \psi \rangle}{\langle \psi | \psi \rangle}$ 。
当 $|\psi\rangle$ 使用张量网络进行表示时，比如二维的投影纠缠对态，如果直接计算观测量，我们需要收缩双层的网络 $\langle \psi | O | \psi \rangle$ 。
如果使用边界MPS的近似方式，复杂度高达 $O(D^4 D_c^3 + d D^6 Dc^2)$  [[cite:Liu2017]] ，其中 $Dc$ 为边界MPS方法中的截断参数，通常 $D_c \propto D^2$。
而使用蒙特卡罗方法，可以避免双层网络的收缩。

蒙特卡罗方法中，首先对 $\langle O \rangle$ 进行变形，得到
\begin{equation}\label{eq:观测量变形}
\langle O \rangle=\frac{\sum_{s,s'}\langle \psi | s | O | s' | \psi \rangle}{\sum_{s}\langle \psi | s | \psi \rangle} , 
\end{equation}
其中 $s$ 和 $s'$ 是希尔伯特空间中对某个构型上的投影算子。
我们这里的表述与标准的变分蒙特卡罗有些不同，比如 我们写成 $\langle \psi | s | \psi \rangle$ 而不是 $\langle \psi | s\rangle \langle s|\psi \rangle$ 。
这是因为使用费米子张量作为波函数表示时，我们无法将 $\langle \psi | s \rangle$ 写成构型无关的复数，而是得到 $\langle \psi | s$ 作为一个费米子张量，它可以进一步和 $|\psi\rangle$ 收缩得到复数。

在公式 [[eqref:eq:观测量变形]] 中，有两个指标需要在整个希尔伯特空间中遍历，即 $s$ 和 $s'$ ，这是不可接受的，因为希尔伯特空间的大小高达 $d^N$ ，其中 $d$ 为单个物理指标的维度， $N$ 为物理指标的数目。
为了解决这个问题，使用蒙特卡罗方法进行采样 $s \sim S$ ，其中 $S$ 为用于采样的分布， $s$ 被采样的概率设为 $p_s$ 。
我们可以估计观测量为
\begin{equation}\label{eq:观测量采样}
\widehat{\langle O \rangle} = \frac{\sum_{s \sim S} \frac{\langle\psi|s|\psi\rangle}{p_s}\frac{\sum_{s'} \langle \psi | s | O | s' | \psi \rangle}{\langle\psi|s|\psi\rangle}}{\sum_{s \sim S} \frac{\langle \psi | s | \psi \rangle}{p_s}} .
\end{equation}

对观测量进行蒙特卡罗计算的时候，我们实际上是在进行多项分布的采样，令构型 $s$ 被采样到的次数为 $n_s$ ，则 $n_s \sim M(n, p_s)$  ，其中 $n$ 为总采样量。
记多项分布下， $X$ 的期望为 $\langle X \rangle_M$ 。
令 $q_s = \frac{n_s}{n}$ ，对于任意 $q_s-p_s$ 的函数 $F$ ，由于
$\langle q_s - p_s \rangle_M = 0$ 和 $\langle (q_s - p_s) (q_t - p_t) \rangle_M = \frac{\delta_{st} p_s - p_s p_t}{n}$ ，
而 对于 $k > 2$ ， $\langle (q_s-p_s)^k \rangle_M = O(1/n^2)$ ，
我们有
\begin{equation}\label{eq:多项分布期望}
\langle F(q_s-p_s) \rangle_M = F(0) + \frac{1}{2n} \sum_{st} (\delta_{st} p_s - p_s p_t) \frac{\partial^2 F}{\partial \delta_s \delta_t}(0) + O(1/n^2) ,
\end{equation}

令 $r_s = \frac{\langle \psi|s|\psi\rangle}{p_s}$， $O_s = \frac{\sum_{s'}\langle\psi|s|O|s'|\psi\rangle}{\langle\psi|s|\psi\rangle}$ ，
定义 $\langle X \rangle_p=\sum_{s}X_s p_s$ ，$\langle X \rangle_\psi = \frac{\langle X_s r_s \rangle_p}{\langle r_s \rangle_p}$ ，
记   $r'_s=\frac{r_s}{\langle r\rangle_p}$ 。
我们有观测量的严格表达式
\begin{equation}\label{eq:严格观测量}
\langle O \rangle = \frac{\sum_s p_s r_s O_s}{\sum_s p_s r_s} = \frac{\langle r O \rangle_p}{\langle r\rangle_p} = \langle O \rangle_\psi,
\end{equation}
而通过采样得到的观测量估计为
\begin{equation}\label{eq:采样观测量}
\widehat {\langle O \rangle} = \frac{\sum_s q_s r_s O_s}{\sum_s q_s r_s},
\end{equation}
这和真实的观测量不同。

将公式 [[eqref:eq:严格观测量]] 和公式 [[eqref:eq:采样观测量]] 的差值与差值平方代入公式 [[eqref:eq:多项分布期望]] ，我们得到
\begin{equation}\label{eq:采样的偏差和方差}
\left\{
\begin{aligned}
\langle \widehat {\langle O \rangle} - \langle O \rangle \rangle_M &= - \frac{1}{n}\langle ( O - \langle O \rangle_\psi ) (r' - \langle r' \rangle_\psi) \rangle_\psi + O(1/n^2), \\
\langle (\widehat {\langle O \rangle} - \langle O \rangle)^2 \rangle_M &= \frac{1}{n}\left\langle (O - \langle O \rangle_\psi)^2 r' \right\rangle_\psi + O(1/n^2).
\end{aligned}
\right.
\end{equation}
可见 $\langle r' \rangle_\psi = r'_s$ ，即 $p_s \propto \langle \psi | s | \psi \rangle$ 时，通过蒙特卡罗计算的观测量的偏差是  $O(1/n^2)$ 的，当涉及到调整权重的重要采样时，对观测量的估计一般有一个 $1/n$ 级的偏差。

*** 基于采样方法的变分法

蒙特卡罗方法用于计算梯度即变分蒙特卡罗方法，考虑使用参数 $T_i$ 表示的态 $|\psi\rangle$ ，对公式 [[eqref:eq:观测量变形]] 进行求导，令 $O=H$ ，得到
\begin{equation}
\left\{
\begin{aligned}
\frac{\partial E}{\partial T_i^*}&=\frac{\sum_{s,s'}\langle \partial_{T_i^*}\psi | s | H | s' | \psi \rangle}{\sum_{s}\langle \psi | s | \psi \rangle} - E \frac{\sum_s\langle \partial_{T_i^*}\psi|s|\psi\rangle}{\langle\psi|\psi\rangle} , \\
\frac{\partial E}{\partial T_i}&=\frac{\sum_{s,s'}\langle \psi | s' | H | s | \partial_{T_i}\psi \rangle}{\sum_{s}\langle \psi | s | \psi \rangle} - E \frac{\sum_s\langle\psi|s|\partial_{T_i}\psi\rangle}{\langle\psi|\psi\rangle} .
\end{aligned}
\right.
\end{equation}
类似公式 [[eqref:eq:观测量采样]] ，我们可以将梯度写成采样估计的形式
\begin{equation}
\left\{
\begin{aligned}
\widehat{\frac{\partial E}{\partial T_i^*}}&=\frac{\sum_{s \sim S} r_s \frac{\sum_{s'} \langle \partial_{T_i^*}\psi | s | H | s' | \psi \rangle}{\langle\psi|s|\psi\rangle}}{\sum_{s \sim S} r_s} - \hat E \frac{\sum_{s \sim S} r_s \frac{\langle \partial_{T_i^*}\psi | s | \psi \rangle}{\langle\psi|s|\psi\rangle}}{\sum_{s \sim S} r_s} ,\\
\widehat{\frac{\partial E}{\partial T_i}}&=\frac{\sum_{s \sim S} r_s \frac{\sum_{s'} \langle \psi | s' | H | s | \partial_{T_i}\psi \rangle}{\langle\psi|s|\psi\rangle}}{\sum_{s \sim S} r_s} - \hat E \frac{\sum_{s \sim S} r_s \frac{\langle \psi | s | \partial_{T_i}\psi \rangle}{\langle\psi|s|\psi\rangle}}{\sum_{s \sim S} r_s} .
\end{aligned}
\right.
\end{equation}
而对于任意 $\langle a|$ 和 $|b \rangle$ ，有 $\langle a | s | b \rangle = \frac{\langle a | s | \psi \rangle \langle \psi | s | b \rangle}{\langle \psi | s | \psi \rangle}$ ，令 $\Delta_s^i = \frac{\langle \partial_{T_i^*} \psi|s|\psi\rangle}{\langle \psi|s|\psi \rangle}$ ，
经过化简，我们有
\begin{equation}
\left\{
\begin{aligned}
\widehat{\frac{\partial E}{\partial T_i^*}}&=\frac{\sum_{s \sim S} r_s \Delta_s^i E_s }{\sum_{s \sim S} r_s}- \hat E \frac{\sum_{s \sim S} r_s \Delta_s^i }{\sum_{s \sim S} r_s} \\
\widehat{\frac{\partial E}{\partial T_i}}&=\frac{\sum_{s \sim S} r_s \Delta_s^{i*} E_s^* }{\sum_{s \sim S} r_s}- \hat E \frac{\sum_{s \sim S} r_s \Delta_s^{i*} }{\sum_{s \sim S} r_s} .
\end{aligned}
\right.
\end{equation}

令 $G=\frac{\partial E}{\partial T_i^*}$ ，为了分析梯度的偏差和方差，我们写成多项分布采得的 $q_s$ 的形式，得到
\begin{equation}\label{eq:梯度的严格和估计}
\left\{
\begin{aligned}
G&=\frac{\sum_{s} p_s r_s \Delta_s E_s }{\sum_{s} p_s r_s}- \frac{\sum_s p_s r_s E_s}{\sum_s p_s r_s} \frac{\sum_{s} p_s r_s \Delta_s}{\sum_{s} p_s r_s} , \\
\hat G&=\frac{\sum_{s} q_s r_s \Delta_s E_s }{\sum_{s} q_s r_s}- \frac{\sum_s q_s r_s E_s}{\sum_s q_s r_s} \frac{\sum_{s} q_s r_s \Delta_s}{\sum_{s} q_s r_s} .
\end{aligned}
\right.
\end{equation}
将公式 [[eqref:eq:梯度的严格和估计]] 代入公式 [[eqref:eq:多项分布期望]] ，我们得到
\begin{equation}\label{eq:梯度的偏差和方差}
\left\{
\begin{aligned}
\langle \frac{n}{n-1}\hat G - G\rangle_M &= \frac{1}{n-1}\left(\langle G\rangle_\psi + \langle r'\rangle_\psi \langle G \rangle_\psi - 2 \langle r' G \rangle_\psi\right) + O(1/n^2), \\
\langle (\frac{n}{n-1}\hat G - G)^2 \rangle_M &= \frac{1}{n}\left\langle (G - \langle G \rangle_\psi)^2 r' \right\rangle_\psi + O(1/n^2) .
\end{aligned}
\right.
\end{equation}
与观测量的情况类似，如果 $\langle r' \rangle_\psi = r'_s$ 即 $p_s \propto \langle \psi | s | \psi \rangle$ 时，梯度估计的偏差为 $O(1/n^2)$ ，而涉及到调整权重的重要采样时，则有 $1/n$ 级的偏差。

*** 基于采样的自然梯度法 <<sec:::自然梯度法>>

度量空间中，梯度下降算法可以被自然梯度法所取代。
考虑局部最小化函数 $E(x_i,x_i^*)$ 的任务，我们需要寻找 $\min_{\delta x_i^* g^{ij} \delta x_j = r^2} \hat E(x_i + \delta x_i, x_i^* + \delta x_i^*)$ 。
其中 $\hat E$ 通过当前点 $(x_i,x_i^*)$ 处的梯度估计得到，即
\begin{equation}
\hat E(x_i+\delta x_i, x_i^* + \delta x_i^*)=E(x_i,x_i^*) + \frac{\partial E}{\partial x_i} \delta x_i + \frac{\partial E}{\partial x_i^*}\delta x_i^* .
\end{equation}
使用拉格朗日乘子，定义
\begin{equation}
L(\delta x_i, \delta x_i^*, \lambda) = E(x_i) + \frac{\partial E}{\partial x_i} \delta x_i + \frac{\partial E}{\partial x_i^*} \delta x_i^* + \lambda (\delta x_i^* g^{ij} \delta x_j - r^2) ,
\end{equation}
并求导得到
\begin{equation}
\left\{
\begin{aligned}
0&=\frac{\partial L}{\partial \delta x_i} = \frac{\partial E}{\partial x_i} + \lambda \delta x_j^* g^{ji}, \\
0&=\frac{\partial L}{\partial \delta x_i^*} = \frac{\partial E}{\partial x_i^*} + \lambda g^{ij} \delta x_j .
\end{aligned}
\right.
\end{equation}
所以，
\begin{equation}\label{eq:自然梯度法}
\left\{
\begin{aligned}
\delta x_i &= -\frac{1}{\lambda} g_{ij}\frac{\partial E}{\partial x_j^*} , \\
\delta x_i^* &= - \frac{1}{\lambda} g_{ij}^* \frac{\partial E}{\partial x_j} . \\
\end{aligned}
\right.
\end{equation}

使用参数空间的参数表示量子态时，由于表示本身的原因，可能导致在参数空间中难以进行梯度下降。
而希尔伯特空间中，能量函数有着较简单的形式，假设希尔伯特空间有平凡度规 ， 即 $g^H_{ij}=\delta_{ij}$ ，则可以在表示态的参数空间中诱导出参数空间的度规，从而提高优化效率。
这种方法就是自然梯度，在变分蒙特卡罗中，也被称为随机重构型方法。

对于两个度量空间 $A$ 和 $B$ ， $x^{A*}_i g^{Aij} y^A_j = x^{B*}_i g^{Bij} y^B_j$ 所以
\begin{equation}\label{eq:度规诱导}
g^{Aij} = \frac{\partial x^{B*}_k}{\partial x^{A*}_i} g^{Bkl} \frac{\partial y^B_l}{\partial y^A_j} .
\end{equation}
希尔伯特空间是射影空间，我们首先将希尔伯特空间的度规诱导至对应的复向量空间中。
由于
\begin{equation}
\psi_i^H = \frac{\psi_i^C}{\sqrt{\sum_k \psi_k^{C*} \psi_k^C}} ,
\end{equation}
我们有
\begin{equation}\label{eq:C和H}
\frac{\partial \psi^H_i}{\partial \psi^C_j} = \frac{1}{|\psi^C|} (\delta_{ij} - \frac{1}{2}\frac{\psi^C_i \psi^{C*}_j}{|\psi^C|^2}) .
\end{equation}
将公式 [[eqref:eq:C和H]] 代入公式 [[eqref:eq:度规诱导]] ，我们得到
\begin{equation}
\begin{aligned}
g^{Cij}
&= \frac{1}{|\psi^C|}(\delta_{ki} - \frac{\psi^{C*}_k \psi^C_i}{|\psi^C|^2}) \delta_{kl} \frac{1}{|\psi^C|}(\delta_{lj} - \frac{\psi^C_l \psi^{C*}_j}{|\psi^C|^2}) \\
&= \frac{1}{|\psi^C|^2}(\delta_{ki} - \frac{\psi^{C*}_k \psi^C_i}{|\psi^C|^2}) (\delta_{kj} - \frac{\psi^C_k \psi^{C*}_j}{|\psi^C|^2}) \\
&= \frac{1}{|\psi^C|^2}(\delta_{ij} - \frac{\psi^C_i \psi^{C*}_j}{|\psi^C|^2}) .
\end{aligned}
\end{equation}

而对于参数 $T_i$ 所在的参数空间 $T$ ，其度规为
\begin{equation}\label{eq:度规推导}
\begin{aligned}
g^{Tij}
&= \frac{\partial \psi_k^*}{\partial T_i^*} \frac{1}{|\psi|^2}(\delta_{kl} - \frac{\psi_k \psi_l^*}{|\psi|^2}) \frac{\partial \psi_l}{\partial T_j} \\
&= \frac{1}{|\psi|^2}\frac{\partial \psi_k^*}{\partial T_i^*} (\delta_{kl} - \frac{\psi_k \psi_l^*}{|\psi|^2}) \frac{\partial \psi_l}{\partial T_j} \\
&= \frac{1}{|\psi|^2} \left(\frac{\partial \psi_k^*}{\partial T_i^*} \frac{\partial \psi_k}{\partial T_j} - \frac{\partial \psi_k^*}{\partial T_i^*} \frac{\psi_k \psi_l^*}{|\psi|^2} \frac{\partial \psi_l}{\partial T_j}\right) .
\end{aligned}
\end{equation}
将公式 [[eqref:eq:度规推导]] 写成方便采样估计的形式，得到
\begin{equation}
g^{Tij} = \frac{\sum_k\langle \partial_{T_i^*}\psi|k|\partial_{T_j}\psi\rangle}{\langle \psi | \psi \rangle} - \frac{\sum_k\langle \partial_{T_i^*}\psi|k|\psi\rangle}{\langle\psi|\psi\rangle} \frac{\sum_l\langle\psi|l|\partial_{T_j}\psi\rangle}{\langle\psi|\psi\rangle} .
\end{equation}
可以采样估计
\begin{equation}\label{eq:度规的采样计算}
\widehat{g^{Tij}} = \frac{\sum_{s \sim S} r_s \Delta_s^i \Delta_s^{j*}}{\sum_{s \sim S} r_s} - \frac{\sum_{s \sim S} r_s \Delta_s^i}{\sum_{s \sim S} r_s} \frac{\sum_{s \sim S} r_s \Delta_s^{j*}}{\sum_{s \sim S} r_s} .
\end{equation}

至此，我们可以得到任意用于表示量子态的函数的参数空间中的度规，这样便我们可以利用公式 [[eqref:eq:自然梯度法]] ，将度规的逆作用在梯度上，得到参数更新的方向。

*** 直接采样

直接采样提供了在PEPS上的一种自回归、无构型关联的采样方法 [[cite:Vieijra2021]] 。
变分蒙特卡洛方法中，我们需要找到一个采样方法，使得 $r_s = \frac{ \langle \psi | s | \psi \rangle}{p_s} \approx 1$ ，因为 $r_s$ 的分布不均匀会给能量和梯度的估计都带来偏差。

直接采样方案中，对投影纠缠对态上的每个物理指标，依次进行采样。
首先， 其试图计算第 0 个物理指标处的约化密度矩阵，即
\begin{equation}
\left(\rho_0\right)_{r_0,t_0} = \sum_{s_1 s_2 \cdots} \langle \psi | (r_0 s_1 s_2 \cdots) \rangle \langle (t_0 s_1 s_2 \cdots) | \psi \rangle ,
\end{equation}
其中 $s = (s_0 s_1 s_2 \cdots)$, $s_i$ 表示构型 $s$ 在第 $i$ 个物理指标上的值。
得到 $\rho_0$ 后，模仿在第 0 个格点上进行测量，即以 $\left(\rho_0\right)_{0,0}, \left(\rho_0\right)_{1,1}, \cdots \left(\rho_0\right)_{d-1,d-1}$ 为概率进行采样，得到 $s_0$ 。
接下来计算在第0个点已经坍缩至 $s_0$ 的情况下， 下一个格点的约化密度矩阵，即
\begin{equation}
\left(\rho_1\right)_{r_1,t_1} = \sum_{s_2 s_3 \cdots} \langle \psi | (s_0 r_1 s_2 s_3 \cdots) \rangle \langle (s_0 t_1 s_2 s_3 \cdots) | \psi \rangle ,
\end{equation}
随后执行相同的操作来进行采样。
即在采样第 $i$ 个格点时， 第 $0, \cdots i-1$ 个格点均已经采样完毕，此时计算 第 $i$ 个格点的约化密度矩阵
\begin{equation}
\left(\rho_i\right)_{r_i,t_i} = \sum_{s_{i+1} s_{i+2} \cdots} \langle \psi | (s_0 s_1 \cdots s_{i-1} r_i s_{i+1} s_{i+2} \cdots) \rangle \langle (s_0 s_1 \cdots s_{i-1} t_i s_{i+1} s_{i+1} \cdots) | \psi \rangle ,
\end{equation}
从而完成 对 第 $i$ 个格点的采样。

由于PEPS网络精确收缩代价极高，采样边界MPS和边界MPO方法对计算上述的约化密度矩阵进行计算 [[cite:Liu2017,Murg2007,Verstraete2008,Liu2021]] 。
由于会重加权，虽然 $r_s$ 的均匀性会影响能量和梯度的偏差，但是直接采样过程中的边界MPO方法里，并不需要很大的 $Dc$ ，通常边界MPO中可以取 $Dc=4$ 甚至 $2$ 。
而直接采样中的边界MPS的计算可以在后续计算观测量时复用，所以并没有效率上的影响。

* 张量网络态程序基础算子在神威超级计算机上的优化 <<sec:神威优化>>

TODO 神威优化

* 张量网络态计算套件（TNSP） <<sec:软件>>

** 张量网络态计算套件概述

基于第 [[ref:sec:张量和张量网络]] 章介绍的各类型张量与第 [[ref:sec:张量网络态算法]] 章介绍的多种张量网络态算法，我们开发了张量网络态计算套件（TNSP）[[cite:TNSP-repo]]。
TNSP简化了各种张量网络态（TNS）方法，特别是PEPS方法的编程过程，它抽象了不同类型张量的细节，无论是费米子张量、对称性张量还是常规的张量。
它提供了简单的用户和编程界面，方便使用各种流行的TNS方法，包括简单更新、梯度优化和各种采样技术。
该框架的设计本身十分具有灵活性，允许用户通过Python3插件无缝集成自定义的物理模型和优化策略。

#+begin_export latex
\begin{figure}
\centering
\includegraphics[width=0.8\textwidth]{figures/structure-of-tnsp.pdf}
\caption{张量网络态计算套件的结构}
\label{fig:张量网络态计算套件的结构}
\note{注：
张量网络计算套件的结构。该套件的核心是张量库TAT，它使用C++17设计，以提供各种张量类型的统一接口。
通过pybind11为该张量库创建了Python接口。
在Python接口的基础上，开发了一个名为tetragono的包，提供了一个易于访问和统一的接口，用于适用于不同物理模型和张量类型的多种TNS方法。
tetragono可以通过插件进行自定义修改。
套件还包括一个名为tetraku的模型库，其中包含了一系列预定义的插件，这些插件涵盖了各种物理模型、采样策略等。
此外，tetragono还使用了几个辅助库：lazy\_graph，提供了一种在计算中使用的惰性求值机制；以及PyScalapack，提供了ScaLAPACK的Python接口。
}
\end{figure}
#+end_export

该套件的总体结构如图 [[ref:fig:张量网络态计算套件的结构]] 所示。
套件内的核心张量库TAT旨在为各种类型张量提供统一的接口。
TAT实现为一个C++17的头文件库，通过泛型编程统一实现不同张量类型。
TAT通过使用所谓的对称性类型（Symmetry）来区分张量类型，对称性类型主要包含量子数，并提供关于这些量子数是费米子还是玻色子的相关信息。
根据指定的对称性类型，TAT定义了一个边类型（Edge）来表示张量指标的性质，该边类型涵盖了由对称性类型表征的一系列值及其各自的简并度。
随后，张量类型（Tensor）由一系列边名称和一系列边构建，并提供各种张量操作的接口，如奇异值分解（SVD）、收缩或边分割/合并，这些操作在不同张量类型中保持接口的一致性。
一旦构建了具有特定对称群的张量，其各种操作的函数接口都保持一致。

如图 [[ref:fig:张量网络态计算套件的结构]] 所示，我们使用pybind11将TAT的C++接口进行了封装，开发了一个Python3接口。
用户可以直接通过C++代码访问TAT库，也可以通过Python接口进行访问。

在核心张量库之上，我们开发了tetragono，以提供针对不同物理模型和张量类型的各种TNS方法，特别是PEPS的简便且统一的接口。
tetragono引入了抽象态类型（AbstractState）的概念以记录物理模型中的各种信息，以及一个抽象晶格类型（AbstractLattice），涵盖了PEPS虚拟边的详细信息。
在这两个抽象类之上，tetragono实现了各种TNS方法，包括简单更新和各种基于采样的方法。
在基于采样的方法中，tetragono实现了物理观测量的计算和优化方法，例如梯度下降 [[cite:Liu2017]] 和随机重构算法 [[cite:Sorella1998,Neuscamman2012,Stokes2020]]。
同时提供了一个简单的直接对角化方法，可用于对小系统中TNS的结果进行基准测试。
为提高重用性，各种组件如用于单层或双层网络的边界MPS方法 [[cite:Murg2007]] 的辅助张量系统也被独立封装。
目前，tetragono仅支持方形晶格上的PEPS。
但我们注意到，三角晶格上的模型可以直接利用为方形晶格设计的PEPS [[cite:Zhang2022]] 。
此外，通过引入在某一位置处的多个物理指标，我们可以把其他晶格几何结构，如Kagome和六边晶格，映射到方形晶格上 [[cite:Dong2023]] 。

tetragono提供了一个接口，使用户能够开发自己的插件，从而在框架内自定义物理模型和算法。
例如，在基于采样的算法 [[cite:Sandvik2007,Liu2017,Dong2019]] , 中，用户可以修改采样规则，以针对特定物理模型提高效率。

我们在套件内为一些常见的物理模型实现了一系列插件，并将它们整合到一个名为tetraku的库中。tetraku被设计为与tetragono无缝集成的插件，使用户无需额外编程即可直接利用这些物理模型。

** 套件各组件的设计

*** 张量库（TAT）

作为框架的中最基础的部分，张量包TAT旨在为各种类型的张量提供统一的接口。
TAT， 作为一个C++17头文件库， 利用泛型编程实现了各种张量类型的统一实现， 通过使用对称性类型来区分不同的张量类型。
这种对称性类型包含量子数， 并标记它们是费米的还是玻色的， 使TAT能够区分不同的张量类型: 对称性张量， 费米子张量或常规张量， 每种都与特定的量子群相关联。
在非对称情况下， 没有量子数， 而 $U(1)$ 对称性涉及整数量子数， $Z(2)$ 对称性使用布尔值。
更复杂的场景涉及具有不同类型和任意长度的量子数元组的乘积来表示对称群。
TAT通过静态处理指示每个量子数的费米玻色性质， 提高了代码的可读性和可重用性。

根据对称性类型， TAT定义了一种边类型， 用于表示张量指标的属性， 封装了由对称性类型表征的值及其简并性。
这种边由若干段组成， 并且在适用的情况下， 包含一个布尔值， 指示费米子情况下的费米箭头。
其中若干段中的每一段是对称性类型的值与其简并性构成的对。
一个分块多维数组， 或者说Core类型， 是由这些边的序列通过公式  [[eqref:eq:Abel对称性张量的形式]] 创建而成的， 为了性能效率， 将分块数据存储为一维数组。
然后， 张量类型由指向这个Core类型的指针和一个边名称的序列组成， 这允许在不直接改变原始张量的情况下， 通过轻量级的非就地边重命名来操纵张量元数据。
TAT提供了张量操作的各种接口， 如奇异值分解， 收缩， 或边的分割/合并。
一旦使用每个对称性所需要的独特属性构建完成了张量， 其他所有的张量操作接口就能在不同的张量类型和对称性组之间保持一致。

TAT的代码位于仓库的 =/TAT/include/TAT= 目录中，包含 =TAT。hpp= 主文件和四个目录： =structure= 、 =implement= 、 =utility= 和 =miscellaneous= 。在 =structure= 目录中，文件的组织如下：
+ =name。hpp= 描述了用作指标名称的类型。
+ =symmetry。hpp= 定义了泛型的对称性类型 =Symmetry= ，用于表示量子数。它可以被实例化为各种对称性类型， 如 =NoSymmetry= 、 =BoseU1Symmetry= 、 =BoseZ2Symmetry= 、 =FermiZ2Symmetry= 、 =FermiU1Symmetry= 等 。
+ =edge。hpp= 定义了基于对称性类型的边类型用以描述张量指标， 包括一个段和费米箭头， 这里的段被表示为一个C++的向量， 该向量由对称性类型(Symmetry)和维度(dimension)的对所组成 。
+ =core。hpp= 定义了核心类型，用于包含边序列和分块多维数组。
+ =tensor。hpp= 通过结合指向核心类型的指针 =shared_ptr<Core>= 和指标名称序列 =vector<Name>= 来描述张量类型，并声明了张量操作的函数，这些函数的实现可以在 =implement= 目录中的相应文件中找到。
此外，TAT包的各种实用函数和类放置在 =utility= 目录中。在 =miscellaneous= 目录中，文件 =io。hpp= 专门用于定义张量的I/O函数， =scalar。hpp= 处理张量的标量算术，而 =mpi。hpp= 则专注于为张量提供各种MPI函数。

Python接口封装的代码位于仓库的 =/PyTAT= 目录中，包含三个主要文件：
+ =PyTAT。hpp= 定义了模板函数，这些函数用于封装张量和边。
+ =dealing_tensor。cpp。in= 用于生成文件， 这些文件实例化 =PyTAT。hpp= 中针对不同张量类型的函数。 文件的生成过程由 =CMakeLists。txt= 协调。
+ =PyTAT。cpp= 负责定义Python模块中的所有其他组件。

TAT通过使用特定的描述符， 称为 =SymmetryType= ， 来区分属于不同对称性群的张量， 该描述符通常是模板类 =Symmetry<Args。。。>= 的实例化。
在这里，  =Args。。。= 表示包含指示对称性单群们的可变模板参数。
由模板类表示的对称性群是这些单群的乘积。
值得注意的是，  $U(1)$ 对称性由整数类型表示， 使用 =U1= 作为别名， 而 $Z(2)$ 对称性由布尔类型表示， 使用 =Z2= 作为别名。
例如，  =Symmetry<U1， Z2>= 表示群 $U(1) \otimes Z(2)$ 。
为了描述费米子对称性， 表明体现这种对称性的粒子是费米子，
TAT使用类型包装器 =fermi= 来封装单群的标记。
例如， =Symmetry<fermi<U1>>= 表示费米子 $U(1)$ 对称性。
为了增强表示的美观性， 用户还可以使用身份包装器 =bose= 为非费米子对称性群标记。
例如，  =Symmetry<fermi<Z2>， bose<U1>>= 表示费米子 $Z(2)$ $\otimes$ 玻色子 $U(1)$ 群。
至于非对称性情况， TAT使用 =Symmetry<>= 。

在TAT中，张量类型被定义为 =Tensor<ScalarType， SymmetryType， NameType>= ， 这是一个模板类，
其中 =ScalarType= (默认为 =double= )表示张量的内部标量类型，  =SymmetryType= (默认为 =Symmetry<>= )指定了张量所保持的对称群，
而 =NameType= (默认为 =string= )表示用于标记张量边的名字的类型。
用户可以通过使用统一的接口 =Tensor(name_list， edge_list)= 轻松生成不同类型的张量。
这里， =name_list= 指的是包含边名字的C++向量， 每个边名字都是 =NameType= 的一个值， 而 =edge_list= 表示由边组成的C++向量。

不同对称性类型的边表现出不同的形式。
在无对称性张量的情况下， 每个边可以直接由一个整数表示。
例如， 代码 [[ref:code:nosymmetry-cpp]] 创建了一个没有任何对称性的张量， 并初始化填充为零。
其创建了一个名为 =A= 的2阶张量， 它有两个边, =i= 和 =j= ， 这两个指标的维度分别为 =3= 和 =4= 。
\begin{lstlisting}[caption={无对称性张量的创建},label={code:nosymmetry-cpp},language=C++]
auto A = TAT::Tensor<double, TAT::Symmetry<>>(
             {"i", "j"},
             {3, 4},
).zero_();
\end{lstlisting}

非费米子对称性张量使用"段"来定义边， 这些段是一系列量子数及其相应简并度的对构成的列表。
如代码 [[ref:code:bose-symmetry-cpp]] 生成了一个 $Z(2)$ 对称性张量和一个 $U(1)$ 对称性张量。
在这里， $Z(2)$ 对称群的不可约表示为一个布尔值， 而对于 $U(1)$ 对称群， 它由一个整数表示。
对于张量 =A= ， 它有两个分块。
第一个分块具有不可约表示 ={false， false}= ， 维度为 $2 \times 4$ 。
第二个块具有不可约表示 ={true， true}= ， 维度为 $4 \times 1$ 。
对于张量 =B= ， 它由三个分块组成。
不可约表示分别为 ={-1， +1}= ， ={0， 0}= ， 和 ={+1， -1}= 。
每个块根据这些多重数具有不同的维度.
\begin{lstlisting}[caption={对称性张量的创建},label={code:bose-symmetry-cpp},language=C++]
auto A = TAT::Tensor<double, TAT::Symmetry<TAT::bose<TAT::U1>>>(
             {"i", "j"},
             {
                 {{false, 2}, {true, 4}},
                 {{false, 3}, {true, 1}},
             }
).zero_();
auto B = TAT::Tensor<double, TAT::Symmetry<TAT::bose<TAT::Z2>>>(
             {"i", "j"},
             {
                 {{-1, 2}, {0, 4}, {+1, 1}},
                 {{-1, 3}, {0, 2}, {+1, 1}},
             }
).zero_();
\end{lstlisting}

费米子张量的情况更加复杂。
边由一系列段以及所谓的"费米箭头"决定，而费米箭头是一个布尔值。
代码 [[ref:code:fermi-symmetry-cpp]] 创建了一个费米子 $U(1)$ 对称性张量，
其费米子性质由 $U(1)$ 对称性携带， 其两个边的费米箭头分别为 =false= 和 =true= 。
如我们在 [[ref:sec:::费米子张量]] 中所介绍，在费米子张量网络中， 我们需要引入了费米箭头， 这是因为在网络的每条边后面存在一个费米子EPR对。
通过一条边连接的两个张量包含EPR对的两个湮灭算符， 而对于费米子EPR对， 两个算符的顺序是重要的。
因此， 在TAT中， 使用费米箭头来表示哪一侧的算符在另一侧之前。
具体来说， TAT假设费米箭头为 =false= 的算符在费米箭头为 =true= 的算符之前。
\begin{lstlisting}[caption={费米子张量的创建},label={code:fermi-symmetry-cpp},language=C++]
auto A = TAT::Tensor<double, TAT::Symmetry<TAT::fermi<TAT::U1>>>(
             {"i", "j"},
             {
                 {{{-1, 2}, {0, 4}, {+1, 1}}, false},
                 {{{-1, 3}, {0, 2}, {+1, 1}}, true},
             }
).zero_();
\end{lstlisting}

对于非单群的对称性张量, 它们的不可约表示实际上可以用一个元组而不是单个布尔值或整数来表示, 如代码 [[ref:code:complex-symmetry-cpp]] 所示。
\begin{lstlisting}[caption={更复杂的张量类型},label={code:complex-symmetry-cpp},language=C++]
using Symmetry = TAT::Symmetry<TAT::fermi<TAT::U1>, TAT::bose<TAT::Z2>>;
auto A = TAT::Tensor<double, Symmetry>(
             {"i", "j"},
             {{{
                   {{-1, false}, 2},
                   {{0, false}, 4},
                   {{+1, false}, 1},
                   {{-1, true}, 4},
                   {{0, true}, 2},
                   {{+1, true}, 1},
               },
               false},
              {{
                   {{-1, false}, 3},
                   {{0, false}, 2},
                   {{+1, false}, 1},
                   {{-1, true}, 1},
                   {{0, true}, 2},
                   {{+1, true}, 3},
               },
               true}}
).zero_();
\end{lstlisting}

由于Python接口的封装是TAT这个C++头文件库的简单封装， 它不支持标量类型或对称性类型的多态性。
因此， Python中的每个不同张量都有其特定的类型。
张量类型的命名约定为 =TAT.<SymmetryType>.<ScalarType>.Tensor= 。
这里, =<SymmetryType>= 表示张量保持的对称性属性， 而 =<ScalarType>= 代表张量内部使用的标量数据类型。
=<ScalarType>= 的可用值在表 [[ref:table:可用的scalar]] 中总结。
表 [[ref:table:可用的symmetry]] 总结了 =<SymmetryType>= 的可选值。

#+caption: \label{table:可用的scalar} 可选的 =ScalarType=
#+ATTR_LATEX: :font \scriptsize
|------------------------------+------------------------+---------------------|
| =<ScalarType>=               | C++的标量类型          | Fortran中的等价类型 |
|------------------------------+------------------------+---------------------|
| =S=, =float32=               | =float=                | =real(kind=4)=      |
| =D=, =float64=, =float=      | =double=               | =real(kind=8)=      |
| =C=, =complex64=             | =std::complex<float>=  | =complex(kind=4)=   |
| =Z=, =complex128=, =complex= | =std::complex<double>= | =complex(kind=8)=   |
|------------------------------+------------------------+---------------------|

#+caption: \label{table:可用的symmetry} 可选的 =SymmetryType=
#+ATTR_LATEX: :font \scriptsize
|------------------+----------------------------------+---------------------------|
| =<SymmetryType>= | C++中的对称性类型                | 守恒量的例子              |
|------------------+----------------------------------+---------------------------|
| =No=, =Normal=   | =Symmetry<>=                     | 没有任何守恒              |
| =BoseZ2=, =Z2=   | =Symmetry<bose<Z2>>=             | z方向自旋宇称             |
| =BoseU1=, =U1=   | =Symmetry<bose<U1>>=             | z方向自旋                 |
| =FermiU1=        | =Symmetry<fermi<U1>>=            | 费米子数目                |
| =FermiU1BoseZ2=  | =Symmetry<fermi<U1>, bose<Z2>>=  | 费米子数目和z方向自选宇称 |
| =FermiU1BoseU1=  | =Symmetry<fermi<U1>, bose<U1>>=  | 费米子数目和z方向自选     |
| =FermiZ2=        | =Symmetry<fermi<Z2>>=            | 费米子数目宇称            |
| =FermiU1FermiU1= | =Symmetry<fermi<U1>, fermi<U1>>= | 两个不同的费米子数目      |
|------------------+----------------------------------+---------------------------|

和C++接口一样， 用户可以通过使用统一的接口 =Tensor(name_list, edge_list)= 来创建各种类型的张量，如代码 [[ref:code:complex-symmetry-py]] 展示了代码 [[ref:code:complex-symmetry-cpp]] 的等价Python版本。
\begin{lstlisting}[caption={Python接口创建的类型更复杂的张量},label={code:complex-symmetry-py},language=Python]
import TAT

A = TAT.FermiU1BoseZ2.D.Tensor(["i", "j"], [
    ([
        ((-1, False), 1),
        ((0, False), 1),
        ((+1, False), 1),
        ((-1, True), 1),
        ((0, True), 1),
        ((+1, True), 1),
    ], False),
    ([
        ((-1, False), 1),
        ((0, False), 1),
        ((+1, False), 1),
        ((-1, True), 1),
        ((0, True), 1),
        ((+1, True), 1),
    ], True),
]).zero_()
\end{lstlisting}

TAT的Python接口封装提供了与其他 Python 包出色的互操作性，能够通过 pickle 对 TAT 张量进行序列化和反序列化。此外，它支持将张量块导出为 NumPy 数组，并保持内存共享，从而实现与 Python 生态系统的无缝集成。
TAT中常用的函数列在表 [[ref:table:TAT-functions]] 中，由于C++和Python接口高度一致，这里只展示Python的接口。

#+begin_export latex
\begin{table} [h]
\begin{center}
\caption{\label{table:TAT-functions}常用的函数}
\scriptsize
\begin{tabular}{|c|c|}
\hline
function & example\\\hline\hline
\texttt{clear\_symmetry} & \texttt{A.clear\_symmetry()} \\\hline
\texttt{conjugate} & \texttt{A.conjugate()} \\\hline
\texttt{contract} & \texttt{A.contract(B, {("i", "o")})} \\\hline
\texttt{edge\_rename} & \texttt{A.edge\_rename({"i": "j"})} \\\hline
\texttt{exponential} & \texttt{A.exponential({("i", "o")})} \\\hline
\texttt{identity\_} & \texttt{A.identity\_({("i", "o")})} \\\hline
\texttt{map} & \texttt{A.map(lambda x: x + 1)} \\\hline
\texttt{merge\_edge} & \texttt{A.merge\_edge({"ij": ["i","j"]})} \\\hline
\texttt{qr} & \texttt{A.qr('r', {"i"}, "q", "r")} \\\hline
\texttt{randn\_} & \texttt{A.randn\_(0, 1)} \\\hline
\texttt{rand\_} & \texttt{A.rand\_(0, 1)} \\\hline
\texttt{reverse\_edge} & \texttt{A.reverse\_edge({"i"})} \\\hline
\texttt{split\_edge} & \texttt{A.split\_edge({"ij": [("i", seg\_i), ("j", seg\_j)]})} \\\hline
\texttt{svd} & \texttt{A.svd({"i"}, "u", "v", "su", "sv")} \\\hline
\texttt{trace} & \texttt{A.trace({("i", "o")})} \\\hline
\texttt{transform\_} & \texttt{A.transform\_(lambda x: x + 1)} \\\hline
\texttt{transpose} & \texttt{A.transpose(["j","i"])} \\\hline
\texttt{zero\_} & \texttt{A.zero\_()} \\\hline
\end{tabular}
\note{注：
1. 函数名遵循命名约定，即内置函数以下划线 “\texttt{\_}” 结尾。
2. \texttt{clear\_symmetry} 函数旨在最大程度地消除对称信息。对于非费米子对称性张量，此操作生成一个非对称性张量。反之，对于费米子张量，该操作的结果是一个费米-$Z(2)$ 对称性张量。
3. \texttt{contract} 函数的第二个参数是一个包含对的集合，每对包含第一个张量中的一个边名及其在第二个张量中的对应边名。
4. \texttt{exponential}、\texttt{identity\_} 和 \texttt{trace} 函数需要一组对来确认边的关系，明确指出张量中哪条边与哪条边对应。
5. 在 \texttt{qr} 函数中，当第一个参数为 \texttt{'r'} 时，第二个参数表示新形成的 \texttt{R} 张量的自由边。相反，如果第一个参数是 \texttt{'q'}，第二个参数则指定 \texttt{Q} 张量的自由边。最后两个参数表示 QR 分解过程中新创建的边的名称。
6. \texttt{randn\_} 函数根据指定的均值和标准差生成正态随机数并填充到张量中，而 \texttt{rand\_} 函数在给定的上下边界内生成均匀随机数并填充到张量中。
7. \texttt{split\_edge} 函数需要新边的分段信息，因为在合并过程中边的分段信息会丢失。
8. 与 \texttt{qr} 函数相比，\texttt{svd} 函数需要为对角 \texttt{S} 张量额外指定两个边名。然而，由于在 SVD 中 \texttt{U} 和 \texttt{V} 是对称的，用户应始终指定新 \texttt{U} 张量的自由边。
}
\end{center}
\end{table}
#+end_export

*** 张量网络态库（tetragono）

tetragono是一个多功能的软件包， 为各种张量网络态(TNS)方法提供了一个统一的接口， 适用于不同的物理模型和张量类型。
它包含了多种TNS方法， 包括简单更新和基于采样的技术。
对于基于采样的方法， 它方便了物理观测量的计算， 并纳入了优化策略， 如梯度下降和随机重构型。
此外， tetragono提供了一种精确对角化方法， 可以作为在小系统中验证TNS结果的基准。
它建立在张量包 TAT 的Python接口之上， 支持对称性张量和费米子张量。
用户可以通过编写插件来扩展其功能， 修改现有算法或引入自定义物理模型。

tetragono主要支持由投影纠缠对态(PEPS)表示的方形格子系统。
然而， 通过在PEPS框架的单个张量中包含多个物理边， 可以适应其他格子几何形状。
tetragono提供了多种接口， 包括一个名为tetragono shell的命令行界面(CLI)应用程序， 以方便使用。
其组件可以单独使用， 赋予用户构建更复杂算法的能力。

tetragono首先定义一个抽象态类型（AbstractState）以概述晶格系统的基本信息，包括：
+ 晶格的尺寸。
+ 每个晶格点的物理边数目，使用轨道索引区分相同位置的多条物理指标。
+ 每条物理指标的量子数及简并信息。
+ 总的哈密顿量，表示为局部哈密顿量之和，每个局部哈密顿量由一个张量表示，该张量包含晶格坐标及不同物理边之间相互作用的信息。
+ 如果系统具有非平凡的总量子数（例如电子总数），则还会有可能的总量子数。

随后，从抽象态类型衍生得到抽象晶格类型（AbstractState），添加有关PEPS中每个虚拟指标的量子数和简并的信息。
在此基础上，基于这两个抽象类实现了各种TNS方法，如简单更新法或多种基于采样的方法。
我们还实现了基于采样的优化方法，包括梯度优化，以及随机重构方法。
该软件包支持遍历、直接采样和Metropolis采样作为采样方法。
tetragono通过插件支持定义抽象态和抽象晶格来描述自定义物理模型和PEPS形式，也可以对在包中实现的算法中进行定制，比如Markov链中的采样规则。

tetragono的代码位于仓库的 =/tetragono= 目录下，组织如下：
+ 抽象态 (AbstractState) 实现在  =abstract_state.py=  中。
+ 抽象晶格 (AbstractLattice) 实现在  =abstract_lattice.py=  中。
+ 精确对角化实现在  =exact_state.py=  中。
+ 简单更新算法实现在  =simple_update_lattice.py=  中。
+ 鉴于采样方法的多样性，相关函数实现在  =sampling_lattice=  子目录中。在这个目录中：
  + =lattice.py=  指定了包含数据的晶格类型和个别采样结果的配置类型。
  + =sampling.py=  包含了若干方法，包括遍历、直接采样和Metropolis采样。
  + =observer.py=  用于从采样结果中测量并计算梯度。
  + 最后，所有这些功能通过 =gradient.py=  中的驱动函数集成并执行。
+ =utility.py=  包含各种工具函数。
+ =auxiliaries=  目录，利用 =lazy_graph= ，如图 [[ref:fig:张量网络态计算套件的结构]] 所述，用于构型类型，包含几个辅助系统，旨在最小化在边界MPS方法中张量网络收缩的冗余计算，特别是移除或替换多个格点的张量时。
+ =conversion.py=  中定义了适用于不同算法的对象转换函数。
+ 最后， =shell.py=  提供了一个高层次、用户友好的接口，称为tetragono shell，用于访问tetragono中的所有功能。

用户可以在命令行中执行 =python -m tetragono.shell= 进入 tetragono shell。
在tetragono shell中输入 =help= 或 =?= 将显示可用命令。 要获取特定命令的详细使用信息, 用户可以输入 =help <command>= 。
用户可以在tetragono shell中逐行执行命令, 也可以在脚本文件中列出多个命令, 并使用 =python -m tetragono.shell <script_file>= 运行它们。
通过这种方式, 可以自动利用 MPI, 这意味着如果用户使用 =mpirun python -m tetragono.shell <script_file>= 执行脚本文件, tetragono 内部实现的每个算法都将在可能的情况下使用 MPI 并行运行，从而加快程序执行速度。

*** 常见模型合集（tetraku）

我们使用tetragono实现了几种流行的典型物理模型。
这些模型包括方格晶格上的J1-J2模型、六角晶格上的Hubbard模型、方格晶格上的Rydberg模型等。
我们将这些模型收集到 tetraku 库中。
对于这些预定义模型，用户可以直接使用，无需进一步编码。
此外，这些模型用作参考，或直接修改以包括额外的相互作用，从而创建更复杂的模型。

** 套件的使用展示

在本章节中，我们通过一个例子展示了TNSP中TAT的Python接口的使用。
这是一个使用费米子PEPS方法解决方格晶格上的无自旋费米子模型的例子。
随后，我们重新使用tetragono接口来改写此示例，相较于直接使用TAT，这种方法更为简便。

方格晶格上自由费米子模型的哈密顿量为
\begin{equation}
H = \sum_{\langle i, j \rangle} (c_i^\dagger c_j + h.c.),
\end{equation}
其中， $\sum_{\langle i, j \rangle}$ 表示对最近邻对 $i$ 格点和 $j$ 格点的求和，本例采用开边界条件（OBC）。
这个模型的波函数将使用费米子PEPS表示，并采用简单更新时间演化方法 [[cite:Jiang2008]] 来优化这个波函数。

*** 使用Python接口TAT实现的简单更新

我们使用费米子 $Z(2)$ 对称性和双精度实张量来处理自由费米子模型，这在TAT中定义为张量类型 =TAT.FermiZ2.float64.Tensor= 。
在代码 [[ref:code:node-for-peps.py]] 中，我们定义了一个数据结构类 =Node= ，用于存储与每个格点相关的数据。
在 =Node= 类结构中， =Tensor= 负责容纳PEPS波函数的主要数据，该张量是一个五阶张量。
此张量包含四个指标对应于虚拟边，一个阶数用于物理指标。
此外，我们定义了四个环境张量： =left= 、 =right= 、 =up= 和 =down= 。
这些张量用于存储关于四个虚拟指标的环境信息，每个都是一个秩为2的张量，即矩阵。
环境张量的默认值设置为 =None= ，表示环境张量是一个单位矩阵。
边界边没有分配环境张量。
需要注意的是，通过一条边连接的相邻节点共享相同的环境张量。

\begin{lstlisting}[language=Python, label={code:node-for-peps.py}, caption={PEPS中的格点}]
from dataclasses import dataclass
import TAT
from TAT import parity

Tensor = TAT.FermiZ2.float64.Tensor


@dataclass
class Node:
    site: Tensor  # 存储每个格点的张量
    left: Tensor | None = None  # 存储环境张量
    right: Tensor | None = None  # 存储环境张量
    up: Tensor | None = None  # 存储环境张量
    down: Tensor | None = None  # 存储环境张量
\end{lstlisting}

在代码 [[ref:code:init-peps.py]] 中，我们为费米子PEPS波函数生成具有费米子 $Z(2)$ 对称性的费米子张量。
在第2-10行，我们准备了五条边，每条边由段（以量子数及其相应简并度的对列表表示）与费米箭头组成。费米箭头表示位于两个张量之间的EPR对中创造算符的顺序。
对于每条边，费米子 $Z(2)$ 对称性可能的两个量子数是偶性(+1)和偶性(-1)。
物理边的简并度统一设置为 =1= 。
虚拟边两个量子数的简并度设置为 =D1= 和 =D2= ，边界边的简并度设置为 =1= 和 =0= 。这里，参数 =D1= 和 =D2= 可以自由设置，只要它们的和等于表示虚拟指标总维度 =D= 。在更新过程中， =D1= 和 =D2= 将自动调整到最佳值。

随后，在代码 [[ref:code:init-peps.py]] 的第11-19行中，我们通过Python生成器创建一个二维列表，循环遍历每个PEPS中的点， =l1= 范围从 =0= 到 =L1-1= ， =l2= 范围从 =0= 到 =L2-1= ，其中 =L1= 和 =L2= 是晶格的大小。
该列表由 =Node= 类的实例组成。
张量使用指标的名称构建，例如 =left= 、 =right= 等。
出于历史原因 [[cite:Verstraete2008]] ，这里使用的坐标系统中， =l1= 表示行， =l2= 表示列。当然，用户可以选择自己的坐标系统。
环境张量保持默认值，这意味着对于内部边，环境是一个单位矩阵，而对于边界边，则没有环境张量。

\begin{lstlisting}[language=Python, label={code:init-peps.py}, caption=PEPS的初始化]
def initialPEPS(L1, L2, D1, D2):
    phyEdge           = ([(parity(+1), 1 ), (parity(-1), 1 )], False)
    leftEdge          = ([(parity(+1), D1), (parity(-1), D2)], False)
    boundaryLeftEdge  = ([(parity(+1), 1 ), (parity(-1), 0 )], False)
    rightEdge         = ([(parity(+1), D1), (parity(-1), D2)], True)
    boundaryRightEdge = ([(parity(+1), 1 ), (parity(-1), 0 )], True)
    upEdge            = ([(parity(+1), D1), (parity(-1), D2)], False)
    boundaryUpEdge    = ([(parity(+1), 1 ), (parity(-1), 0 )], False)
    downEdge          = ([(parity(+1), D1), (parity(-1), D2)], True)
    boundaryDownEdge  = ([(parity(+1), 1 ), (parity(-1), 0 )], True)
    return [[
        Node(site=Tensor(["phy", "left", "right", "up", "down"], [
            phyEdge,
            boundaryLeftEdge if l2 == 0 else leftEdge,
            boundaryRightEdge if l2 == L2 - 1 else rightEdge,
            boundaryUpEdge if l1 == 0 else upEdge,
            boundaryDownEdge if l1 == L1 - 1 else downEdge,
        ]).randn_()) for l2 in range(L2)
    ] for l1 in range(L1)]
\end{lstlisting}

哈密顿量是各项局部哈密顿量的和，每个局部哈密顿量是邻近位置 $i$, $j$ 上的两体相互作用 $h_{i,j} = c^\dag_i c_j + c^\dag_j c_i$ 。
其中， $c^\dag_i$ 表示在格点 $i$ 上费米子的生成算符，而 $c_i$ 是从格点 $i$ 的湮灭算符。
算符 $h_{i,j}$ 可视为具有费米子 $Z(2)$ 对称性的四阶张量，并可在 TAT 包中表示为相应类型的费米子张量。
在代码 [[ref:code:prepare-H.py]] 的第 1-13 行中，函数 =initialH= 被设计用来准备局部哈密顿量项 $h_{i,j}$ 。
在后续的函数 =initialGate= ， 第 16-18 行中，我们定义了一个门算符 $\mathrm{Gate} = \mathrm{e}^{−\tau h_{i,j}}$，其中 $\tau$ 是时间步长。
为了计算门张量的指数函数，指数函数被展开为级数形式，如图 [[ref:fig:张量指数的幂展开]] 所示。

\begin{lstlisting}[language=Python, label={code:prepare-H.py}, caption={准备虚时间演化的门张量}]
def initialH():
    # 准备物理指标即其共轭
    edge_out = ([(parity(+1), 1), (parity(-1), 1)], False)
    edge_in  = ([(parity(+1), 1), (parity(-1), 1)], True)
    # 初始化局部哈密顿量为零
    H = Tensor(
        ["Oi", "Oj", "Ii", "Ij"],
        [edge_out, edge_out, edge_in, edge_in],
    ).zero_()
    # 设置局部哈密顿量非零元素
    H[{"Oi": 1, "Oj": 0, "Ii": 0, "Ij": 1}] = 1
    H[{"Oi": 0, "Oj": 1, "Ii": 1, "Ij": 0}] = 1
    return H


def initialGate(H, tau):
    # 从哈密顿量得到演化门算子
    return (-abs(tau) * H).exponential({("Ii", "Oi"), ("Ij", "Oj")})
\end{lstlisting}

在代码 [[ref:code:su-two-site.py]] 中的 =step= 函数中，我们展示了使用门张量对两个格点进行简单更新，如 [[ref:sec:::简单更新]] 中介绍的那样。
\begin{lstlisting}[language=Python, label={code:su-two-site.py}, caption=两个格点上的单步演化]
def step(A, env, B, gate, cutoff, A_dir, B_dir):
    # 为了复用，这里输入的三个张量这样相连
    # -A_dir-[A]-B_dir- -A_dir-[env]-B_dir- -A_dir-[B]-B_dir-
    # A_dir 和 B_dir 是指标名

    # A和B各自进行QR，以将酉部分提取出去，从而降低后续复杂度
    q_A, r_A = A.qr('r', {"phy", B_dir}, B_dir, A_dir)
    q_B, r_B = B.qr('r', {"phy", A_dir}, A_dir, B_dir)
    # 重命名R张量的指标，避免后续冲突
    r_A = r_A.edge_rename({"phy": "Oi"})
    r_B = r_B.edge_rename({"phy": "Oj"})
    # 收缩A、环境的逆（如果非空）、B和门张量
    C = r_A
    if env is not None:
        C = C.contract(env.reciprocal(), {(B_dir, A_dir)})
    C = C.contract(r_B, {(B_dir, A_dir)})
    C = C.contract(gate, {("Oi", "Ii"), ("Oj", "Ij")})
    # 对收缩结果进行SVD，并截断
    new_A, new_env, new_B = C.svd({A_dir, "Oi"}, B_dir, A_dir, A_dir, B_dir, cutoff)
    # 归一化环境张量
    new_env = new_env / new_env.norm_max()
    # 恢复PEPS的形式，将SVD的结果和新环境与先前的酉矩阵收缩
    new_A = new_A \
        .contract(new_env, {(B_dir, A_dir)}) \
        .contract(q_A, {(A_dir, B_dir)}) \
        .edge_rename({"Oi": "phy"})
    new_B = new_B \
        .contract(new_env, {(A_dir, B_dir)}) \
        .contract(q_B, {(B_dir, A_dir)}) \
        .edge_rename({"Oj": "phy"})
    return new_A, new_env, new_B
\end{lstlisting}

在代码 [[ref:code:su.py]] 中，函数 =simple_update= 通过对所有近临邻点调用 =step= 函数来对整个系统执行单步简单更新。

\begin{lstlisting}[language=Python, label={code:su.py}, caption=PEPS上单步简单更新]
def simple_update(peps, gate, L1, L2, D):
    # 循环所有的横向边
    for l1 in range(L1):
        for l2 in range(L2 - 1):
            # 获取将更新的张量
            A = peps[l1][l2].site
            env = peps[l1][l2].right
            B = peps[l1][l2 + 1].site
            # 调用step
            A, env, B = step(A, env, B, gate, D, "left", "right")
            # 更新张量
            peps[l1][l2].site = A
            peps[l1][l2 + 1].site = B
            peps[l1][l2].right = peps[l1][l2 + 1].left = env
    # 循环所有的竖向边
    for l2 in range(L2):
        for l1 in range(L1 - 1):
            # 获取将更新的张量
            A = peps[l1][l2].site
            env = peps[l1][l2].down
            B = peps[l1 + 1][l2].site
            # 调用step
            A, env, B = step(A, env, B, gate, D, "up", "down")
            # 更新张量
            peps[l1][l2].site = A
            peps[l1 + 1][l2].site = B
            peps[l1][l2].down = peps[l1 + 1][l2].up = env
\end{lstlisting}

定义了 =simple_update= 后， 函数可以直接用于执行简单更新的计算。
代码 [[ref:code:runsu.py]] 中通过在 $4 \times 4$ 格子上执行 $50$ 步简单更新提供了一个示例， 虚拟指标维度被设置为 $D=4$ 。初始态中， $D$ 的一半分配给量子数 $+1$，另一半分配给 $-1$ 。

\begin{lstlisting}[language=Python,label={code:runsu.py}, caption=使用\texttt{simple\_update}函数]
L1 = L2 = 4
D = 4
tau = 0.1
step_number = 50

peps = initialPEPS(L1, L2, D // 2, D // 2)
gate = initialGate(initialH(), tau)
for i in range(step_number):
    simple_update(peps, gate, L1, L2, D)
\end{lstlisting}

从这个例子中，我们看到通过使用TAT，可以像编写普通的、用于玻色子或自旋系统的PEPS方法那样为费米子系统编写代码。
一旦系统的哈密顿量和初始参数确定，就无需再在后续使用过程中考虑费米子的反对易性质。

*** 使用tetragono实现的简单更新 <<sec:::tet-example>>

在本章节中，我们使用tetragono接口重写了自由费米子模型的简单更新，与直接使用TAT相比，这大大简化了过程。
一旦定义了物理模型，tetragono中实现的每个算法都可以通过一个命令访问。
要描述自定义的物理模型，用户只需定义两个函数： =abstract_state= 用于确定模型的物理指标和哈密顿量，以及 =abstract_lattice= 用于设置PEPS中的虚拟指标。

\begin{lstlisting}[language=Python, label={code:tet-abs-state.py}, caption=自由费米子的描述：\texttt{abstract\_state}]
import TAT
from TAT import parity
import tetragono as tet


def abstract_state(L1, L2):
    # 创建抽象态，大小设置为 L1 * L2
    # 张量类型为 fermi-Z(2) 对称性的双精度实浮点数张量
    state = tet.AbstractState(TAT.FermiZ2.D.Tensor, L1, L2)
    # 每个格点一个轨道
    for l1 in range(L1):
        for l2 in range(L2):
            state.physics_edges[l1, l2, 0] = [(parity(+1), 1), (parity(-1), 1)]
    # 获取预定义的CC算符用作哈密顿量
    CC = tet.common_tensor.Parity.CC.to(float)
    # 设置所有近邻格点有CC相互作用
    for l1 in range(L1):
        for l2 in range(L2):
            if l1 != 0:
                state.hamiltonians[(l1 - 1, l2, 0), (l1, l2, 0)] = CC
            if l2 != 0:
                state.hamiltonians[(l1, l2 - 1, 0), (l1, l2, 0)] = CC
    return state
\end{lstlisting}

在代码 [[ref:code:tet-abs-state.py]] 中，我们为自由费米子模型定义了 =abstract_state= ，包括系统大小和张量类型开始，以及每个格点的物理指标。
该指标由两个段组成：一个量子数为 =+1= ，另一个为 =−1= ；每个段的简并度都是 =1= 。
根据 [[ref:sec:::费米子张量]] 中的讨论，物理指标的费米箭头默认设置为 =False= 。
在tetragono中，每个格点可以承载多个物理指标，并通过其轨道索引区分。
在本例子中，由于每个格点只有一个物理指标，所有轨道索引都是 =0= 。

\begin{lstlisting}[language=Python, label={code:tet-abs-lattice.py}, caption=用于自由费米子的费米子PEPS描述：\texttt{abstract\_lattice}]
def abstract_lattice(L1, L2, D):
    # 从抽象态创建抽象晶格
    lattice = tet.AbstractLattice(abstract_state(L1, L2))
    # 设置竖向边
    for l1 in range(lattice.L1 - 1):
        for l2 in range(lattice.L2):
            lattice.virtual_bond[l1, l2, "D"] = [(parity(+1), D // 2), (parity(-1), D // 2)]
    # 设置横向边
    for l1 in range(lattice.L1):
        for l2 in range(lattice.L2 - 1):
            lattice.virtual_bond[l1, l2, "R"] = [(parity(+1), D // 2), (parity(-1), D // 2)]
    return lattice
\end{lstlisting}

要为给定模型构建PEPS波函数，还需要描述虚拟指标。
这在 =abstract_lattice= 函数中实现，该函数根据在 =abstract_state= 函数获得的虚拟态的基础上，加上虚拟指标信息。
如代码 [[ref:code:tet-abs-lattice.py]] 所示，每个边缘由两个段组成：一个段的量子数为 =+1= ，简并度为 =D/2= ；另一个段的量子数为 =−1= ，简并度相同。
当我们为格点 =(l1, l2)= 的设置下指标 ="D"= 时，对应格点 =(l1 + 1, l2)= 的上指标 ="U"= 会自动设置为其共轭，水平边上的指标也有相同的行为。

一旦定义了这两个函数，它们可以被保存到如名为 =ff.py= 的文件中。
随后，可以编写一个脚本，如代码 [[ref:code:tet-script.tet]] 所示，以对这个费米子PEPS执行简单更新算法。
在第1行，它初始化一个自由费米子模型的晶格，参数为 =L1=4= 、 =L2=4= 和 =D=4= ，这些参数对应于 =ff.py= 中的 =abstract_lattice= 函数。
在第2行，它应用了简单更新算法，这里指定了总步骤、 $\Delta \tau$ 和简单更新中的维度截断。

\begin{lstlisting}[label={code:tet-script.tet}, caption=创建晶格系统并执行简单更新的 \texttt{tetragono} 脚本]
su_create free_fermion.parity L1=4 L2=4 D=4
su_update 100 0.01 4 # 总步数为100的简单更新，tau=0.01、 D=4
\end{lstlisting}

通过将这个脚本文件保存为如名为 =network_example.tet= 的文件，我们可以使用命令 =python -m tetragono.shell network_example.tet= 运行它，即创建一个 $4 \times 4$ 费米子PEPS上的自由费米子模型，随后进行简单更新。

*** 使用 tetraku 进行的简单更新

无自旋的自由费米子等常见模型已经在 tetraku 库中实现，对于 fermi-$Z(2)$ 对称性，其被命名为 =free_fermion.parity= 。
因此， [[ref:sec:::tet-example]] 讨论的例子可以通过代码 [[ref:code:tetraku-example.tet]] 中的脚本轻松实现，无需额外编码。

\begin{lstlisting}[label={code:tetraku-example.tet}, caption=使用 \texttt{tetraku} 中的描述文件进行的简单更新]
su_create free_fermion.parity L1=4 L2=4 D=4
su_update 100 0.01 4 # 总步数为100的简单更新，tau=0.01、 D=4
\end{lstlisting}

* 六角晶格中的Hubbard模型的掺杂基态模拟计算 <<sec:超导>>

** 背景介绍与主要结论

对高温超导现象 [[cite:Bednorz1986,Wu1987]] 的理解是当代凝聚态物理学中最具挑战性的课题之一。
普遍认为，通过研究掺杂的Mott绝缘体 [[cite:Lee2006]] 可以理解高温超导，而Hubbard模型 [[cite:Hubbard1964]] 是描述这类绝缘体的基本工具。
然而，多年来的研究表明，在方形晶格上原始的Hubbard模型并不能产生稳定的超导态 [[cite:Rozhkov2011,Kitatani2019,Qin2020]] 。
这引起了人们对使用Hubbard模型来研究六角晶格上电子电子关联的兴趣 [[cite:Pathak2010,BlackSchaffer2014,Wang2012,Xu2016,Jiang2014,Gu2020,Kiesel2012,Raghu2010,Honerkamp2008,Ying2020,Wolf2018,Nandkishore2012,Watanabe2013,Ma2014,Wu2013]] 。
与方形晶格相比，六角晶格因其六边形结构展现出独特的电子特性。
六角晶格的能带结构在费米能级处具有Dirac锥，同时在 $1/8$ 电子和空穴掺杂的情况下，表现出对数型 Van Hove 奇异性以及显著的费米面嵌套，
这些特性可能增强六角晶格上的长程超导相 [[cite:Pathak2010,Nandkishore2012]]。

尽管在半填充时观察到在约 $U_c = 3.8$ 处有从半金属到反铁磁态的相变 [[cite:Otsuka2016]] ，但关于掺杂对六角晶格上Hubbard模型中的反铁磁态的影响仍然没有彻底研究。
许多研究都探讨了六角晶格上的超导性，但结果存在争议。
一个关于六角晶格上Hubbard模型的变分量子Monte Carlo（QMC）研究提出，在掺杂石墨烯中存在具有手性d + id对称性的超导 [[cite:Pathak2010]] 。
另外，另一项QMC模拟也预测了在强相互作用区间会出现金手性 $d + id$ 波超导性 [[cite:BlackSchaffer2014]] 。
同样，Grassmann张量乘积态（GTPS）研究也表明在大U极限下，t-J模型中存在手性超导态 [[cite:Gu2013]] 。
然而，最新的密度矩阵重整化群（DMRG）模拟结果与这些研究相矛盾，指出在掺杂六角晶格的Hubbard模型中，Cooper对关联中缺乏准长程序 [[cite:Qin2022]] 。

然而，这些数值方法各自有其局限性。
VMC方法依赖于基于先验知识设定的初态，这可能导致结果有偏。
DMRG方法对于一维或准一维系统有效，但可能无法充分捕捉二维系统的特性。
此外，文献 [[cite:Gu2013]] 中使用的GTPS使用了简单更新算法，在时间演化过程中涉及近似处理，可能影响结果的准确性。

为了深入探究六角晶格中Hubbard模型掺杂后的性质，我们在一个较宽的参数范围内通过第 [[ref:sec:张量和张量网络]] 章中介绍的费米子投影纠缠对状态研究了空穴掺杂的六角晶格Hubbard模型。
我们使用第 [[ref:sec:张量网络态算法]] 章介绍的各种优化方法对 PEPS 进行优化，确保了可控的精度。
这些方法一方面避免了简单更新优化过程中忽略环境影响而导致的误差，另一方面显著降低了与张量网络截断 $D$ 相关的复杂度问题，使得能够利用更大的网络截断，从而在大系统中实现高度精确且收敛的结果。
我们观察到准长程超导秩序的存在，其特征是Cooper对关联随距离呈幂律衰减，衰减指数 $K > 1$ 。
我们还研究了系统中的竞争相，包括电荷密度波（CDW）序和反铁磁（AFM）序。
结果发现，在低掺杂浓度下，基态呈现AFM序，然而随着掺杂浓度的增加，这一秩序逐渐减弱，并最终在 $\delta>0.05$ 时消失。
相比之下，即使在较高的掺杂浓度下，基态仍持续表现出稳定的CDW序。

** 方法

哈密顿量Hubbard模型的公式为
\begin{equation}
H = -t \sum_{\langle i,j \rangle, \sigma} \left( c_{i, \sigma}^\dagger c_{j, \sigma} + \text{h.c.} \right) + U \sum_i n_{i \uparrow} n_{i \downarrow},
\end{equation}
其中， $t$ 和 $U$ 分别为相邻格点之间的跃迁参数和格点上的库伦相互作用。
这里， $c_{i, \sigma}$ 表示在格点 $i$ 处具有自旋 $\sigma$ 的电子湮灭算符，且 $n_{i\sigma} = c_{i\sigma}^\dagger c_{i\sigma}$ 。 本文中，默认 $t = 1$ 。

该哈密顿量的多粒子波函数由费米子PEPS表示。为了简化实现，我们将六角格子映射到如图 [[ref:fig:六角格子映射]] 所示的方格子上。
对于方格子上的每个格点，我们定义一个承载六角格子上的两个物理指标的张量，左上和右下两个角上的张量除外，它们依然只有一个物理指标。
因此，PEPS中的张量的物理指标维度为 $4^2 = 16$ 。

#+begin_export latex
\begin{figure}
\centering
\includegraphics[width=0.4\textwidth]{figures/honeycomb.pdf}
\caption{六角格子系统到方格子的映射}
\label{fig:六角格子映射}
\note{注：
六角晶格到方形晶格的映射，用于PEPS方法。每个灰色椭圆对应于PEPS中一个单独的张量，涵盖了两个六角晶格格点，左下角和右上角除外，它们仅包含一个点。黄色区域表示选择用于计算Cooper对相关函数的区域。
}
\end{figure}
#+end_export

我们首先通过应用简单更新方案来优化PEPS波函数  [[cite:Jiang2008]]  。
得出的PEPS波函数随后作为初始态，利用梯度下降法进行进一步优化  [[cite:Sandvik2007,Liu2017,Dong2019]] 。
在整个优化过程中，总粒子数始终保持守恒，以确保符合预期的掺杂浓度。
这一守恒性是通过强制要求 PEPS的 fermi-$U(1)$ 对称性来实现的 [[cite:Singh2010]] 。
在简单更新过程中，我们通过降序排列奇异值并保留最大的奇异值来截断虚拟指标，从而决定虚拟指标上量子数的选择。
通过简单更新过程确定的虚拟指标量子数随后被用于梯度下降优化计算。
为了计算能量和梯度，我们采用了文献 [[cite:Vieijra2021]] 中提出的直接采样技术。
这种方法非常高效，因为避免了采样构型之间的关联，提高了计算效率和结果精度。
从最初的虚拟指标维度 $D=4$ 开始，我们在简单更新过程中，逐步增加维度到 $D=16$ ，使能量收敛到约 $10^{-3}$ 的水平，如图 [[ref:fig:超导D收敛]] 所示。
边界MPS方法中的截断维度被设置为 $D_c=2D$ ，同时，在优化PEPS过程中使用的采样数设定为 $N=10^4$ 。
这些优化步骤和参数选择确保了我们在计算中能够获得准确和可靠的结果，为后续分析提供可靠的基础。

#+begin_export latex
\begin{figure}
\centering
\includegraphics[width=0.6\textwidth]{figures/converge-D.pdf}
\caption{能量随 $D$ 的收敛图}
\label{fig:超导D收敛}
\note{注：
对于 $10 \times 10$ 的晶格（ $198$ 个格点 ），在参数 $U=8$ 和 $δ=0.1$ 的情况下，系统的能量作为虚拟指标维度 $D$ 的倒数的函数呈现收敛趋势。当 $D$ 接近 $16$ 时，能量大约收敛到 $10^{-3}$。
}
\end{figure}
#+end_export

我们获得基态波函数后，则利用直接采样技术 [[cite:Vieijra2021]] 计算物理量和关联函数。
为了确保高精度，采样次数设定为 $10^5$ 次。此外，我们在此还提高了截断维度到 $D_c = 6D$ ，以尽可能减少截断误差。

** 计算结果与分析

*** 超导性质

我们首先研究了在六角格子上的空穴掺杂Hubbard模型的超导可能。
在六角格子上，单态和三态Cooper对函数分别定义为
\begin{equation}
\left\{
\begin{aligned}
\Delta_s^a(i) &= \frac{1}{\sqrt{2}}(c_{i\uparrow}c_{j\downarrow} - c_{i\downarrow}c_{j\uparrow}) ,\\
\Delta_t^a(i) &= \frac{1}{\sqrt{2}}(c_{i\uparrow}c_{j\downarrow} + c_{i\downarrow}c_{j\uparrow}) ,\\
\end{aligned}
\right.
\end{equation}
其中，$j = i + a$，$a$ 是围绕格点 $i$ 的三条边的方向之一。
Cooper对可以根据它们的对称性进一步分类，它们是 $\Delta_s^a(i)$ 和 $\Delta_t^a(i)$ 的线性组合。

具有超导性的系统可以根据其Cooper对配对的对称性进行分类。在六角格子上，可能的Cooper对对称性在文献 [[cite:Faye2015]] 中被定义为单态或三态对的组合，具体表达如下为
\begin{equation}\label{eq:cooper-sym}
\left\{
\begin{aligned}
    \Delta_{s}(i)    &= \Delta^s_1(i) + \Delta^s_2(i) + \Delta^s_3(i) , \\
    \Delta_{d+id}(i) &= \Delta^s_1(i) + e^{2\pi i/3} \Delta^s_2(i) + e^{4\pi i/3}\Delta^s_3(i) , \\
    \Delta_{d-id}(i) &= \Delta^s_1(i) + e^{-2\pi i/3} \Delta^s_2(i) + e^{-4\pi i/3}\Delta^s_3(i) , \\
    \Delta_{f}(i)    &= \Delta^t_1(i) + \Delta^t_2(i) + \Delta^t_3(i) , \\
    \Delta_{p+ip}(i) &= \Delta^t_1(i) + e^{2\pi i/3} \Delta^t_2(i) + e^{4\pi i/3}\Delta^t_3(i) , \\
    \Delta_{p-ip}(i) &= \Delta^t_1(i) + e^{-2\pi i/3} \Delta^t_2(i) + e^{-4\pi i/3}\Delta^t_3(i) .
\end{aligned}
\right.
\end{equation}
在此， $\Delta_1$ 、 $\Delta_2$ 和 $\Delta_3$ 分别三条边上的Cooper对，如图 [[ref:fig:cooper-pairs]]。

#+begin_export latex
\begin{figure}
\centering
\includegraphics[width=0.6\textwidth]{cooper-pairs.pdf}
\caption{\label{fig:cooper-pairs}Cooper对的对称性示意图}
\note{注：
(a) 对于 $s$ 波和 $f$ 波对，三个库珀对具有相同的相位；
(b) 对于 $p$ 波和 $d$ 波对，三个库珀对 $\Delta_1$ 、 $\Delta_2$ 和 $\Delta_3$ 分别具有相同的、 ${\rm exp(\pm 2/3 \pi i)}$ 和 ${\rm exp(\pm 4/3 \pi i)}$ 相位。
}
\end{figure}
#+end_export

根据以往研究 [[cite:Pathak2010,BlackSchaffer2014,Xu2016]] ，有一些证据支持在六角格子上的Hubbard模型中存在超导性。
例如，vQMC研究表明，在 $U = 2.4$ 和 $\delta = 0.2$ 的情况下，Hubbard模型中的单态库珀对具有恒定关联 [[cite:Pathak2010]] 。
此外，基于GTPS的变分方法在大 $U$ 极限 （即 $t-J$ 模型）下显示出非零的库珀对，表明该系统中可能存在超导性 [[cite:Gu2013]] 。
然而，他们的研究并未计算库珀对的关联函数。
而最近的DMRG和vQMC计算则表明，六角格子的Hubbard模型中不存在超导性 [[cite:Qin2022]] 。该研究发现Cooper对的关联长度是有限的。
为了进一步研究优化后的态中的超导性可能性，我们计算了跨越两个柱内区域的对关联函数，如图 [[ref:fig:六角格子映射]] 所示。

对关联函数定义为
\begin{equation}
C(\Delta r) = \frac{1}{N} \sum_{|{r}_1 - {r}_2| = \Delta r} |\langle \Delta({r}_1)^\dagger \Delta({r}_2) \rangle|,
\end{equation}

其中， $r_1$ 和 $r_2$ 为图 [[ref:fig:六角格子映射]] 所示的长条区域中满足 $|{r}_1 - {r}_2| = \Delta r$ 条件的点。
这些关联函数对相同 $\Delta r$ 的N个对关联进行平均得到的。
当 $\delta = 0$ 时，基态是反铁磁(AFM)绝缘体，对关联函数应呈指数衰减，这一点通过我们的数值计算得到验证，如图 [[ref:fig:指数衰减的超导]]。

#+begin_export latex
\begin{figure}
\centering
\includegraphics[width=0.4\textwidth]{exp-decay.pdf}
\caption{反铁磁态的Cooper关联衰减}
\note{注：
Cooper对关联在 $\delta=0$ 时呈指数衰。 系统为 $198$个格点的六角Hubbard模型；(a) $U=4$, (b) $U=8$, (c) $U=12$ 。}
\label{fig:指数衰减的超导}
\end{figure}
#+end_export

图 [[ref:fig:超导power-law]] 展示了在不同掺杂浓度下， $U=8$ 时的Cooper对关联函数。
具体来说，图 [[ref:fig:超导power-law]] (a) 显示了$\delta = 0.05$ 时的关联函数。
单态和三态的关联函数均表现出代数衰减，即
\begin{equation}
C(\Delta r) \propto \Delta r^{-K} .
\end{equation}
然而，拟合出的衰减参数 $K_s \sim K_t = 3.8$ 非常大，表明关联函数迅速趋近于零。
其中， $K_s$ 表示单态的衰减指数，$K_t$ 表示三态的衰减指数。
这些结果表明，在这一掺杂浓度下，六角格子上的Hubbard模型的超导性被抑制了。

#+begin_export latex
\begin{figure}
\centering
\includegraphics[width=0.4\textwidth]{power-decay.pdf}
\caption{代数衰减下的Cooper对关联}
\note{注：
在198个格点的六角格子上，对于不同的空穴掺杂浓度 $\delta$ ，计算了 $U = 8$ 时的单态和三态Cooper对关联函数 $C(\Delta r)$ 。
关联函数和 $\Delta r$ 均使用对数刻度表示。
实线为通过幂律衰减函数拟合的结果：$ C(\Delta r) \propto \Delta r^{-K} $ 。
}
\label{fig:超导power-law}
\end{figure}
#+end_export

图 [[ref:fig:超导power-law]] (b) 和图 [[ref:fig:超导power-law]] (c)分别展示了 $\delta = 0.15$ 和 $\delta = 0.25$ 时的关联函数。
与 $\delta = 0.05$ 的情况类似，这些关联函数也表现出幂律衰减。
拟合出的衰减指数 $K$ 随着掺杂浓度的增加而减小。
对于 $\delta = 0.15$ ， $K \sim 1.5$ ，而对于 $\delta = 0.25$ ， $K \sim 1.2$ 。
在三角格子上的 $t-J$ 模型中也发现了类似的幂律衰减现象 [[cite:Jiang2021]]。

随后，我们在更广阔的区间中进行了Hubbard模型的模拟，参数 $U$ 从 $4$ 到 $12$ ，探索了不同的掺杂浓度。
由于之前的研究表明， 当 $U < U_c \approx 3.8$ 时，在广泛的掺杂范围内，六角格子上的Hubbard模型基态为半金属 [[cite:Otsuka2016]] ，因此我们未研究 $U < 4$ 的情况。
我们的发现表明，在这些特定参数范围内，关联函数始终表现出幂律衰减行为。
单态($K_s$)和三态($K_t$)关联的衰减指数总结在图 [[ref:fig:k-plot]] 中，可以观察到几个显著的趋势。
随着掺杂浓度的增加，衰减指数 $K_s$ 和 $K_t$ 的值趋于减小。
对于 $U = 4$ 且掺杂浓度 $\delta$ 超过 $0.05$ 的情况， 参数 $K$ 始终小于2。
在 $\delta=0.2$ 的情况下， $K_s$ 和 $K_t$ 均接近 $1$ 。
此外，对于 $U = 8$ 且 $\delta$ 大于 $0.1$ 的情况，衰减指数 $K$ 继续保持在2以下，表明当温度趋近于0时超导磁化率发散 [[cite:Peng2023]] 。
有人提出在范霍夫奇点附近可能会发展出长程超导序 [[cite:Pathak2010,Nandkishore2012]]。
然而，图 [[ref:fig:k-plot]] 中 $1/8$ 掺杂附近的结果并未显示出显著的行为。

#+begin_export latex
\begin{figure}
\centering
\includegraphics[width=0.4\textwidth]{k-plot.pdf}
\caption{不同$U$和$\delta$下的基态Cooper对关联衰减指数$K$}
\note{注：
在包含198个格点的六角晶格上，不同的相互作用强度 $U$ 下， 单态对关联函数的幂律衰减指数 $K_s$ 和三态对关联函数的幂律衰减指数 $K_t$ 随空穴掺杂 $\delta$ 的变化关系。
(a) 单态对关联函数的幂律衰减指数 $K_s$ 随空穴掺杂 $\delta$ 的变化关系；
(b) 三态对关联函数的幂律衰减指数 $K_t$ 随空穴掺杂 $\delta$ 的变化关系。
}
\label{fig:k-plot}
\end{figure}
#+end_export

在空穴掺杂 $\delta=0.25$ 时， $K_s$ 接近 $1$ 。
然而，当 $U$ 达到 $12$ 且 $\delta=0.15$ 时，$K$ 的值超过了其他空穴浓度下的观察值。
这可能归因于存在一种竞争序，抑制了超导相。
值得注意的是，即使使用公式 [[eqref:eq:cooper-sym]] 中定义的对称Cooper对计算对关联函数，这些结果依然保持一致且稳定。

在之前的一项研究中，秦明普利用密度矩阵重正化群（DMRG）计算分析了六角格子上的Hubbard模型，结果表明超导序具有指数衰减的特性 [[cite:Qin2022]]。
需要注意的是，这些计算是在一个长而窄的准一维格子上进行的。
而我们的研究结果显示，对关联在距离 $\Delta r < 8$ 范围内呈现幂律衰减，在 $\Delta r = 8$ 处对关联值约为 $10^{-5} \sim 10^{-4}$ 。
在此距离范围内，我们的结果与文献 [[cite:Qin2022]] 的报告结果一致。
然而，文献 [[cite:Qin2022]] 的结果在 $\Delta r > 8$ 时显示出更快的衰减，可以用指数函数拟合。
这种差异可能来源于文献 [[cite:Qin2022]] 中使用的窄准一维格子。
在文献 [[cite:Peng2023]] 中，也观察到了Cooper对关联的幂律衰减。
但值得注意的是，该文中报告的衰减指数比我们研究中得到的要小。

*** 反铁磁序与电荷密度波序

与超导有竞争关系的相态中，最常观察到的两种相是反铁磁（AFM）和电荷密度波（CDW）。
图 [[ref:fig:sc-lattice]] 显示了在 $U = 12$ 和 $\delta = 0.05$ 条件下， 198个格点的系统的空穴密度 $n_h = 1 - n_{\uparrow} - n_{\downarrow}$ 和自旋密度 $S_z = \frac{1}{2}(n_{\uparrow} - n_{\downarrow})$。
在图 [[ref:fig:sc-lattice]] 中，圆圈的大小对应于空穴密度，而颜色则表示自旋密度的方向和大小。
系统表现出带有畴壁结构的弱反铁磁性。
空穴密度的空间变化则暗示了可能存在CDW序。
最近的DMRG结果也揭示了在 $1/16 < \delta < 1/12$ 范围内，$U = 8$ 条件下，长而窄的六角格子（最多 $4 \times 32$ 个格子）的电荷和自旋均处在条纹状态 [[cite:Qin2022]]。
在文献 [[cite:Qin2022]] 中，这些条纹垂直于系统的长边边界，这可能与系统尺寸和圆柱形边界条件有关。
我们的结果为这些条纹图案提供了额外的证据。

#+begin_export latex
\begin{figure}
\centering
\includegraphics[width=0.35\textwidth]{sc-lattice.pdf}
\caption{$U=12$ ， $\delta=0.05$ 时，Hubbard模型的基态实空间图}
\note{注：
Hubbard模型基态在 $U=12$ 和 $\delta=0.05$ 条件下，198个格子上的空穴密度 $\langle n_h \rangle$ 和自旋 $\langle S_z \rangle$ 。
颜色方案表示 $S_z$ 的幅值，红色表示自旋上，蓝色表示自旋下。圆圈的大小对应于空穴密度。
}
\label{fig:sc-lattice}
\end{figure}
#+end_export

在 $\delta = 0.05$ 和较大 $U$ 值的情况下，存在畴壁结构。
然而，当 $U$ 下降至 $U = 8$ 时，畴壁结构减弱，并在 $U = 4$ 时完全消失。
另一方面，当 $\delta$ 增加到 $0.10$ 时，畴壁结构也会消失。

为了更定量地描述基态性质，我们计算了空穴和自旋的结构因子，定义为
\begin{equation}
\left\{
\begin{aligned}
S_{h}(\mathbf{k}) &= \frac{1}{\delta^2N^2}\sum_{i,j}\langle n_h^i n_h^j  e^{2\pi i (\mathbf{R}_i-\mathbf{R}_j)\cdot \mathbf{k}}\rangle, \\
S_{z}(\mathbf{k}) &= \frac{1}{N^2}\sum_{i,j}\langle S_z^i S_z^j e^{2\pi i (\mathbf{R}_i-\mathbf{R}_j)\cdot \mathbf{k}}\rangle,
\end{aligned}
\right.
\end{equation}
其中 $N$ 是系统中的总格点数。
为了最小化边界效应，我们在求和时排除了位于边界上的格点。
在 $U = 12$ 和 $\delta = 0.05$ 时，空穴和自旋的结构因子如图 [[ref:fig:k-space]] (a)和(b)所示。
空穴结构因子显示出具有动量 $(4/3\pi, 0)$ 的电荷密度波 (CDW)序 ，如 $S_h(\mathbf{k})$ 在 $K$ 点的峰值所示。
这里的 CDW 序可能来源于费米面嵌套和电子-电子关联， 进一步讨论请参见文献 [[cite:Nandkishore2012,Hur2009]] 。
同样，自旋结构因子在 $K$ 点附近也显示出峰值，表明存在反铁磁 (AFM) 序。
这与方格子上的 AFM 不同，后者的自旋结构峰值在 $(\pi, \pi)$。

#+begin_export latex
\begin{figure}
\centering
\includegraphics[width=0.45\textwidth]{k-space.pdf}
\caption{空穴和自旋的结构因子}
\note{注：
(a) 空穴结构因子 $S_{h}({\bf k})$ 和 (b) 自旋结构因子 $S_z ({\bf k})$ 。
系统为198个格点的Hubbard模型，$U=12$ , $\delta=0.05$ 。
}
\label{fig:k-space}
\end{figure}
#+end_export

为了表征系统在不同 $U$ 和 $\delta$ 下的整体趋势，我们计算了不同参数下的自旋结构因子 $S_z (K)$ 和空穴结构因子 $S_h(K)$。
在图 [[ref:fig:factor-plot]] (a)、(b)、(c) 和 (d) 中，我们分别展示了 $U$ 值为 $16$ 、 $12$ 、 $8$ 和 $4$ 的结果。
反铁磁（AFM）序在不同 $U$ 下表现出类似的趋势，即随着空穴掺杂 $\delta$ 的增加而减小。
同样地，电荷密度波（CDW）序在不同 $U$ 参数下也表现出类似的趋势。
在 $\delta = 0$ 时，即未掺杂时，基态在 $U > 3.8$ 时预计为 AFM [[cite:Otsuka2016]]，这得到了我们的计算结果的验证。
然而，随着掺杂浓度的增加 ($\delta > 0$），AFM 序迅速减弱，在 $\delta=0.1$ 时几乎接近于零。
不过，在 $\delta = 0.05$ 时，我们仍然可以观察到显著的 CDW 序，这展现在一个较大的 $S_h(K)$ 值上。
随着掺杂浓度的进一步增加，CDW 序逐渐减弱。
然而，即使在相对较高的掺杂浓度如 $\delta = 0.2$ 时，仍然存在相当显著的 CDW 序。
这些发现表明，系统从 $\delta = 0$ 时的 AFM 基态逐渐过渡到随着掺杂浓度增加带来的 CDW 主导状态。
AFM 序逐渐被抑制，而 CDW 序变得更加显著。
即使在较高的掺杂浓度下，显著的 CDW 序仍然存在。

#+begin_export latex
\begin{figure}
\centering
\includegraphics[width=0.45\textwidth]{factor-plot.pdf}
\caption{各个参数下的AFM序与CDW序}
\note{注：
反铁磁（AFM，$S_{z}(K)$，用红色菱形表示）和电荷密度波（CDW，$S_{h}(K)$，用蓝色方块表示）的序参数，分别对应 (a) $U=4$，(b) $U=8$，(c) $U=12$ 和 (d) $U=16$，掺杂 $\delta$ 从 $0.00$ 到 $0.20$，系统为一个 198 个格点的六角格子上的Hubbard模型。
}
\label{fig:factor-plot}
\end{figure}
#+end_export

为了研究有限尺寸效应的影响，我们考察了不同晶格尺寸下反铁磁（AFM）序和电荷密度波（CDW）序随空穴掺杂 $\delta$ 的变化情况，特别是针对 $U = 12$ 的情况。
相应的结果如图 [[ref:fig:finite-scaling-cdw-afm]] 所示。
我们发现，随着晶格尺寸的增加，AFM 序和 CDW 序的结果逐渐收敛。
值得注意的是，在 198 个站点的晶格上，有限尺寸效应已经变得很小。
因此，对于这一晶格尺寸所得到的结果可以认为是对系统基态性质的可靠近似。

#+begin_export latex
\begin{figure}
\centering
\includegraphics[width=0.4\textwidth]{finite-scaling-cdw-afm.pdf}
\caption{AFM序和CDW序的有限尺寸效应}
\note{注：
(a) AFM序 $S_{z}(K)$ 和 (b) CDW序 $S_{h}(K)$ 关于 $\delta$ 的变化趋势，系统为 $U=12$ 时， 198个格点的六角Hubbard模型。
}
\label{fig:finite-scaling-cdw-afm}
\end{figure}
#+end_export

超导（SC）与电荷密度波（CDW）之间的关系是当前研究热点。
尽管普遍认为 SC 和 CDW 是竞争相，但仍有研究表明 SC 序和 CDW 可以共存，例如文献 [[cite:Morosan2006,Wang2015]] 中的实例。
因此，这仍然是一个活跃的研究领域，这些相位之间的相互作用依然是一个未解之谜。

** 小结

我们通过使用费米子 PEPS 方法研究了六角格子上空穴掺杂的Hubbard模型的基态。
我们在 从 $\delta=0$ 到 $0.25$ 的广泛空穴掺杂浓度，以及从 $U/t=4$ 到 $16$ 的相互作用强度范围的参数空间内，发现Cooper对表现出准长程有序，遵循幂律衰减，衰减指数 $K$ 大于 $1$ 但小于 $2$ 。
此外，我们的研究揭示，在低掺杂浓度下，基态表现出反铁磁（AFM）序。
然而，随着掺杂浓度的增加，这种有序性逐渐减弱，最终在 $\delta > 0.05$ 时消失。
相反，基态始终表现出持续的电荷密度波（CDW）序。
这些观察结果表明，系统的基态从 $\delta = 0$ 的 AFM 主导状态逐渐过渡到随着掺杂浓度增加的 CDW 主导状态。
此外，在大 $U$ 和小 $\delta$ 区域，系统显示出明显的畴壁结构。

* 基于自然梯度法的有限温算法 <<sec:有限温>>

** 背景介绍

张量网络态，作为处理二维阻挫系统和费米子系统的有力工具 [[cite:Verstraete2008,Ors2014,Cirac2021]]，通过捕捉量子多体系统的纠缠结构，使得基于其的方法可以给出这些系统基态的有效表示。
然而，虽然张量网络方法在模拟二维强关联系统方面取得了丰硕的成果，但迄今为止主要应用于零温。
然而，真实的物理系统总是存在于有限温度下。
此外，在有限温度下会出现更丰富的物理现象。
因此，有必要开发能够模拟有限温度下量子多体系统的张量网络方法。
一些研究 [[cite:Czarnik2015,Kshetrimayum2019,Chen2018,Li2023,White2009,Stoudenmire2010,Wietek2021,Schmoll2024]], 在使用张量网络处理二维热量子多体系统方面取得了一些进展。
一类方法是基于无限投影纠缠对态 (iPEPS) 或无限投影纠缠对算子 (iPEPO) 来模拟二维热态 [[cite:Czarnik2015,Kshetrimayum2019,Schmoll2024]] 。
这种方法通过在 PEPS 上施加平移不变性来模拟热力学极限中的热系统。
然而，这种限制使其无法模拟长程相互作用和破坏平移不变性的系统。
另一类方法是使用一维矩阵积态 (MPS) 或矩阵积算子 (MPO) 来模拟二维量子态 [[cite:Chen2018,Li2023,White2009,Stoudenmire2010,Wietek2021]] 。
然而，为了满足二维面积定律，严格表示二维量子态所需的 MPS 截断维度会随着系统宽度的增加而呈指数增长，从而将该方法限制在准一维系统中。

为此，我们基于PEPS的变分蒙特卡洛 [[cite:Liu2017,Liu2021,Vieijra2021]] ，发展出一套计算有限温系统的方法。
此方法由于使用张量网络态表示波函数，所以可以有效表示阻挫系统，也可以利用 [[ref:sec:::费米子张量]] 中介绍的费米子张量无缝地拓展到费米子系统，
我们通过对密度矩阵进行矢量化 [[cite:Kshetrimayum2019,Kshetrimayum2017]] ，将自无穷温开始的降温过程，转变成自然梯度、也就是随机重构型 [[cite:Sorella1998,Sorella2001]] 的优化过程。
不同于之前使用简单更新实现近似的虚时间演化​​工作 [[cite:Kshetrimayum2019,Schmoll2024]] ，此方法直接等价于在表示空间中进行虚时间演化 [[cite:Takai2016,Nomura2021,Hendry2022,Nys2023]] 。
其变分地更新PEPS网络，保证了精确地降温过程。
本方法继承了变分蒙特卡洛和PEPS计算基态的优势 ，可以大规模并行化实现，并且只需要收缩单层张量网络即可计算观测量与梯度。
我们将本方法与其他数值方法做对比，包括严格对角化、 随机级数展开 [[cite:Sandvik1991,Sandvik1992]] 和行列式量子蒙特卡罗 [[cite:Blankenbecler1981,Hirsch1983,Hirsch1985]] ，
我们方法的结果与这些方法保持一致。

** 方法

对于给定系统的哈密顿量 $H$ ，温度 $T=1/\beta$ 时，热态密度矩阵为
\begin{equation}
\rho(\beta) = \mathrm{e}^{-\beta H} ,
\end{equation}
故而我们可以写成
\begin{equation} \label{eq:原始降温公式}
\rho(\beta) = \mathrm{e}^{-\frac{\beta}{2} H} I \mathrm{e}^{-\frac{\beta}{2} H} .
\end{equation}
可以讲 公式 [[eqref:eq:原始降温公式]] 写成演化形式，即
\begin{equation} \label{eq:矩阵演化方程}
- \frac{\mathrm{d}}{\mathrm{d} \beta}\rho(\beta) = \frac{H}{2} \rho(\beta) + \rho(\beta) \frac{H}{2}
\end{equation}

而对于希尔伯特空间 $V$ 中的矩阵 $\rho$ ，我们可以将其矢量化为 $V \otimes V$ 空间中的向量，即
\begin{equation}
\rho = \sum_{ss'} \rho_{ss'} |s\rangle\langle s'| \to |\rho\rangle_\sharp = \sum_{ss'} \rho_{ss'} |s\rangle \otimes |s'\rangle.
\end{equation}
将公式 [[eqref:eq:矩阵演化方程]] 进行矢量化，我们得到
\begin{equation}
-\frac{\mathrm{d}}{\mathrm{d}\beta} |\rho(\beta)\rangle_\sharp = \frac{H \otimes I + I \otimes H^T}{2} |\rho(\beta)\rangle_\sharp .
\end{equation}

令 $H' =  \frac{H \otimes I + I \otimes H^T}{2}$ ，我们有
\begin{equation} \label{eq:矢量演化方程}
-\frac{\mathrm{d}}{\mathrm{d}\beta} |\rho(\beta)\rangle_\sharp = H' |\rho(\beta)\rangle_\sharp .
\end{equation}
而公式 [[eqref:eq:矢量演化方程]] 正是虚时间演化的演化方程，即
\begin{equation}
|\rho(\beta)\rangle_\sharp = \mathrm{e}^{-\beta H'}|\rho(0)\rangle_\sharp .
\end{equation}
这意味着，我们可以设 $|\rho(0)\rangle_\sharp=|I\rangle_\sharp$ ，并进行虚时间演化，从而得到系统的降温过程。

然而，对于二维的多体系统，表示为投影纠缠对态后，难以进行高精度的虚时间演化。
因此我们选择使用自然梯度法的方式进行变分地降温。
考虑直接在希尔伯特空间中，给定某个态 $|\psi\rangle$ ，给定某个哈密顿量 $O$ ，其能量为
\begin{equation}
E = \langle \psi | O | \psi \rangle .
\end{equation}
直接计算梯度，得到梯度优化的公式
\begin{equation} \label{eq:Hilbert空间的优化}
\Delta |\psi\rangle = - \Delta \tau 2 O |\psi\rangle ,
\end{equation}
其中 $\Delta\tau$ 为梯度下降的步长，$\Delta |\psi\rangle$ 为态的增量。
对比公式 [[eqref:eq:Hilbert空间的优化]] 和公式 [[eqref:eq:矢量演化方程]] ，我们可以发现，若
\begin{equation}
\left\{
\begin{aligned}
|\psi\rangle &= |\rho(\beta)\rangle_\sharp , \\
\tau &= \beta , \\
2O &= H' ,
\end{aligned}
\right.
\end{equation}
则公式 [[eqref:eq:Hilbert空间的优化]] 正是公式 [[eqref:eq:矢量演化方程]] 这个常微分方程的欧拉迭代解。
这意味着，在希尔伯特空间直接使用 $H'/2$ 作为哈密顿量进行标准的梯度优化，相当于在对原密度矩阵进行降温。
另一方面，[[ref:sec:::自然梯度法]] 介绍过的自然梯度法通过诱导度规，可以实现在参数空间中优化得到在希尔伯特空间进行标准的梯度下降的效果。
综上，我们可以通过算法 [[ref:alg:降温]] 实现在参数空间下的降温。

#+begin_export latex
\SetKwComment{Comment}{/* }{ */}
\begin{algorithm}
\caption{基于自然梯度的降温算法}\label{alg:降温}
\KwData{哈密顿量 $H$ ， 降温步长 $\Delta\beta$， 表示函数$\text{PEPS}$}
\KwResult{任意温度下的热态 $\rho(\beta)$}
初始化参数 $\theta$ 使得 $\text{PEPS}(\theta) = |I\rangle_\sharp$\;
$O \gets \frac{H \otimes I + I \otimes H^T}{4}$\;
$\beta \gets 0$\;
\While{$\beta$ 没有降温到目标温度}{
  $\rho(\beta) \gets \text{PEPS}(\theta)$\;
  $E, G, g \gets \texttt{VMC}(O, \rho(\beta))$ \Comment*[r]{使用 \ref{sec::各种采样方法} 中的方法采样得到梯度和度规}
  $\theta \gets \theta - \Delta\beta g^{-1} G$ \;
  $\beta \gets \beta + \Delta\beta$
}
\end{algorithm}
#+end_export

在自然梯度法中，我们需要计算度规的逆乘以梯度，即求解
\begin{equation}
g X = G,
\end{equation}
其中 $g$ 为度规， $G$ 为梯度， $X$ 为更新参数的方向。
这个求逆任务可以通过共轭梯度法实现 [[cite:Bjrck1979,Paige1982]]。
在共轭梯度法中，我们不需要知道矩阵 $g$ 的显式形式，只需要知道如何将其作用在向量 $X$ 上，然后多次迭代即可。
由于 $g$ 本身是 $n_p \times n_p$ 的矩阵，其中 $n_p$ 为参数空间大小。
而采样方法中， 公式 [[eqref:eq:度规的采样计算]] 给出的度规估计实际上是由 $n_p \times n_s$ 的矩阵乘以 $n_s \times n_p$ 的矩阵得到的，其中 $n_s$ 为采样数目。
故而共轭梯度法的复杂度为 $n_s n_p n_{cg}$ ，其中 $n_{cg}$ 为共轭梯度法的迭代步数。
当 $n_p \gg n_s$ 时，共轭梯度相比与直接求逆 的 $O(n_p^3)$ 复杂度要快很多。

相较与标准的共轭梯度法，我们可以共轭梯度法内，计算 $X^\dag g X$ 时做一些改进。
我们不需要将 $g$ 完全作用在 $X$ 上，取而代之，我们直接将 $X$ 放入公式 [[eqref:eq:度规的采样计算]] ，得到
\begin{equation}
X^\dag_i \widehat{g}^{ij} X_j = \frac{\sum_{s \sim S} r_s (X^\dag_i \Delta_s^i) (\Delta_s^{j*} X_j)}{\sum_{s \sim S} r_s} - \frac{\sum_{s \sim S} r_s (X^\dag_i \Delta_s^i)}{\sum_{s \sim S} r_s} \frac{\sum_{s \sim S} r_s (\Delta_s^{j*} X_j)}{\sum_{s \sim S} r_s} ,
\end{equation}
这样我们可以复用多个中间变量，既减少了运算，也提高了数值稳定性。
这是共轭梯度法的一个常见技巧 [[cite:Bjrck1979,Paige1982]] 。

** 基准测试结果

*** 量子自旋系统

我们首先使用二维方形格晶上的反铁磁海森堡模型和 $J_{1}-J_{2}$ 模型对我们的方法进行基准测试。
这些模型可以写成如下形式：
\begin{equation}\label{eq:j1-j2}
H = J_{1} \sum_{\langle i, j\rangle} \mathbf{S}_{i} \cdot \mathbf{S}_{j} + J_{2} \sum_{\langle\langle i, j\rangle\rangle} \mathbf{S}_{i} \cdot \mathbf{S}_{j},
\end{equation}
其中 $\mathbf{S}_{i}$ 是位于 $i$ 位置的自旋-1/2算符， $\langle i, j\rangle$ 表示最近邻的格点对， $\langle\langle i, j\rangle\rangle$ 表示次近邻的格点对。

当 $J_{1} = 1$ 且 $J_{2} = 0$ 时，公式 [[eqref:eq:j1-j2]] 即退化为无阻挫的海森堡模型，因此可以通过量子蒙特卡罗（QMC）方法进行模拟而不会遇到符号问题，例如基于随机序列展开（SSE） [[cite:Sandvik1991,Sandvik1992]] 。
如图 [[ref:fig:thermal-heisenberg]] 所示，我们将得到的结果与SSE方法进行比较。
具体的模型和计算参数为，大小为 $N = 8 \times 8$ 的方形晶格，采用开放边界条件。
我们设定投影纠缠对态中的虚拟指标维度为 $D=8$ 。
我们使用边界MPS收缩算法 [[cite:Verstraete2008,Liu2021]] 来收缩单层张量网络， 其精度由截断维度 $D_c$ 控制，这里我们设定 $D_c =16$ 。
我们采用了传统的马尔可夫链方法对量子态的构型进行采样，总样本数量为 $40000$ 。
对于高温情况，我们使用 $p_s=\sqrt{\langle \psi | s | \psi \rangle}$ 的权重进行采样并进行重加权，直到 $\beta \simeq 0.3$ ，
这是因为对于非常高的温度， 未归一化的热态 $\rho(\beta)$ 接近恒等算子，其对角项接近于一，而非对角线项则接近于零。
而降低温度后，非对角项权重应当扩大，但是由于此时权重过小，难以采样到，所以难以采出其梯度，也就难以扩大其权重，导致高温附近降温比真实情况更慢。
然后使用正常采样方法直到较低温度 $\beta \simeq 10$ 。
为了与我们的结果进行比较，我们更改了SSE代码 [[cite:SSE-code]] 的边界条件。
在SSE方法中，我们使用的样本数为 $10^7$ 。

#+begin_export latex
\begin{figure}
\centering
\includegraphics[width=0.5\textwidth]{8x8-heisenberg.pdf}
\caption{海森堡模型的降温曲线}
\note{注：
二维反铁磁海森堡模型在 $8 \times 8$ 方格晶格上的表现：(a) 每格点能量，(b) 每格点比热，(c) 均匀磁化率 $\chi$ 随 $\beta = 1/T$ 的变化情况。
}
\label{fig:thermal-heisenberg}
\end{figure}
#+end_export

如图 [[ref:fig:thermal-heisenberg]] (a) 所示，我们的方法计算得到的每点内能在整个温度范围内（ $\beta = [0, 10]$ ）与SSE的结果一致，这说明我们的方法即使在非常低的温度下也具有出色的精度。
图 [[ref:fig:thermal-heisenberg]] (b) 显示了比热 $C_v$ 随 $\beta$ 的变化情况。
在此，我们通过数值微分获取 $C_v$。
具体来说，我们首先得到图 [[ref:fig:thermal-heisenberg]] (a) 数据的B样条曲线，然后可以从该曲线的导数中获取 $C_v$。
如图 [[ref:fig:thermal-heisenberg]] (b) 所示，我们的结果与SSE的结果基本一致。
尽管 $C_v$ 的峰值与SSE的结果存在一定的偏差，这主要是由于数值微分带来的误差，但相应的 $\beta$ 值与SSE的结果非常吻合。
获取 $C_v$ 的更精确方法是直接计算 $\beta^2 (\langle H^2 \rangle - \langle H \rangle^2)$ ，然而在低温处，由于 $\beta^2$ 会放大采样误差，为了得到同等质量的结果，直接计算效率比数值差分要低。
图 [[ref:fig:thermal-heisenberg]] (c) 展示了均匀磁化率随 $\beta$ 的变化情况，其定义为
\begin{equation}\label{eq:sus}
\chi=\frac{\beta}{N}\left (\left\langle M_{z}^{2}\right\rangle - \left\langle M_{z}\right\rangle^{2}\right ) , \quad M_{z}=\sum_{i=1}^{N} S_{i}^{z},
\end{equation}
这里，我们同SSE方法 [[cite:Sandvik2010]] 一样， 将 $\langle M_z \rangle^2$ 设置为0，因为哈密顿量中不包含磁场。
如图 [[ref:fig:thermal-heisenberg]] (c)所示，均匀磁化率在整个温度范围内与SSE方法的结果高度一致。
实际上，比起磁化强度，磁化率更难估计，因为随着温度下降，公式 [[eqref:eq:sus]] 中的 $\beta$ 增加，这要求对 $\langle M_z^2 \rangle$ 估计的精度有了更高的要求以达到固定的精度。
这也是低温区域内磁化率与精确结果略有偏差的原因，见图 图 [[ref:fig:thermal-heisenberg]] (c)和图 [[ref:fig:thermal-heisenberg]] (c)中 $\beta \approx 10$ 的部分。

当公式 [[eqref:eq:j1-j2]] 中的 $J_2$ 不为零时， $J_1-J_2$ 模型是一个阻挫系统，由于符号问题，不适合使用量子蒙特卡罗方法进行计算。
在零温度情况下，多个数值计算研究 [[cite:Liu2018,Liu2022,Jiang2012,Hu2013,Wang2018]] 显示，当 $J_2/J_1 = 0.5$ 时，$J_1-J_2$ 模型呈现出量子自旋液相。

我们在 $4 \times 4$ 方格晶格上计算了 $J_1-J_2$ 模型，设置 $J_2/J_1 = 0.5$，这允许通过严格对角化方法进行精确计算。
我们将张量网络虚拟指标的键维度设为 $D=8$，边界维度 $D_c=16$，样本数为 80000。
如图 [[ref:fig:thermal-j1j2]] (a)所示，每点的内能在整个温度范围内与严格对角化的结果高度一致。
图 [[ref:fig:thermal-j1j2]] (b)中的比热 $C_v$ 同样是通过B样条曲线法获得的，也与严格对角化结果一致。
图 [[ref:fig:thermal-j1j2]] (c)中显示的磁化率也很好地与ED结果相符。
因此，我们的方法也适用于有限温度下高度阻挫系统的模拟。

#+begin_export latex
\begin{figure}
\centering
\includegraphics[width=0.5\textwidth]{4x4-j1j2.pdf}
\caption{ $J_1-J_2$ 模型的降温曲线}
\note{注：
二维阻挫的 $J_1-J_2$ 模型在 $4 \times 4$ 方格晶格上的表现：(a) 每格点能量，(b) 每格点比热，(c) 均匀磁化率 $\chi$ 随 $\beta = 1/T$ 的变化情况。
}
\label{fig:thermal-j1j2}
\end{figure}
#+end_export

*** 费米子系统

我们也尝试将此有限温算法应用于方形晶格的费米子Hubbard模型，其哈密顿量为
\begin{equation}\label{eq:hubbard}
    H = -t \sum_{\langle i, j\rangle, \sigma} c_{i\sigma}^\dag c_{j\sigma} + U \sum_{i} n_{i\uparrow} n_{i\downarrow} - \mu \sum_{i\sigma} n_{i\sigma} ,
\end{equation}
其中， $c_{i\sigma}$ 是位于格点 $i$ 上自旋为 $\sigma = \uparrow$ 或 $\downarrow$ 的湮灭算符， $n_{i\sigma} = c_{i\sigma}^\dag c_{i\sigma}$ 是粒子数算符。
在公式 [[eqref:eq:hubbard]] 中，最近邻格点 $\langle i, j \rangle$ 之间的跃迁项幅度为 $t$ ，同一格点 $i$ 上占据两个相反自旋的粒子之间的排斥相互作用参数为 $U$，化学势为 $\mu$。

如第 [[ref:sec:超导]] 中提到过，Hubbard模型作为描述Mott绝缘体的基本工具，其在寻找超导现象，探究i超导机理的计算与分析中极为重要。
在本次测试中，我们使用 $6 \times 6$ 大小的开边界方形晶格， 参数取 $t=1$ ， $U=8$ 以及 $\mu=4$ ，这对应着半满的反铁磁相 [[cite:Zheng2016]] 。
需要注意的是，我们的方法也适用于正则系综，不过在此我们使用的是巨正则系综，以便与DQMC进行比较。
由于这是半满的Hubbard模型，因此对于行列式量子蒙特卡洛算法来说不存在符号问题。

在测试Hubbard模型中，我们发现Hubbard模型高温附近相比自旋系统更加难以及时降温。
为了解决这个问题，除了取 $p_s' = \sqrt{\langle \psi | s | \psi \rangle}$ 外，
我们还设置 $p_s = b_s p_s'$ ，其中 $b_s$ 是一个动态调整的值，使得对角项的 $p_s$ 不再远高于非对角项的 $p_s$ 。

如图 [[ref:fig:thermal-hubbard]] 所示，我们将Hubbard模型的结果与DQMC方法进行比较。
在优化过程中使用了高达30000次采样，在测量过程中使用了600000次采样。
可以看出，图  [[ref:fig:thermal-hubbard]] (a) 中每格点的能量 $E=\langle H \rangle / N$ 与行列式量子蒙特卡洛结果一致。
而图  [[ref:fig:thermal-hubbard]] (b) 中的 每格点的双占据 $D=\sum_i \langle n_{i\downarrow} n_{i\uparrow} \rangle / N$ 也和DQMC结果相符。
图  [[ref:fig:thermal-hubbard]] (c) 则展示了次近邻格点之间的自旋关联 $F=\sum_{\langle\langle i, j \rangle\rangle}\langle \mathbf{S}_i \cdot \mathbf{S}_j \rangle / M$ ，其同样和 行列式量子蒙特卡洛方法获得的结果一致，其中 $M$ 是次近邻格点对的数量。

#+begin_export latex
\begin{figure}
\centering
\includegraphics[width=0.5\textwidth]{6x6-hubbard.pdf}
\caption{ Hubbard模型的降温曲线 }
\note{注：
$6 \times 6$ 方形晶格上的费米子Hubbard模型的降温曲线，参数为 $U=8$，$t=1$ 和 $\mu=4$。(a) 每格点的能量 $E$ ，(b) 每格点的双占据 $D$ ，(c) 次近邻格点之间的自旋关联 $F$ 随着 $\beta = 1/T$ 的变化情况。
}
\label{fig:thermal-hubbard}
\end{figure}
#+end_export

如图  [[ref:fig:thermal-hubbard]] (a) 所示，随着温度的降低，能量逐渐下降。
在图  [[ref:fig:thermal-hubbard]] (b) 中可以看出，约在 $1/T = 0.5$ 附近，双占据从一个有限的值收敛到零。
随着温度的进一步降低，次近邻格点之间的自旋关联在图  [[ref:fig:thermal-hubbard]] (c) 中从零增加到一个有限的值，约发生在 $1/T = 3.0$ 附近。
由于系统尺寸较小，有限尺寸效应使我们无法观察到明显的相变。
值得一提的是，本测试结果与文献 [[cite:Li2023]] 中的结果基本一致，只是由于系统尺寸有差异，各个降温曲线不完全相同。

** 小结

我们开发了基于自然梯度法的有限温度PEPS变分方案，用于模拟二维量子多体系统的热态。
我们的方法中使用的张量网络态，特别是PEPS网络，在表示二维系统中具有可扩展性。
我们的方案继承了PEPS加变分法的多个优势，如可以实现大规模并行化。
此外，基准测试结果显示，我们的方法可以应用于量子自旋系统和费米子系统。
相比与直接的简单更新，我们的方法不仅精度更高其更容易控制，还可以直接用于模拟长程相互作用，例如里德伯原子系统。
我们未来还可以使用多个张量网络之和作为变分表示 [[cite:Dong2024]] 来模拟具有周期性边界条件的系统。

* 总结与展望 <<sec:总结与展望>>

TODO 总结展望

#+begin_export latex
\bibliography{main}
\appendix
#+end_export

#+begin_export latex
\backmatter
#+end_export

#+begin_export latex
\begin{acknowledgements}

哦霍，听说致谢不算字数，反正也没人看，正文敲得手酸，这里就不写了。

\end{acknowledgements}

\begin{publications}

\section*{已发表论文}

\begin{enumerate}
\item A A A A A A A A A
\end{enumerate}

\section*{待发表论文}

\begin{enumerate}
\item A A A A A A A A A
\end{enumerate}

\section*{研究报告}
\begin{enumerate}
\item A A A A A A A A A
\end{enumerate}

TODO publication

\end{publications}
#+end_export
