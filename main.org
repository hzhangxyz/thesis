#+LATEX_CLASS: thesis
#+TITLE: 费米子张量网络方法的发展及其在哈伯德模型中的应用
#+OPTIONS: title:nil
#+OPTIONS: toc:nil

#+LATEX: \newcommand{\red}[1]{{\color{red} #1}}

#+begin_src emacs-lisp :exports none :results none
  (add-to-list 'org-latex-classes
               '("thesis"
                 "\\documentclass{ustcthesis}\\input{ustcsetup.tex}
                  [NO-DEFAULT-PACKAGES]
                  [NO-PACKAGES]"
                 ("\\chapter{%s}" . "\\chapter*{%s}")
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
  (setq org-latex-pdf-process
        '("xelatex -interaction nonstopmode -output-directory %o %f"
          "bibtex %b"
          "xelatex -interaction nonstopmode -output-directory %o %f"
          "xelatex -interaction nonstopmode -output-directory %o %f"))
  (setq org-format-latex-options (plist-put org-format-latex-options :scale 4.0))
#+end_src

#+begin_export latex
\maketitle
\copyrightpage
\frontmatter
#+end_export

#+begin_export latex
\ustcsetup{
  keywords  = {张量网络态，强关联系统，量子多体问题，投影纠缠对态},
  keywords* = {Tensor network state, Strongly correlated systems, Quantum many-body problems, PEPS},
}
#+end_export

#+MACRO: ED 严格对角化
#+MACRO: MC 蒙特卡洛
#+MACRO: QMC 量子 {{{MC}}}
#+MACRO: Ansatz 拟设
#+MACRO: NQS 神经网络量子态
#+MACRO: TNS 张量网络态
#+MACRO: MPS 矩阵乘积态
#+MACRO: PEPS 投影纠缠对态
#+MACRO: iTEBD 逐块虚时间演化
#+MACRO: SU 简单更新
#+MACRO: DMRG 密度矩阵重整化
#+MACRO: SR 随机重构型
#+MACRO: SSE 随机级数展开
#+MACRO: DQMC 行列式 {{{QMC}}}
#+MACRO: SC 超导
#+MACRO: VMC 变分 {{{MC}}}
#+MACRO: CDW 电荷密度波
#+MACRO: AFM 反铁磁
#+MACRO: F 费米
#+MACRO: B 玻色
#+MACRO: AL 纠缠熵面积定律
#+MACRO: DS 直接采样
#+MACRO: NG 自然梯度
#+MACRO: Hilbert 希尔伯特
#+MACRO: T 张量
#+MACRO: TN 张量网络
#+MACRO: L6 六角晶格
#+MACRO: L4 方形晶格
#+MACRO: Hubbard 哈伯德
#+MACRO: Hamiltonian 哈密顿量
#+MACRO: Rydberg 里德伯
#+MACRO: Metropolis 梅特罗波利斯
#+MACRO: MERA 多尺度纠缠重整化 {{{Ansatz}}}
#+MACRO: Cooper 库珀
#+MACRO: Grassmann 格拉斯曼
#+MACRO: TNSP 张量网络态计算套件

#+begin_export latex
\begin{abstract}
#+end_export
上世纪发展起来的朗道费米液体理论和基于自发对称性破缺的相变理论在研究许多凝聚态问题上取得了巨大的成功。
然而，这些理论在强关联系统中失效，因为在这类系统中，粒子间存在强的关联相互作用，导致传统的微扰理论无法得到准确的结果。
因此，研究强关联系统的性质主要依赖于数值方法。近年来，随着计算技术和算法的进步，针对强关联系统的数值方法成为了备受关注的研究领域。

强关联系统数值求解的根本困难在于其希尔伯特空间维度随着系统尺寸的增大呈指数增长。
因此，传统的严格对角化方法（ED）仅能处理30多个格点左右的有限系统。
在某些特殊的强关联系统中，量子蒙特卡洛方法（QMC）可以得到优异的结果，但在具有阻挫相互作用和费米子系统中，会遇到所谓的 ``符号问题''。
为确保模拟结果的收敛，所需的采样量必须呈指数增加，极大地限制了QMC方法在这些系统中的适用性。
另一大类数值方法依赖于使用拟设（Ansatz）函数来表示系统的波函数。
由于强关联系统中的波函数往往包含大量的量子纠缠和复杂的多体关联，如何在有限的参数量下准确描述庞大的希尔伯特空间中的相关向量成为这类数值方法的核心问题。

近年来，张量网络态（TNS）在强关联系统的研究中取得了显著进展。
矩阵乘积态（MPS）已成功应用于一维系统，而投影纠缠对态（PEPS）则被推广到二维系统。
尽管张量网络态方法在许多应用中表现优异，但在处理复杂相互作用时仍面临挑战。
此外，张量网络态方法已被成功扩展到费米子系统，并催生了多种费米子张量网络态（f-TNS）方法。
由于费米子具有交换反对易性，f-TNS 的实现比玻色子系统更加复杂。
因此，尽管 f-TNS 在理论上提供了处理费米子系统的强大工具，但其实际应用面临巨大挑战。
特别是，由于缺乏专门支持费米子张量网络态的基础软件包，这进一步限制了f-TNS在实际计算中的推广和应用。

为了解决这些挑战，尤其是发展对称性张量网络态和费米子张量网络态方法中遇到的问题，本论文开展了以下几项工作：

一、为简化对称性张量网络态和费米子张量网络态的编程实现，我们提出并实现了一种新方案。
通过直接定义网络中张量的运算规则，成功地保持了张量运算中的对称性和费米子的反对易性质。
这一改进使得在网络层次可以忽略对称性张量网络和费米子张量网络的复杂细节，简化了对对称性和费米子性质的处理，显著降低了编程的复杂性，并提升了实现效率和可扩展性。
基于这一方法，我们开发了一个支持对称性和费米子张量的张量网络态方法框架：TNSP。
我们设计了一个统一的接口，能够一致性地处理玻色子、费米子及多种对称类型的张量，同时保持软件包的用户友好性和多功能性。
这个张量网络态计算套件TNSP包含两个主要组成部分：1. TAT（底层张量库）：支持不同类型张量的复杂运算。
2. tetragono（高级接口库）：基于 TAT 构建，专为简化在方形晶格上开发复杂物理模型算法而设计。
该框架使研究人员能够更加轻松地研究各种物理模型，无需深入关注底层实现细节。
这极大简化了基于张量网络态的程序开发，尤其是涉及对称性或费米子张量网络态的应用。

二、我们利用费米子投影纠缠对态 (f-PEPS) 方法研究了在六角晶格上空穴掺杂的哈伯德模型。
研究发现，在这个模型中库珀对存在准长程序，其关联函数呈现幂律衰减，衰减指数 $K > 1$。
我们进一步分析了超导性与其他竞争序之间的关系，包括反铁磁 (AFM) 序和电荷密度波 (CDW) 序。
结果显示，当空穴掺杂 $\delta$ 较小且库仑参数 $U$ 较大时，系统中存在畴壁结构。
随着空穴掺杂 $\delta$ 的增加或 $U$ 的减少，这些畴壁结构会消失。
当空穴掺杂较小时，系统表 现出反铁磁序，但在 $\delta > 0.05$ 时该序减弱至消失。
而随着掺杂水平的增加，电荷密度波序也逐渐减弱。
值得注意的是，即使在较高的掺杂水平下，仍然可以观察到显著的电荷密度波序。
这些结果表明，随着掺杂水平 $\delta$ 的增加，反铁磁序逐渐受到抑制，而电荷密度波序则逐渐占据主导地位。

三、我们提出了一种可扩展的二维量子多体系统的有限温度张量网络态算法。
该算法使用（费米子）投影纠缠对态来表示矢量化的量子热态，并通过随机重构型方法（SR）逐步将量子态从无穷温度冷却。
为验证算法的有效性，我们对二维反铁磁海森堡模型、 $J_1-J_2$ 模型和费米哈伯德模型进行了测试。
我们将计算所得的物理性质如内能、比热和磁化率等与随机级数展开（SSE）、严格对角化和行列式量子蒙特卡洛（DQMC）方法的结果进行了对比，显示出高度一致性，验证了该算法的准确性和可靠性。

综上所述，本论文发展了一个支持对称性和费米子张量的张量网络态方法框架 TNSP，能够统一处理玻色子、费米子及多种对称类型的张量网络态，显著简化了算法开发的复杂性。
在此基础上，我们利用费米子投影纠缠对态方法研究了六角晶格上空穴掺杂的哈伯德模型。
研究结果表明，该模型中库珀对存在准长程序，并且存在相互竞争的反铁磁及电荷密度波序。
最后，我们提出了一种可扩展的二维量子多体系统的有限温度张量网络态算法，为研究有限温度下的强关联系统提供了有力的工具和基础。
#+begin_export latex
\end{abstract}
#+end_export

#+begin_export latex
\begin{abstract*}
#+end_export
The Landau-Fermi liquid theory and the phase transition theory based on spontaneous symmetry breaking, developed in the last century, have achieved great success in studying many condensed matter problems.
However, these theories fail in strongly correlated systems due to the strong interaction between particles in such systems, which causes traditional perturbation theories to yield inaccurate results.
Therefore, the study of strongly correlated systems primarily relies on numerical methods.
In recent years, with advances in computational technology and algorithms, numerical methods for strongly correlated systems have become a highly focused research area.

The fundamental difficulty in numerically solving strongly correlated systems lies in the exponential growth of the Hilbert space dimension with increasing system size.
As a result, traditional exact diagonalization (ED) methods can only handle finite systems with around 30 or so lattice sites.
In some special strongly correlated systems, quantum Monte Carlo (QMC) methods can provide excellent results, but in systems with frustrated interactions and fermionic systems, they encounter the so-called ``sign problem''.
To ensure the convergence of simulation results, the required sampling must increase exponentially, greatly limiting the applicability of QMC methods in these systems.

Another major class of numerical methods relies on using ansatz functions to represent the system's wave function.
Because the wave functions in strongly correlated systems often contain significant quantum entanglement and complex many-body correlations,
accurately describing the relevant vectors in the vast Hilbert space with a finite number of parameters becomes the core issue of these methods.

In recent years, tensor network states (TNS) have made significant progress in the study of strongly correlated systems.
Matrix product states (MPS) have been successfully applied to one-dimensional systems, while projected entangled pair states (PEPS) have been extended to two-dimensional systems.
Although tensor network state methods perform excellently in many applications, they still face challenges when dealing with complex interactions.
Additionally, tensor network methods have been successfully extended to fermionic systems, leading to various fermionic tensor network state (f-TNS) methods.
Since fermions obey anticommutation relations, implementing f-TNS is more complex than in bosonic systems.
Therefore, despite theoretically providing powerful tools for handling fermionic systems, practical applications of f-TNS face significant challenges.
Particularly, the lack of specialized software packages supporting fermionic tensor network states further limits the promotion and application of f-TNS in practical computations.

To address these challenges, especially those encountered in developing symmetry tensor network states and fermionic tensor network states, this thesis undertakes the following work:

1. To simplify the programming implementation of symmetry tensor network states and fermionic tensor network states, we propose and implement a new scheme.
   By directly defining the operation rules for tensors in the network, we effectively preserve both the symmetry of tensors and the anticommutation properties of fermions.
   This improvement allows ignoring the complex details of symmetry tensor networks and fermionic tensor networks at the network level, simplifying the handling of symmetry and fermionic properties,
   significantly reducing programming complexity, and improving implementation efficiency and scalability.
   Based on this method, we have developed a tensor network state method framework that supports symmetry and fermionic tensors: TNSP.
   We designed a unified interface capable of consistently handling bosonic, fermionic, and various symmetry tensor types while maintaining user-friendliness and multifunctionality.
   This tensor network state computational suite, TNSP, includes two main components:
   (1) TAT (Basic tensor library): Supports complex operations for different types of tensors.
   (2) tetragono (Advanced interface library): Built on TAT, specifically designed to simplify the development of complex physical model algorithms on square lattices.
   This framework enables researchers to more easily study various physical models without delving into the underlying implementation details.
   It greatly simplifies the development of tensor network state-based programs, especially for applications involving symmetry or fermionic tensor network states.

2. We utilized the fermionic projected entangled pair states (f-PEPS) method to study the Hubbard model with hole doping on a hexagonal lattice.
   Our study found that in this model, Cooper pairs exhibit quasi-long-range order with their correlation function showing a power-law decay with an exponent $K>1$.
   We further analyzed the relationship between superconductivity and other competing orders, including antiferromagnetic (AFM) order and charge density wave (CDW) order.
   Results show that when hole doping $\delta$ is small and the Coulomb parameter $U$ is large, domain wall structures exist in the system.
   As hole doping $\delta$ increases or $U$ decreases, these domain wall structures disappear.
   When hole doping is small, the system exhibits antiferromagnetic order, but this order weakens and vanishes for $\delta>0.05$.
   As doping levels increase, the charge density wave order also gradually weakens.
   Notably, significant charge density wave order can still be observed at higher doping levels.
   These results indicate that with increasing doping level $\delta$, antiferromagnetic order is gradually suppressed while charge density wave order becomes dominant.

3. We propose a scalable finite-temperature tensor network state algorithm for two-dimensional quantum many-body systems.
   This algorithm uses (fermionic) projected entangled pair states to represent vectorized quantum thermal states and gradually cools the quantum states from infinite temperature using a stochastic reconfiguration method (SR).
   To validate the algorithm's effectiveness, we tested it on the two-dimensional antiferromagnetic Heisenberg model, the $J_1-J_2$ model, and the fermionic Hubbard model.
   We compared the measured physical properties such as internal energy, specific heat, and magnetic susceptibility with results from stochastic series expansion (SSE), exact diagonalization, and determinant quantum Monte Carlo (DQMC) methods,
   showing high consistency and validating the algorithm's accuracy and reliability.

In summary, this thesis develops a tensor network state method framework, TNSP, supporting symmetry and fermionic tensors, which can uniformly handle bosonic, fermionic, and various symmetry tensor network states,
significantly simplifying the complexity of algorithm development.
Building on this framework, we used the fermionic projected entangled pair states method to study the Hubbard model with hole doping on a hexagonal lattice.
The study reveals that the model exhibits quasi-long-range order in Cooper pairs and competing antiferromagnetic and charge density wave orders.
Finally, we propose a scalable finite-temperature tensor network state algorithm for two-dimensional quantum many-body systems, providing a powerful tool and foundation for studying strongly correlated systems at finite temperatures.
#+begin_export latex
\end{abstract*}
#+end_export

#+begin_export latex
\tableofcontents
\listoffigures
\listoftables
#+end_export

#+begin_export latex
\newenvironment{ustcnotation}{\begin{notation}\begin{notationlist}{2em}}{\end{notationlist}\end{notation}}
#+end_export

#+attr_latex: :environment ustcnotation
- ED :: {{{ED}}} (Exact Diagonalization)
- MC :: {{{MC}}} (Monte Carlo)
- QMC :: {{{QMC}}} (Quantum Monte Carlo)
- Ansatz :: {{{Ansatz}}} (Ansatz)
- NQS :: {{{NQS}}} (Neural Quantum States)
- TNS :: {{{TNS}}} (Tensor Network States)
- MPS :: {{{MPS}}} (Matrix Product States)
- PEPS :: {{{PEPS}}} (Projected Entangled Pair States)
- VMC :: {{{VMC}}} (Variational Monte Carlo)
- iTEBD :: {{{iTEBD}}} (Imaginary Time-evolving Block Decimation)
- SU :: {{{SU}}} (Simple Update)
- DMRG :: {{{DMRG}}} (Density Matrix Renormalization Group)
- SR :: {{{SR}}} (Stochastic Reconfiguration)
- SSE :: {{{SSE}}} (Stochastic Series Expansion)
- DQMC :: {{{DQMC}}} (Determinant Quantum Monte Carlo)
- SC :: {{{SC}}} (Superconductivity)
- CDW :: {{{CDW}}} (Charge Density Wave)
- AFM :: {{{AFM}}} (Antiferromagnetic)
- MERA :: {{{MERA}}} (Multiscale Entanglement Renormalization Ansatz)
- TNSP :: {{{TNSP}}} (Tensor Network State Packages)

#+begin_export latex
\mainmatter
#+end_export

* 绪论 <<sec:绪论>>

自上世纪以来，多体系统一直是物理学研究中的一个重要课题 [[cite:Blanchet2001,Chenciner2007,Diacu1996,Trenti2008]]。
在量子力学中，由于哈密顿量中不同算符之间的不可对易性，量子多体问题表现得更加复杂 [[cite:Hochstuhl2014,Thouless1972-pf,Fetter2003-sp,Nozieres1997-cw,Mattuck1975-pe]] 。
尽管路径积分表明，量子多体问题可以类比于高一维的经典多体问题 [[cite:Brown2005,Feynman2010-xh]] ，具体问题的复杂性依然使得系统难以求解。
量子多体问题的主要困难在于希尔伯特空间的张量积结构。
相比于经典系统，若需要 $1$ 个比特来描述一个经典物体，其表示空间为 $V = 2$ ；
当描述 $n$ 个物体时，表示空间为各个物体表示空间的直积 $V=2 \otimes 2 \otimes \cdots \otimes 2 = 2^n$ ，即整体需要 $n$ 个比特来描述。
然而，在量子多体系统中，由于存在叠加态，描述单个量子比特的希尔伯特空间为 $H = \mathbb{C}^{2}$，而 $n$ 个量子比特的总表示空间为各子系统空间的张量积，因此需要 $2^{n}$ 个 $\mathbb{C}$ 来描述，即 $H = \mathbb{C}^{2^{n}}$。
这种量子系统中表示空间维度的指数增长，而不是经典系统中表示空间本身大小的指数增长，是量子多体问题复杂性的核心所在。

#+LATEX: {\color{blue}ZH: 修改了这一段的表述方式，经典多体是空间大小指数增长，量子多体是空间维度指数增长。}

理论物理学的一个核心目标是找到复杂系统的配分函数或波函数的有效表示 [[cite:Sandvik2007,Carleo2017,Liang2021,Adams2021,Acevedo2020,Drummond2005]]，以便简化处理具有指数级自由度的多体问题。
通过这样的表示，可以更有效地计算系统的物理量，比如能量和磁化率等。
量子微扰理论是实现这一目标的重要方法之一 [[cite:Schwartz2013,Talagrand2022,Simon1982,Sulejmanpasic2018,Dick2020]] 。
在该方法中，系统的哈密顿量被分解为自由部分 $H_f$ 和相互作用部分 $H_i$，即 $H = H_f + H_i$。
首先解决无相互作用的自由系统 $H_f$，这时的多体系统可以简单地表示为子空间解的张量积，随后再引入相互作用 $H_i$ 作为微扰，获得含有相互作用的系统的结果。
这种方法对于弱相互作用系统效果良好，但在相互作用起到关键作用时，例如系统经过由相互作用驱动的相变时，可能会失效。
为了解决这个问题，Wilson 在1975年引入了重整化群 [[cite:Wilson1975]] 方法：
首先对系统的有效场论作出一个猜测，然后通过积分掉高能的自由度，将重整化群流引入作用量或哈密顿量的空间 [[cite:Peskin2019-ut,ZinnJustin2002,Goldenfeld2018]]。
在有能隙的系统中，重整化的过程会落入由拓扑量子场论描述的固定点。
当应用于无能隙的临界系统时，重整化群能够预测诸如相变时可能的临界指数等普适信息。
然而，重整化群并不适合对给定的微观哈密顿量作出定量求解，并且在强关联区域表现不佳，因为被积分掉的高能部分在此处可能并不平凡。
为了避开这些问题，人们设计了各种各样的计算方法。

在这些计算方法中，严格对角化方法可以在系统较小时得到精确的结果。
然而，由于参数数量随系统大小呈指数增长，严格对角化的计算无法扩展到足以得到合理物理结果的规模，这一困难被称为``指数墙'' [[cite:Ayral2023]]。
为了克服这一问题，量子多体问题的求解中发展出了一类可扩展的方法，即所谓的量子蒙特卡洛方法 [[cite:Austin2011,Lchow2011,Santos2003]]。
由于波函数或配分函数的分量权重分布通常具有一定的特征，我们可以通过快速收敛的蒙特卡洛方法对这些观测量进行采样计算。
这类采样方法通常使用基于马尔可夫链的 {{{Metropolis}}} 算法（Metropolis Algorithm） [[cite:Minh2014,Berg2004]] 来实现。
然而，许多我们感兴趣的物理系统具有阻挫相互作用或属于费米系统。
对于这些系统，直接进行蒙特卡洛采样时会遇到所谓的``符号问题''，导致观测量的收敛需要指数级增长的采样量 [[cite:Troyer2005,Hangleiter2020,Hen2021,Honecker2022]] 。
为此解决符号问题，人们提出了 {{{VMC}}} 方法 [[cite:Sandvik2007,Umrigar2005,Sorella2005,Carleo2017,Liang2021,Drummond2005]] ：
该方法通过在指数维的希尔伯特空间中构建一个{{{Ansatz}}}函数 (Ansatz)，并利用 {{{MC}}} 方法计算感兴趣的观测量。
拟设函数通常结合了某些先验的物理知识，使得目标态能够位于拟设函数所能表示的子流形中。

最简单的波函数 {{{Ansatz}}} 由Slater行列式给出，即 Hartree-Fock 理论 [[cite:Echenique2007,Clark2013-mf]]，其{{{Ansatz}}}波函数形式为
$\psi^{HF}=\frac{1}{\sqrt{N!}} \mathrm{det}M$ ， 其中 $N$ 为系统中的粒子数目， $M$ 为 $N \times N$ 的矩阵 $M_{ij}=\phi_j(x_i)$ 。
这种 {{{Ansatz}}} 对于弱相互作用的系统较为有效。
Slater 行列式拟设本质上是一种平均场理论 [[cite:Chaikin2000-nq,Boudec2007-xj,Stanley1987-va]]，它完全忽略了粒子之间的关联效应，假设每个粒子都处于由其他粒子组成的平均场中。
由于忽略了关联效应，Hartree-Fock 方法通常只能得到定性的结果，尤其是在量子涨落较为显著的低维系统中，该方法往往失效。

张量网络态 [[cite:Vidal2003,Verstraete2004,Vidal2004,Vidal2007,Jiang2008,Sandvik2007,Liu2017,Vieijra2021]] 是一种新新兴的拟设方法，通过不同格点之间的张量乘积来表示波函数，从而模拟强相互作用系统的基态。
该拟设能够很好地描述许多量子系统的纠缠结构，基态波函数通常处于低纠缠区域，因此各种系统的基态往往位于张量网络态的子流形中。
具体来说，张量网络态表示的波函数可以满足纠缠熵的面积定律 [[cite:Eisert2010,Arad2013,Arad2017,Napp2022,Hastings2006,Brando2014,Hastings2015,Anshu2022,Abrahamsen2020]]，而许多量子系统的基态确实遵循这一定律。
张量网络态 的发展历经数十年，取得了巨大成功。如今回首，正应了Feynman的那句话: ``
I think it should be possible some day to describe field theory
in some other way than with the wave functions and
amplitudes. It might be something like the density
matrices where you concentrate on quantities in a
given locality and in order to start to talk about it
you don’t immediately have to talk about what’s
going on everywhere else''  。

张量网络态（或张量乘积态）方法在计算物理中的发展可以追溯到 1992 年， White 提出了用于模拟一维量子自旋链的  {{{DMRG}}} 方法（Density Matrix Renormalization Group, DMRG）[[cite:White1992]]。
{{{DMRG}}} 在一维自旋链系统的基态求解中能够达到极高的精度，至今仍然是一维自旋链系统的标准求解方法 [[cite:Nakatani2018]]。
十年后，Vidal 于 2003 年设计了现代版本的矩阵乘积态（Matrix Product State, MPS）[[cite:Vidal2003]] 及其优化算法。
随后，人们认识到矩阵乘积态实际上是{{{DMRG}}}的一种等价表述。
进一步研究表明矩阵乘积态与纠缠熵面积定律有着紧密的联系 [[cite:Verstraete2006]]， 并揭示了局部有能隙哈密顿量的基态通常满足纠缠熵面积定律的事实 [[cite:Hastings2007]]，从而为 密度矩阵重整化群 方法在一维系统中的成功提供了理论解释。

在理论物理中，1987年提出的 AKLT 态是最著名的张量网络态之一 [[cite:Affleck1987,Affleck1988]]，它描述了一个一维自旋为 $1$ 的链。
在构造时，AKLT 态首先在每两个格点之间生成了一个自旋 $1/2$ 的单重态，
$|M\rangle = \frac{1}{\sqrt{2}} (|\uparrow\downarrow\rangle - |\downarrow\uparrow\rangle)$，
随后每个格点将两侧的自旋 $1/2$ 粒子投影至自旋 $1$ 的空间，
$P = |+1\rangle\langle\uparrow\uparrow| + |0\rangle\frac{\langle\uparrow\downarrow| + \langle\downarrow\uparrow|}{2} + |-1\rangle\langle\downarrow\downarrow|$。
后来，人们认识到 AKLT 态是一类更大的态中的一个，即有限相关态 (Finitely Correlated States, FCS) [[cite:Fannes1989]]，而有限相关态则是一类特殊的矩阵乘积态。

矩阵乘积态在一维系统中的成功让人们尝试将其推广至二维系统 [[cite:Verstraete2004]]。
这种张量网络态被称为投影纠缠对态（Projected Entangled Pair States, PEPS）。
与一维系统中的矩阵乘积态类似，投影纠缠对态能够自然地展现二维系统中的纠缠熵面积定律。
事实上，早在 1988 年，二维系统中的 AKLT 态作为一种特殊的投影纠缠对态已经被研究过 [[cite:Affleck1988]] ；
此外，满足杨-Baxter 方程的投影纠缠对态也在 1997 年被讨论过 [[cite:Niggemann1997]] 。
随着对投影纠缠对态的深入研究，许多有趣的波函数被发现可以表示为投影纠缠对态，如 Anderson 的共振价键（Resonating Valence Bond, RVB）态、Kitaev 的 toric code 态，以及任何局部无阻挫的可交换量子哈密顿量的基态 [[cite:Verstraete2006b]]，等。
与此同时，Vidal 提出了 多尺度纠缠重整化 拟设 (MERA) [[cite:Vidal2007b]] ，并发展了树形张量网络。
与 {{{MPS}}}不同， {{{MERA}}} 用于描述尺度不变的波函数，并且可以表示超越{{{AL}}}的临界点波函数。

本论文主要关注投影纠缠对态 [[cite:Verstraete2004,Verstraete2004b]] 的数值计算方法。
投影纠缠对态满足纠缠熵面积定律，理论上能够在维度指数增长的希尔伯特空间中构建一个子流形，精确地描述系统的基态。
然而，由于其计算复杂度依然极高，这种方法在实际应用中仍然面临巨大的挑战。
例如，在进行张量网络缩并时，缺乏高效且高精度的算法，而这种计算复杂性正是源于投影纠缠对态的优势：其网络结构。
因此，各种收缩张量网络的算法被提出，以平衡收缩二维张量网络时的精度与计算速度。
目前，主流的二维张量网络收缩算法主要分为三大类：角传递矩阵方法，张量重整化方法 和边界 MPS/MPO 方法。

角传递矩阵方法可追溯至1978 年 Baxter的工作 [[cite:Baxter1978]] ，并于1996 年被正式提出[[cite:Nishino1996]] 。
这类方法通常用于无穷大的 {{{PEPS}}} ，这种 {{{PEPS}}} 中的张量构成了周期性的晶胞。
其基本思路是在任意格点的四周放置八个待优化的变分张量，即四个角传递张量和四个行列张量，
随后通过向中间收缩完成迭代并最终得到某个张量收敛的四周环境， 如图 [[ref:fig:ctmrg]] 所示 [[cite:Ors2009]] 。

#+begin_export latex
\begin{figure}
\centering
\input{tikz/ctmrg.tikz}
%\caption{张量收缩的角传递矩阵方法}
%\note{注：张量收缩的角传递矩阵方法，以左上角的迭代收敛为例子。
\caption{张量收缩的角传递矩阵方法，以左上角的迭代收敛为例子。
(a) 无穷大系统的张量会通常表示为周期性的晶胞，这里以 $1 \times 1$ 的晶胞为例，使用紫色表示。
左侧的列张量使用黄色表示，上侧的行张量使用蓝色表示，左上角的角传递张量使用红色表示。
(b) 迭代一次后，蓝色框中的两个张量被更新为新的上侧行张量，黄色框中的两个张量被更新为新的左侧列张量，红色框中的四个张量被更新为新的角传递张量。
}
\label{fig:ctmrg}
\end{figure}
#+end_export

张量重整化方法通过将一个张量进行奇异值分解得到两个张量，再将四个张量收缩得到一个张量实现重整化操作 [[cite:Levin2007,Xie2009,Xie2012]]。
近年来，此方法有多种变种，比如张量网络重整化方法 [[cite:Evenbly2015]] 和 圈张量网络重整化 [[cite:Yang2017]] 等。

在边界 MPS/MPO 方法中 [[cite:Liu2017,Murg2007,Verstraete2008,Liu2021]] ，
通过在边界上使用一个 MPS 来近似 MPS 和矩阵乘积算子 (MPO) 的乘积，
逐步将整个二维投影纠缠对态近似收缩为一个 MPS 链，如图 [[ref:fig:b-mps-mpo]] 所示。
这种方法适用于有限大系统，并且由于近似次数为网络的边长，误差累计效应以及计算精度能够较好地控制。
该方法的基本操作通常通过迭代方程或奇异值分解来实现。
本论文中主要采用此方法完成二维张量网络的缩并。

#+LATEX: {\color{blue}ZH: 对于边长为 $L$ 的二维系统，TRG近似次数为 $O(L^2 \mathrm{log}(L))$ 的，而bMPS/MPO方法近似次数为 O(L) 。}

#+begin_export latex
\begin{figure}
\centering
\input{tikz/bmpsmpo.tikz}
%\caption{张量收缩的边界MPS/MPO方法}
%\note{注：张量收缩的边界MPS/MPO方法，适用于有限大的 投影纠缠对态。
\caption{张量收缩的边界MPS/MPO方法，适用于有限大的 投影纠缠对态。
其基本操作是将两行张量网络近似为一行，具体的近似手段可选奇异值分解或者迭代方程近似。
(a) 边界上的两行张量网络；(b) 近似后的一行张量网络。
}
\label{fig:b-mps-mpo}
\end{figure}
#+end_export

尽管投影纠缠对态（PEPS）算法在过去十年中取得了显著进展，但仍有一些具有挑战性的问题亟待解决。
例如，通过虚时间演化的简单更新方法 [[cite:Jiang2008]] 可以高效地得到基态投影纠缠对态的近似结果，但在计算观测量时，由于需要对双层网络进行缩并，其计算复杂度依然很高 。
此外，投影纠缠对态最早被应用于自旋模型和玻色子系统，而当应用于费米子系统时，由于费米子算符具有反对易性质，网络在进行缩并时会因缩并次序的不同产生额外的符号，这使得费米子网络的算法比玻色子网络更加复杂
[[cite:Corboz2010,Corboz2011,Gu2010,Gu2013,Kraus2010]]。
由于费米子本身性质的复杂性，编写费米子张量网络态的程序变得相当困难。
为减少费米子张量的编程负担，降低算法设计的复杂性，适用于费米子张量网络的软件基础设施显得至关重要，但目前尚未有成熟的库可以满足这一需求。
另一方面，投影纠缠对态目前主要适用于计算基态性质，对于有着丰富物理现象的有限温度系统，该方法尚无法有效处理。

为应对这些极具挑战性的问题，本研究组发展了一系列变分优化张量网络的方法，并通过蒙特卡洛采样的方法，将双层网络的缩并转换为单层网络的缩并，大幅降低了计算复杂度[[cite:Liu2017]]。
为克服费米子反对易性质带来的复杂性，我们设计了一套费米子张量网络方案 ，利用``费米箭头'' [[cite:Dong2019]] 确定纠缠对之间的相对次序，并定义费米算符在网络操作中的规则。
我们将这些底层规则封装，使得上层算法设计无需考虑费米子的特殊性质，实现在设计时与底层费米子属性的解耦合。
我们在董少钧等人发展的张量网络态软件包TNSPackage [[cite:Dong2018]] 上做了重大的改进和升级，推出了张量网络态计算套件。
该套件通过多层次封装实现了张量网络态程序开发中常用功能的模块化设计，并为不同类型的张量提供了统一的接口，显著简化了网络层次算法设计过程中的复杂性，尤其是与费米子张量方案的结合，使得算法开发更加便捷。
此外，我们还发展了一个可扩展的二维量子多体系统有限温度的张量网络态算法，实现了有限温度下量子多体系统的高效模拟。这一突破性算法为研究有限温度系统中的丰富物理现象提供了新的工具。

本论文介绍了我在博士期间关于张量网络方法的发展与应用的主要工作，包括张量网络态计算套件的开发以及在费米哈伯德模型中的应用。
论文提出了一个支持对称性和费米子张量的框架 TNSP，能够统一处理玻色子、费米子及多种对称性，简化了算法开发。
在此基础上，我们利用费米子投影纠缠态方法研究了六角晶格上的掺杂哈伯德模型，发现库珀对具有准长程序，且存在反铁磁序和电荷密度波序的竞争。
此外，论文还提出了一种可扩展的二维量子多体系统有限温度张量网络态算法，为研究有限温度下的强关联系统提供了新工具。论文的结构安排如下：
+ 第 [[ref:sec:绪论]] 章为绪论，即本章。
+ 第 [[ref:sec:张量和张量网络]] 章详细介绍 {{{T}}} 和 {{{TN}}} 的基础理论。
+ 第 [[ref:sec:张量网络态算法]] 章介绍多种基于 {{{TNS}}} 的算法。
+ 第 [[ref:sec:神威优化]] 章介绍在国产神威系统上对 {{{TNS}}} 的程序优化工作。
+ 第 [[ref:sec:软件]] 章介绍 {{{TNS}}} 计算套件的设计和开发。
+ 第 [[ref:sec:超导]] 章介绍在 {{{L6}}} 上的 {{{Hubbard}}} 模型基态中寻找 {{{SC}}} (SC) 相的工作。
+ 第 [[ref:sec:有限温]] 章介绍一种有限温度张量网络态算法以及其测试结果。
+ 第 [[ref:sec:总结与展望]] 章进行总结与展望。

* {{{T}}} 和 {{{TN}}} <<sec:张量和张量网络>>

** {{{MPS}}} (MPS)

*** {{{MPS}}} 的形式

数值模拟量子多体问题的根本困难在于系统的{{{Hilbert}}}空间的维度随着系统尺寸的增大指数上升[[cite:Ayral2023]]。
比如对于自旋系统，由 $N$ 个自旋 $\frac{1}{2}$ 的格点构成的晶格系统的 {{{Hilbert}}} 空间维度高达 $2^N$ ，为了表示这个系统的状态，需要 $2^N$ 维的向量作为波函数。
所以不做任何近似的严格表示这个波函数，并精确求解系统的本征态，只适用于很小的系统。
而White在1992年提出了{{{DMRG}}}(DMRG)方法 [[cite:White1992,White1993]] 成功地求解了各种一维模型的低能态性质。
后来Vidal提出 {{{MPS}}} (MPS) [[cite:Vidal2003]] ，人们认识到{{{DMRG}}}方法可以被认为是对 {{{MPS}}} {{{Ansatz}}}的波函数进行优化的过程。

{{{T}}} 的定义有很多种 [[cite:Dimitrienko2002-oy,Jeevanjee2009-oh,Lawden2003-mh,Bowen1976-hd]]， $R$ 阶的张量 可以被简单地认为是多个线性空间上的 $R$ 阶多线性映射[[cite:Lang2002-cr]]：
\begin{equation}
\hat T : V_0 \otimes V_1 \otimes V_2 \cdots V_{R-1} \to \mathbb{K} ,
\end{equation}
本论文将一直从 $0$ 开始计数而不是从 $1$ 开始计数。
其中 $V_r$ 是 $\mathbb{K}$ 上的线性空间， $r=0,1,2,\cdots R-1$ , 记 $\mathrm{rank}(\hat T) = R$ 。
而本论文中， $\mathbb{K}$ 只会取 $\mathbb{R}$ 或者 $\mathbb{C}$ ， $V_r$ 也一定是定义了内积的有限维线性空间，
所以可以使用一个高维数组来表示一个张量，即
\begin{equation}
\hat T (
\sum_{i_0=0}^{D_0-1} a_0^{i_0} e_0^{i_0},
\sum_{i_1=0}^{D_1-1} a_1^{i_1} e_1^{i_1},
\cdots
\def\rrr{{R-1}}
\sum_{i_\rrr=0}^{D_{R-1}-1} a_\rrr^{i_\rrr} e_\rrr^{i_\rrr}
)
=
T^{i_0,i_1,\cdots,i_\rrr} a_0^{i_0} a_1^{i_1} \cdots a_\rrr^{i_\rrr},
\end{equation}
其中 $D_r = \mathrm{dim}(V_r)$ ， 记 $\mathrm{rank}(T) = R$ ，本论文中将一直使用爱因斯坦求和约定。
为了表达上的简便，我们直接称呼 $T$ 为张量， 即使严格的说张量应是其所表示的 $\hat T$ 。

{{{MPS}}} [[cite:Vidal2003]] 使用一个张量链 [[cite:Oseledets2011,NezFernndez2022]] 来表示高维的向量。
以自旋 $\frac{1}{2}$ 系统为例子，一个长度为 $L$ 的自旋系统波函数
\begin{equation}\label{eq:一维系统波函数}
|\Psi\rangle = T^{\sigma_0,\sigma_1,\cdots,\sigma_{L-1}} |\sigma_0 \sigma_1 \cdots \sigma_{L-1}\rangle ,
\end{equation}
可以被使用 {{{MPS}}} 作为 {{{Ansatz}}} 来表示：
\begin{equation}\label{eq:一维系统波函数的MPS展开}
T^{\sigma_0,\sigma_1,\cdots,\sigma_{L-1}} =
(A_0 ^ {\sigma_0})_{v_1}
(A_1 ^ {\sigma_1})_{v_1 v_2}
(A_2 ^ {\sigma_2})_{v_2 v_3}
\cdots (A_{L-1} ^ {\sigma_{L-1}})_{v_{L-1}} ,
\end{equation}
其中 $\sigma_i$ 为第 $i$ 个格点处的自旋，可以取 $\uparrow$ 或者 $\downarrow$。
从公式 [[eqref:eq:一维系统波函数的MPS展开]] 中看到，{{{MPS}}}表示的波函数在一个特定构型下的分量，是一连串的矩阵乘积，这是矩阵乘积态(MPS)名称由来。

在实践中，通常可以通过多次奇异值分解（SVD）来将 公式 [[eqref:eq:一维系统波函数]] 写成 公式 [[eqref:eq:一维系统波函数的MPS展开]] 的形式。
具体而言，首先将张量 $T^{\sigma_0,\sigma_1,\cdots,\sigma_{L-1}}$ 视作矩阵 $T^{(\sigma_0), (\sigma_1,\cdots,\sigma_{L-1})}$ 并进行SVD分解得到， $T^{(\sigma_0), (\sigma_1,\cdots,\sigma_{L-1})} = U_0^{\sigma_0,v_1} S_0^{v_1, v'_1} V_0^{v'_1, \sigma_1,\cdots,\sigma_{L-1}}$ 。
合并 $S_0$ 和 $V_0$ 并视作矩阵， 得到 $S_0^{v_1, v'_1} V_0^{v'_1, \sigma_1,\cdots,\sigma_{L-1}} = T_1^{v_1, \sigma_1,\cdots,\sigma_{L-1}} = T_1^{ (v_1, \sigma_1),(\sigma_2 \cdots,\sigma_{L-1})}$ ，随后再次进行SVD分解，得到
$T_1^{(v_1, \sigma_1), (\sigma_2,\cdots,\sigma_{L-1})} = U_1^{v_1, \sigma_1,v_2} S_1^{v_2, v'_2} V_1^{v'_2, \sigma_2,\cdots,\sigma_{L-1}}$ 。
以此类推，最终得到
\begin{equation}
T^{\sigma_0,\sigma_1,\cdots,\sigma_{L-1}} =
U_0^{\sigma_0, v_1}
U_1^{v_1, \sigma_1, v_2}
\cdots
U_{L-2}^{v_{L-2}, \sigma_{L-2}, v_{L-1}}
T_{L-1}^{v_{L-1}, \sigma_{L-1}} .
\end{equation}
至此，已经可以通过替换符号名可以得到 公式 [[eqref:eq:一维系统波函数的MPS展开]] 。

在 {{{MPS}}} {{{Ansatz}}} 中，除了最左边和最右边的格点外，第 $i$ 个格点处的 $(A_i^{\sigma_i})_{v_i v_{i+1}}$ 是一个三阶张量，他有一个物理指标 $\sigma_i$
和两个虚拟指标 $v_i$ 和 $v_{i+1}$ 。
其中物理指标 $\sigma_i$ 可以取 $\uparrow$ 或者 $\downarrow$，其维度是 $2$ ，通常使用 $d$ 标记。
而虚拟指标的维度是一个可调节的参数，通常用 $D$ 表示。
这些指标被称作虚拟指标是因为他们并不是真正的物理指标。
对于其他类型的系统，一个格点处的物理维度并不一定是 $2$ ，如 $t-J$ 模型中 $d=3$ ， {{{Hubbard}}} 模型中 $d=4$ 。

*** {{{AL}}} 与 {{{MPS}}}

在 $D$ 不变的情况下，{{{MPS}}} 可以使用随着系统尺寸线性上升的参数来表示维度指数上升的波函数。
虽然 {{{MPS}}} 仅能表示 {{{Hilbert}}} 空间中极小区域的波函数，但是这些能够表示的态具有明确的物理意义，即：
固定 $D$ 的 {{{MPS}}} 所表示的态是 满足 {{{AL}}} 的态 [[cite:Hastings2007,Hastings2006,Arad2013,Arad2017]]。

一个量子态分割成两个部分A和B后，A部分和B部分之间的纠缠熵是
\begin{equation}\label{eq:纠缠熵}
S_{A|B} = - \mathrm{tr} (\hat\rho_A \ln \hat\rho_A) = - \mathrm{tr} (\hat\rho_B \ln \hat\rho_B) = - \sum_{v=0}^{V-1} \lambda_v \ln \lambda_v,
\end{equation}
其中 $\hat\rho_A$ 和 $\hat\rho_B$ 是A部分和B部分的约化密度矩阵，$\lambda_v$ 是他们的本征值， $V$ 为约化密度矩阵的维度。
纠缠熵最大的情况下，所有的本征值相等，即 $\lambda_v = \frac{1}{V}$，此时 $S_{A|B} = \ln V$ 。
而约化密度矩阵的维度随着较小系统的尺寸指数上升，不妨假设A部分比B部分更小， 有$S_{A|B} \propto |A|$ ，其中 $|X|$ 为X部分的体积。
而当系统满足{{{AL}}}时，纠缠熵有更强的约束， 即
\begin{equation}\label{eq:面积定律}
S_{A|B} \propto |\partial A| = |\partial B|,
\end{equation}
其中 $|\partial X|$ 表示X的边界大小。

对于公式 [[eqref:eq:一维系统波函数的MPS展开]] 表示的 {{{MPS}}}， 切割为长度为 $X$ 和 $Y$ 的两部分， $X+Y=L$ ，X部分的约化密度矩阵为
\begin{equation}\label{eq:MPS切割后的约化密度矩阵}
\begin{aligned}
(\hat\rho_X)_{\sigma_0,\sigma_1,\cdots,\sigma_{X-1}}^{\sigma'_0,\sigma_2,\cdots,\sigma'_{X-1}} =&
(A_0 ^ {\sigma_0})_{v_1}
\cdots
(A_{X-1} ^ {\sigma_{X-1}})_{v_{X-1} v_X}
(A_X ^ {\sigma_X})_{v_X v_{X+1}}
\cdots
(A_{L-1} ^ {\sigma_{N-1}})_{v_{N-1}}
\\
&
(A_0 ^ {\sigma'_0})^\dag_{v'_1}
\cdots
(A_{X-1} ^ {\sigma'_{X-1}})^\dag_{v'_{X-1} v'_X}
(A_X ^ {\sigma_X})^\dag_{v'_X v'_{X+1}}
\cdots
(A_{L-1} ^ {\sigma_{N-1}})^\dag_{v'_{N-1}} .
\end{aligned}
\end{equation}
注意到
\begin{equation}
\begin{aligned}
(\hat\rho_X)_{\sigma_0,\sigma_1,\cdots,\sigma_{X-1}}^{\sigma'_0,\sigma_2,\cdots,\sigma'_{X-1}} =&
(A_0 ^ {\sigma_0})_{v_1}
\cdots
(A_{X-1} ^ {\sigma_{X-1}})_{v_{X-1} v_X}
\\
&
M_{v_X, v_X'}
\\
&
(A_0 ^ {\sigma'_0})^\dag_{v'_1}
\cdots
(A_{X-1} ^ {\sigma'_{X-1}})^\dag_{v'_{X-1} v'_X},
\end{aligned}
\end{equation}
其中
\begin{equation}
\begin{aligned}
M_{v_X, v_X'} =&
(A_X ^ {\sigma_X})_{v_X v_{X+1}}
\cdots
(A_{L-1} ^ {\sigma_{N-1}})_{v_{N-1}}
\\
&
(A_X ^ {\sigma_X})^\dag_{v'_X v'_{X+1}}
\cdots
(A_{L-1} ^ {\sigma_{N-1}})^\dag_{v'_{N-1}} ,
\end{aligned}
\end{equation}
而 $M_{v_X,v'_X}$ 是一个 $D \times D$ 的矩阵，所以密度矩阵 $\hat \rho_X$ 的秩不大于 $D$ ，则其可表示的最大纠缠熵为 $S = \ln D$ ，即一个常数。
而满足 {{{AL}}} 的一维系统，两部分的边界是零维的点，大小也是常数，所以 {{{MPS}}} {{{Ansatz}}} 能够表示的一维系统恰好是满足一维情况下 {{{AL}}} 的系统。

由于{{{MPS}}}对纠缠熵恰到好处的描述，{{{MPS}}} 可以较高效地表示满足 {{{AL}}} 的系统的波函数。
一维情况下，局部 {{{Hamiltonian}}} 构成的有能隙系统的基态是满足 {{{AL}}} 的 [[cite:Eisert2010,Hastings2007,Hastings2006,Nachtergaele2006]]，所以一个固定 $D$ 的 {{{MPS}}} 可以很好地表示此类系统的基态。
而对于无能隙的系统，有 $S \propto \alpha \ln L$ [[cite:Eisert2010,Franchini2007,Korepin2004,Latorre2003,Vidal2003]] ，即纠缠熵随着系统的尺寸对数上升，而 $S \propto \ln D$ ，所以应取 $D \propto L ^\alpha$ ，
不过对于 $\alpha$ 较小的情况， 所需的 $D$ 随着系统尺寸增长缓慢，我们依然可以通过计算相当大的系统来了解接近热力学极限时系统的性质。

*** {{{TN}}} 的图形标记

由于 {{{TNS}}} 中各个 {{{T}}} 通常有复杂的运算关系，人们通常使用图形标记法来表示 {{{TN}}} [[cite:Ors2019,Biamonte2017]]。
图形标记法中，使用一个闭合的图形表示一个 {{{T}}} ，图形上的每一条边表示张量的一个指标，两个张量之间彼此相连的边表示这两个指标将要求和。
因此，张量的一个指标有时也被称呼为张量的一个边。
图 [[ref:fig:张量的图形标记法]] 中展示了一些基本的例子。

#+begin_export latex
\begin{figure}
\centering
\input{tikz/graphical_notation.tikz}
%\caption{张量的图形标记法}
%\note{注：
\caption{张量的图形标记法。
(a)是一个标量 $A$ ，即0阶张量；
(b)是一个向量 $A_i$ ，即1阶张量，有一个指标 $i$ ；
(c)是一个矩阵 $A_{ij}$ ，即2阶张量，有两个指标 $i$ 和 $j$ ；
(d)表示矩阵 $A_{ij}$ 和向量 $B_j$ 的乘积，即 $A_{ij} B_{j}$ ；
(e)表示两个矩阵相乘，即 $A_{ij} B_{jk}$ ；
(f)中三个矩阵彼此相连，表示了 $A_{ij} B_{jk} C_{ji}$ 。
}
\label{fig:张量的图形标记法}
\end{figure}
#+end_export

使用图形标记法表示的公式 [[eqref:eq:一维系统波函数的MPS展开]] 所展示的 {{{MPS}}} 在 $L=5$ 时如图 [[ref:fig:图形标记法表示的长度为5的MPS]] 所示。
{{{TN}}} 的图形标记法直观地展示了张量之间的连接关系。
因为图形标记法中的形象，我们称呼物理指标所在的边为物理边，其他张量之间彼此相连的边为虚拟边。

#+begin_export latex
\begin{figure}
\centering
\input{tikz/mps.tikz}
\caption{图形标记法表示的长度为$5$的MPS}
\label{fig:图形标记法表示的长度为5的MPS}
\end{figure}
#+end_export

** 投影纠缠对态 (PEPS)

*** {{{PEPS}}}的表示

{{{MPS}}} 成功地处理一维系统后，有一些将 {{{MPS}}} 直接应用于二维系统的尝试 [[cite:Verstraete2004]]，如图 [[ref:fig:用于表示二维系统的MPS和PEPS]] (a)所示。
但是二维系统中，对于满足 {{{AL}}} 的系统 [[cite:Eisert2010]] ，纠缠熵 $S \propto L$ ，其中 $L$ 为边界的长度。
这意味者{{{MPS}}}的虚拟指标维度 $D$ 需要随着系统增大而增大。
时至今日，这种方法通常被用于长条形的准一维系统的求解，而对于真正的二维系统， {{{MPS}}} 无法胜任。
Verstraete在表示二维系统的 {{{MPS}}} 上额外加上了行间的边从而得到了{{{PEPS}}} [[cite:Verstraete2004]] ，如图 [[ref:fig:用于表示二维系统的MPS和PEPS]] (b)所示。

#+begin_export latex
\begin{figure}
\centering
\input{tikz/mps_to_peps.tikz}
%\caption{用于表示二维系统的 矩阵乘积态 和 投影纠缠对态 }
%\note{注：固定 虚拟指标维度 $D$ 的 矩阵乘积态 只能表示常数的纠缠熵，通过在行间加上额外的边可以得到 投影纠缠对态， 投影纠缠对态 可以满足二维系统的面积定律。}
\caption{用于表示二维系统的 矩阵乘积态 和 投影纠缠对态。固定 虚拟指标维度 $D$ 的 矩阵乘积态 只能表示常数的纠缠熵，通过在行间加上额外的边可以得到 投影纠缠对态， 投影纠缠对态 可以满足二维系统的面积定律。}
\label{fig:用于表示二维系统的MPS和PEPS}
\end{figure}
#+end_export

一张 {{{PEPS}}} 中划分出一个区域X，其与外界相连的边的数目正比与区域的周长，即边的数目 $N \propto |\partial X|$ 。
类似 {{{MPS}}} 的情况，计算约化密度矩阵时有同样的形式：
\begin{equation}\label{eq:PEPS中计算约化密度矩阵}
(\hat\rho_{X})_{s_{X, 0}, s_{X, 1}, \cdots} ^ {s'_{X, 0}, s'_{X, 1}, \cdots} =
T_{s_{X,0}, s_{X,1}, \cdots}^{v_0, v_1, \cdots v_{N-1}}
M_{v_0, v_1, \cdots v_{N-1}}^{v'_0, v'_1, \cdots v'_{N-1}}
T^{\dag {s'_{X,0}, s'_{X,1}, \cdots}}_{v'_0, v'_1, \cdots v'_{N-1}} , 
\end{equation}
其中， $s_{X,i}$ 为区域X中各个物理指标， $v_i$ 为区域X和外部相连的边的指标。
公式 [[eqref:eq:PEPS中计算约化密度矩阵]] 中间有一个 $D^N$ 维度的矩阵$M$，其中 $D$ 是 {{{PEPS}}} 中虚拟指标的维度。
而 $S = \ln D^N = N \ln D \propto |\partial X|$ ，所以 {{{PEPS}}} 可以满足二维系统的 {{{AL}}} 。

*** 投影纠缠对

使用一张 {{{TN}}} 作为 {{{Ansatz}}} 表示波函数时，我们可以有两种构造方式。第一种是数学上的分解，即对于任意一个 $R$ 个粒子的系统，波函数
\begin{equation}
|\Psi\rangle = T_{i_{T,0}, i_{T,1}, \cdots, i_{T,R-1}} |i_0 i_1 \cdots i_{R-1} \rangle ,
\end{equation}
中 $T$ 作为一个 $R$ 阶张量，可以被分解为一张 {{{TN}}}：
\begin{equation}
\begin{aligned}
T_{i_{T,0}, i_{T,1}, \cdots, i_{T, R-1}} = &
\prod_{n=0}^{N-1} (A_n)_{i_{A_n, 0} i_{A_n, 1} \cdots i_{A_n, \mathrm{rank}(A_n) -1}}
\\ &
\prod_{b=0}^{B-1} \delta^{i_{A_{V_b^0},E_b^0}}_{i_{A_{V_b^1},E_b^1}}
\\ &
\prod_{r=0}^{R-1} \delta^{i_{T,r}}_{i_{A_{V'_r},E'_r}} .
\end{aligned}
\end{equation}
这张 {{{TN}}} 中有 $N$ 个{{{T}}} ，即 $A_n$ ，其中 $n = 0, 1, \cdots N-1$ 。
张量 $A_n$ 的阶数是 $\mathrm{rank}(A_n)$ ，他的指标被记作 $i_{A_n, j}$ ，其中 $j = 0, 1, \cdots \mathrm{rank}(A_n) - 1$ 。
这张 {{{TN}}} 内部有 $B$ 个边连接某两个张量，第 $b$ 个边所连接的是第 $V_b^0$ 个张量的第 $E_b^0$ 个边和第 $V_b^1$ 个张量的第 $E_b^1$ 个边，其中 $b=0,1,\cdots B-1$
而这些张量中，有 $R$ 个边没有被收缩，而是作为物理指标出现在张量 $T$ 中，
张量 $T$ 的第 $r$ 个边在 {{{TN}}} 中是第 $V'_r$ 个张量的第 $E'_r$ 个边，其中 $r = 0, 1, \cdots R-1$ 。
这张 {{{TN}}} 中，由 $A_n$ ， $n=0, \cdots N-1$ 组成，而 $V_b^0, V_b^1, V'_r, E_b^0, E_b^1, E'_r$ ， $b=0,\cdots B-1, r=0,\cdots R-1$ 用于表示 {{{TN}}} 的图结构信息。
通过不同的 {{{TN}}} 图结构，可以构造出不同类型的 {{{TN}}}。

另一种构造方式是将 {{{TNS}}} 视为对一群纠缠对所构成的母态的投影。
先把波函数写成产生算符的形式：
\begin{equation}\label{eq:一般的波函数}
|\Psi\rangle = T_{i_{T,0}, i_{T,1}, \cdots, i_{T,R-1}} \prod_{r=0}^{R-1} c_r^{\dag i_{T,r}} |\Omega\rangle ,
\end{equation}
其中 $|\Omega\rangle$ 是真空态，  $c_r^{\dag i_{T,r}}$ 是第 $r$ 个粒子处，产生第 $i_{T,r}$ 个构型的算符。
需要注意的是，对于一些系统， $c_r^{\dag i_{T,r}}$ 不一定是单个粒子的产生算符，而可能是多个粒子产生算符的复合。
然后将波函数视为对一个母态的投影：
\begin{equation}
|\Psi\rangle = P M |\Omega\rangle ,
\end{equation}
其中 $P$ 为投影算符， $M$ 为制备母态的算符。
而母态为众多组纠缠对的组合：
\begin{equation}
M = 
\prod_{b=0}^{B-1} a_{b,0}^{\dag d_b} a_{b,1}^{\dag d_b}
,
\end{equation}
其中第 $b$ 组纠缠对由 $a_{b,0}^{\dag d_b}$ 和 $a_{b,1}^{\dag d_b}$ 生成， 这里 $d_b$ 取值范围为 $0, 1, \cdots D_b - 1$ ，其中 $D_b$ 为这组纠缠对的个数。
而投影算符被定义为：
\begin{equation}
\begin{aligned}
P = 
\prod_{n=0}^{N-1} & (A_n)_{i_{A_n, 0} i_{A_n, 1} \cdots i_{A_n, \mathrm{rank}(A_n) -1}} \\
&
\prod_{j=0}^{\mathrm{rank}(A_n) - 1} \left\{
\begin{aligned}
&a^{i_{A_n, j}}_{X_{A_n,j},Y_{A_n, j}} \ & \text{如果 $A_n$ 的第 $j$ 个边为虚拟边}, \\
&c^{\dag i_{A_n,j}}_{Z_{A_n,j}} \ & \text{如果 $A_n$ 的第 $j$ 个边为物理边},
\end{aligned}
\right.
\end{aligned}
\end{equation}
其中 $A_n$ 的第 $j$ 个边，如果是物理边，则是 $|\Psi\rangle$ 的第 $Z_{A_n,j}$ 个边，
如果是虚拟边，则将湮灭掉第 $X_{A_n,j}$ 组纠缠对中粒子，而 $Y_{A_n,j}$ 取 $0$ 或 $1$ ，标记其湮灭的是纠缠对中靠前的还是靠后的粒子。
这种解释方式中，将张量网络的虚拟边用纠缠对表示，投影算子中湮灭同一个纠缠对的两个部分是彼此相连的张量。
每个张量通过湮灭掉纠缠对并产生物理的粒子，实现了将多组纠缠对投影到物理空间的操作，这便是投影纠缠对态的名称由来。

在张量网络态的投影纠缠对构造中，投影部分既有湮灭算符也有产生算符，这使得表达式缺乏一致性。
我们可以再为每个物理粒子引入一个纠缠的虚拟的粒子来解决这个问题，这样投影算子只需要湮灭虚拟粒子，得到
\begin{equation}\label{eq:投影纠缠对构造的一般张量网络}
\left\{
\begin{aligned}
P &= 
\prod_{n=0}^{N-1} (A_n)_{i_{A_n, 0} i_{A_n, 1} \cdots i_{A_n, \mathrm{rank}(A_n) -1}}
\prod_{j=0}^{\mathrm{rank}(A_n) - 1} 
a^{i_{A_n, j}}_{X_{A_n,j},Y_{A_n, j}} , \\
M &=
\prod_{b=0}^{B-1} a_{b,0}^{\dag d_b} a_{b,1}^{\dag d_b}
\prod_{r=0}^{R-1} a_{r+B,0}^{\dag d_{r+B}} c_r^{\dag d_{r+B}} ,
\end{aligned}
\right.
\end{equation}
通过 公式 [[eqref:eq:投影纠缠对构造的一般张量网络]] ,我们依然可以将公式 [[eqref:eq:一般的波函数]] 表示为母态上的投影，即 $|\Psi\rangle = P M |\Omega\rangle$ 。
这种变型的投影纠缠对构造方式将每个张量中各个边平等地对待，图结构的信息完全放置在母态生成算符 $M$ 中。

** 对称性张量和费米子张量 <<sec::对称性张量和费米子张量>>

*** 对称性张量 <<sec:::对称性张量>>

当一个系统的 {{{Hamiltonian}}} 拥有某个对称性时，其基态要么满足这个对称性，要么自发破缺从而是简并的
[[cite:Moretti2018-dw,Martin2008-le,McMahon2008-vj,Chaichian1997-ft,Ladd1989-rg]]。
对称性变换使用一个紧致群 $G$ 来描述，
如果公式 [[eqref:eq:一般的波函数]] 表示的基态波函数满足这个对称性，我们有
\begin{equation}\label{eq:对称性张量}
U_g^{\otimes R} T_{i_{T,0},\cdots, i_{T,R-1}} = T_{i_{T,0},\cdots, i_{T,R-1}} ,
\end{equation}
其中 $g \in G$ ，
$U_g^{\otimes R} = \bigotimes_{r=0}^{R-1} U_g^r$ ， $U_g^r$ 为 $g$ 在张量的第 $r$ 个指标的线性空间上的表示。
满足公式 [[eqref:eq:对称性张量]] 的张量被称作对称性张量 [[cite:Singh2010,Singh2011,Singh2012]] ，图 [[ref:fig:对称性张量和对称性张量网络]] (a)使用图形标记法展示了此关系。
需要注意对称性张量和对称矩阵完全不同，对称矩阵是做交换两个指标的转置变换下不变的矩阵，对称性张量是在每个指标中各自做相同的群元素代表的群变换下不变的张量。

#+begin_export latex
\begin{figure}
\centering
\input{tikz/symmetry.tikz}
%\caption{对称性张量和对称性张量网络}
%\note{注：
\caption{对称性张量和对称性张量网络。
(a)中，对张量做一个对称性变换相当与在张量的每个指标上作用上这个指标上 $g$ 的群表示矩阵，因为是群是紧致的，我们可以给张量找到一组合适的基使得矩阵是酉的。
(b)中，如果张量网络中的每个张量都是对称性张量，我们可以在每个张量的周围都加上群的变换矩阵，而不改变张量网络的值，得到等式的左侧；
而两个张量彼此相互收缩的线性空间是相互共轭的，所以他们的群表示是互逆的，所有的虚拟边上的两个矩阵可以相互抵消而不改变张量网络的值，得到等式的右侧；
所以原有的张量网络等于只在物理边上做群变换，即整个张量网络的收缩结果是对称性张量。}
\label{fig:对称性张量和对称性张量网络}
\end{figure}
#+end_export

从图 [[ref:fig:对称性张量和对称性张量网络]] (b) 中可以很明显看出，对称性张量收缩结果仍然是对称性张量 [[cite:Singh2010]] 。
所以对于一个已知满足某个对称性的波函数，使用张量网络表示时，可以使用限制更强的 {{{Ansatz}}} ：{{{TNS}}} 中每个张量都是对称性张量 [[cite:Singh2010]]。
波函数的物理指标有明确的物理意义，所以给定对称群的群表示是固定的。
而对于一个张量网络态，我们可以将每个虚拟指标所在的线性空间也看作对称群的一个表示空间，
从而我们可以对张量网络态中的每个张量各自做对称性变换，这样每个张量都可以被设置为对称性张量。
值得注意的是，这种虚拟指标所在空间的群表示是任意的。

一个对称性张量的每个边所在的空间都是群的表示空间，空间 $V$ 可以分解为
\begin{equation}
V \cong \bigoplus_{s} d_s V^{s} \cong \bigoplus_{s} (D^{s} \otimes V^{s}),
\end{equation}
其中 $V^s$ 是群的第 $s$ 个不可约表示空间， $d_s$ 是他的重数，这里 $D^s$ 是 $d_s$ 维的简并空间。

我们可以使用 $U_g^r$ 来作张量的第 $r$ 个指标的基，每个指标的空间 $V^r = \bigoplus_s (D^{r,s} \otimes V^s)$ 中，使用 $(s,\alpha_s, m_s)$ 来作为基底。
其中 $s$ 标记了不同的不可约表示， $\alpha_s$ 是简并空间的指标，即 $\alpha_s = 0,1,\cdots d_s-1$ ，而 $m_s$ 是这个不可约表示空间中的指标。

在这个基下，一个张量是一个对称性张量的条件是
+ 0阶 :: 标量显然是一个对称性张量。
+ 1阶 :: 其非零元素只能位于平凡的不可约表示中，即 $s=0$ ，而 $m_0=0$ 。
+ 2阶 :: 其非零元素的两个指标需要在相同的不可约表示空间中，且两者的 $m_s$ 相反，即张量需要满足形式
\begin{equation}
T_{(s_0,\alpha_{s_0},m_{s_0}),(s_1,\alpha_{s_1},m_{s_1})} =
P_{(s_0,\alpha_{s_0}),(s_1,\alpha_{s_1})} \delta_{s_0,s_1}
\begin{pmatrix} s_0 \\ m_{s_0} \quad m_{s_1} \end{pmatrix},
\end{equation}
其中括号是Wigner 1-jm符号[[cite:Wigner1993]]。
+ 3阶 :: 张量需要满足形式
\begin{equation}
T_{(s_0,\alpha_{s_0},m_{s_0}),(s_1,\alpha_{s_1},m_{s_1}),(s_2,\alpha_{s_2},m_{s_2})} =
P_{(s_0, \alpha_{s_0}),(s_1, \alpha_{s_1}),(s_2, \alpha_{s_2})}
\begin{pmatrix}
s_0 & s_1 & s_2 \\
m_0 & m_1 & m_2
\end{pmatrix},
\end{equation}
其中括号是Wigner 3-jm符号 [[cite:Wigner1993]] 。
+ 更高阶 :: 张量需要可以被分解为多个3阶对称性张量收缩的形式。

如上所示，一般对称群的对称性张量结构十分复杂，但对于Abel群来说，情况却十分简单。
Abel群的不可约表示一定是1维的，所以恒有 $m_s=0$ ,故我们将 $m_s$ 省略，使用 $(s,\alpha_s)$ 作为基 [[cite:Singh2011]]。
此时 $R$ 阶的对称性张量需要满足
\begin{equation}
U_g^{\otimes R} T_{(s_0,\alpha_{s_0}),(s_1,\alpha_{s_1}),\cdots (s_{R-1},\alpha_{s_{R-1}})} =
T_{(s_0,\alpha_{s_0}),(s_1,\alpha_{s_1}),\cdots (s_{R-1},\alpha_{s_{R-1}})},
\end{equation}
而 $U_g^{\otimes R}$ 中每个项目 $U_g^r = U_g^{s_r}$ ，作为一个一维的酉矩阵，就是一个复数。
所以我们得到：
\begin{equation}
T_{(s_0,\alpha_{s_0}),(s_1,\alpha_{s_1}),\cdots (s_{R-1},\alpha_{s_{R-1}})}
\prod_r^{R-1}U_g^{s_r}
=
T_{(s_0,\alpha_{s_0}),(s_1,\alpha_{s_1}),\cdots (s_{R-1},\alpha_{s_{R-1}})}.
\end{equation}
为此，张量需要满足形式：
\begin{equation}\label{eq:Abel对称性张量的原始形式}
T_{(s_0,\alpha_{s_0}),(s_1,\alpha_{s_1}),\cdots (s_{R-1},\alpha_{s_{R-1}})} =
P_{(s_0, \alpha_{s_0}),(s_1, \alpha_{s_1}),\cdots (s_{R-1}, \alpha_{s_{R-1}})}
C(s_0,s_1,\cdots s_{R-1}) ,
\end{equation}
其中
\begin{equation}
C(s_0, s_1, \cdots s_{R-1}) = \left\{\begin{aligned}
1 \quad & \text{如果对于任意$g$有}  \quad \prod_{r=0}^{R-1} U_g^{s_r} = 1 ,\\
0 \quad & \text{其他情况},
\end{aligned}\right.
\end{equation}
是对称群决定的对称性条件。
将公式 [[eqref:eq:Abel对称性张量的原始形式]] 稍作变形得到：
\begin{equation}\label{eq:Abel对称性张量的形式}
T_{(s_0,\alpha_{s_0}),(s_1,\alpha_{s_1}),\cdots (s_{R-1},\alpha_{s_{R-1}})} =
\left(P_{s_0,s_1,\cdots,s_{R-1}}\right)_{\alpha_{s_0},\alpha_{s_1},\cdots \alpha_{s_{R-1}}}
C(s_0,s_1,\cdots s_{R-1}) .
\end{equation}
可见Abel群的对称性张量是一个分块的张量，其中分块方案由对称性条件和张量每个边上的不可约表示分解决定。

物理中常见的群是 $Z(2)$ 群和 $U(1)$ 群。
对于 $Z(2)$ 群[[cite:Singh2010]]， $g=e$ 表示不变， $g=z$ 表示反转。
群表示 $0$ 中 $U_e^0 = U_z^0 = +1$ ，另一个群表示 $1$ 中 $U_e^1 = +1$ ， $U_z^1 = -1$ 。
所以 $Z(2)$ 群的对称性条件是：
\begin{equation}\label{eq:Z2对称性条件}
C(s_0, s_1, \cdots s_{R-1}) = \left\{\begin{aligned}
1 \quad & \text{如果}  \quad \bigoplus_{r=0}^{R-1} s_r = 0 ,\\
0 \quad & \text{如果}  \quad \bigoplus_{r=0}^{R-1} s_r = 1 ,
\end{aligned}\right.
\end{equation}
其中 $\bigoplus$ 为异或运算。

而对于 $U(1)$ 群[[cite:Singh2011]]， $g=\theta$ 表示旋转 $\theta$ 。
群表示使用一个整数 $s$ 来标记， $U_\theta^s = \mathrm{e}^{\mathrm{i} s \theta}$ 。
所以 $U(1)$ 群的对称性条件是：
\begin{equation}
C(s_0, s_1, \cdots s_{R-1}) = \left\{\begin{aligned}
1 \quad & \text{如果}  \quad \sum_{r=0}^{R-1} s_r = 0 ,\\
0 \quad & \text{如果}  \quad \sum_{r=0}^{R-1} s_r \neq 0 .
\end{aligned}\right.
\end{equation}

对于 $U(1)$ 群和 $Z(2)$ 的乘积群，可以使用各个子群的群表示的乘积来表示这个群的群表示。
比如对于 $U(1) \times Z(2)$ 群，群元素为 $g=(\theta, p)$ ，其中 $p=e=+1$ 表示不变， $p=z=-1$ 表示反转。
群表示可以标记为 $s=(z, b)$ 其中 $z$ 为整数， $b=0$ 或 $1$ ，而 $U_{\theta,p}^{z, b} = \mathrm{e}^{\mathrm{i} z \theta} p^b$ 。
对称性条件 $C=1$ 的条件为
\begin{equation}
\begin{aligned}
1 &= \prod_{r=0}^{R-1} U_{\theta,p}^{z_r, b_r} \\
&= \prod_{r=0}^{R-1} \mathrm{e}^{\mathrm{i} z_r \theta} p^{b_r} \\
&= \mathrm{e}^{\mathrm{i} \sum_{r=0}^{R-1} z_r \theta} p^{\sum b_r} \quad \forall \theta, p ,
\end{aligned}
\end{equation}
即 $\sum_{r=0}^{R-1} z_r = 0$ 且 $\bigoplus_{r=0}^{R-1} b_r = 0$ 。
故而有
\begin{equation}
\begin{aligned}
&C_{U(1)\times Z(2)} ( (z_0, b_0), (z_1, b_1), \cdots (z_{R-1}, b_{R-1}) ) \\
= &C_{U(1)} (z_0, z_1, \cdots z_{R-1}) C_{Z(2)} (b_0, b_1, \cdots b_{R-1}),
\end{aligned}
\end{equation}
可见对于乘积群，对称性张量非零的条件是满足所有子群的对称性条件：对称性条件为各个子群的对称性条件的乘积：
\begin{equation}
C_{\prod_i G_i} = \prod_i C_{G_i} .
\end{equation}

综上所述，Abel群的对称性张量是一个由对称性条件决定的分块张量，由对称性张量所构成的张量网络整体依然满足这个对称性。
对于已知满足某个对称性的波函数来说，使用对称性张量所构成的张量网络来表示能够很好的减少网络参数。

*** 费米子张量 <<sec:::费米子张量>>

#+LATEX: {\color{blue}HLX: 这句话不通。为什么是“大部分？”这只是一种可能的选择！ ZH: 除了fermion tensor，二次量子化表象下并没有见过不等价于JW变换的表示方式，修改了一下表述方式。 }

费米子系统中，由于反对易的性质，二次量子化表象下，用于表示费米子系统波函数的方法 通常 需要进行Jordan-Wigner变换 [[cite:Giamarchi2003,Coleman2015-mb]] ，即：
\begin{equation}\label{eq:Jordan-Wigner变换}
\left\{
\begin{aligned}
f_i^\dag &= \mathrm{e} ^{+\mathrm{i} \pi \sum_{j=0}^{i-1} a_j^\dag a_j}  a_i^\dag \\
f_i &= \mathrm{e} ^{-\mathrm{i} \pi \sum_{j=0}^{i-1} a_j^\dag a_j}  a_i .
\end{aligned}
\right.
\end{equation}
其中 $a_i^\dag$ 和 $a_i$ 为硬核玻色子的产生湮灭算符，或者说是自旋的上升下降算符。
通过此变换，构造出来的 $f_i^\dag$ 和 $f_i$ 拥有费米子的反对易性质。
这意味这，我们可以将费米子系统的哈密顿量中所有的粒子算符，使用公式 [[eqref:eq:Jordan-Wigner变换]] 进行替换，从而得到了一个非玻色子的系统。

Jordan-Wigner变换要求给所有的费米子模式排列成一维序列，并让所有的产生湮灭算符添加一个包含序列前面所有粒子粒子数的相位表达式。
对于一维的近邻相互作用来说，这种情况不会有太大问题，因为相位表达式中大部分项目都会相互抵消，
比如：
\begin{equation}
\begin{aligned}
f_{i+1}^\dag f_i
&= \mathrm{e}^{+\mathrm{i}\pi \sum_{j=0}^{i} a_j^\dag a_j} a_{i+1}^\dag \mathrm{e}^{-\mathrm{i} \pi \sum_{j=0}^{i-1} a_j^\dag a_j} a_i \\
&= \mathrm{e}^{+\mathrm{i}\pi a_i^\dag a_i} a_{i+1}^\dag a_i ,
\end{aligned}
\end{equation}
可见一维情况的近邻相互作用经过Jordan-Wigner变换后依然是近邻相互作用。

但是对于二维系统来说，将所有物理边排列成一行后，原本行间的近邻相互作用变成了长程的相互作用，如：
\begin{equation}
f_{i+1,j}^\dag f_{i,j} = \mathrm{e} ^ {+\mathrm{i}\pi (\sum_{k=j}^{L_2-1} a_{i,k}^\dag a_{i,k} + \sum_{k=0}^{j-1} a_{i+1,k}^\dag a_{i+1,k})} a_{i+1,j}^\dag a_{i,j} .
\end{equation}
所以即使只有近邻相互作用的二维系统，进行Jordan-Wigner变换时，也会引入大量的交换费米子产生的相位符号，并且这是多体且长程的。
当应用Jordan-Wigner变换于张量网络态时，这种长程相互作用，会极大地削弱张量网络态的表示能力。

一种针对费米子的张量网络态方案可以解决这个问题 [[cite:Dong2019,Zhang2024]] 。
考虑公式 [[eqref:eq:投影纠缠对构造的一般张量网络]] ，这种张量网络态的构造中，
使用母态中的纠缠对建立关联，并使用投影算子将母态投影到真实的物理空间中。
如果直接将母态中的物理产生算符替换成费米子产生算符，会破坏原本的网络中，
各个张量和各个边所表示的收缩运算可以随意交换次序的性质。
但是，如果纠缠对整体没有费米子的性质，即 $P_{\text{物理}, r} = a_{r+B,0}^{\dag d_{r+B}} c_r^{\dag d_{r+B}}$ 中，
$a_{r+B,0}^{\dag d_{r+B}}$ 和 $c_r^{\dag d_{r+B}}$ 对于不同的 $d_{r+B}$ 始终拥有相同的费米子奇偶性，
那么，母态中产生物理粒子的部分，即张量网络中的物理边，整体是一个玻色的算符，依然可以随意交换顺序。
类似的，对于每组虚拟纠缠对 $P_{\text{虚拟}, b} = a_{b,0}^{\dag d_b} a_{b,1}^{\dag d_b}$ ，
我们也可以将其中的某些算符替换成费米子，这样依然可以保持这些纠缠对整体的玻色性质 [[cite:Dong2019,Zhang2024]] 。
当然，当我们将物理纠缠对和虚拟纠缠对中一部分粒子替换为费米子后，
投影算符中的湮灭算符也对应地变成了费米子，整体并不能再随意交换了。

考虑到凝聚态物理中，大部分系统的费米子数目是守恒的，即系统至少满足 $U(1)$ 对称性 [[cite:Singh2011]]。
我们可以将这个条件先弱化为 $Z(2)$ 对称性，按照 [[ref:sec:::对称性张量]] 中的结论，
我们可以使用 $Z(2)$ 对称性张量来构成表示这个系统的张量网络态。
此时，每个张量网络中的每个张量都是在 $Z(2)$ 对称性变化下不变的分块张量，
公式 [[eqref:eq:投影纠缠对构造的一般张量网络]] 中投影算符可以写为：
\begin{equation}
\begin{aligned}
P_{\text{投影}, n} =
&(A_{n, (s_0, s_1, \cdots s_{R-1})})_{\alpha_{s_0}, \alpha_{s_1}, \cdots \alpha_{s_{R-1}}} \\
&C(s_0, s_1, \cdots s_{R-1}) \\
&\prod_{j=0}^{\mathrm{rank}(A_n) - 1} 
a^{(s_j, \alpha_{s_j})}_{X_{A_n,j},Y_{A_n, j}} ,
\end{aligned}
\end{equation}
由于只涉及到单个张量，这里为了便利省略了指标中表示张量所有的标记，即将 $s_{A_n,j}$ 写成了 $s_{j}$ 。

这里的 $C(s_0, s_1,\cdots s_{R-1})$ 为公式 [[eqref:eq:Z2对称性条件]] 所描述的 $Z(2)$ 群的对称性条件。
容易验证，当 $C(s_0, s_1, \cdots s_{R-1}) \neq 0$ 时，湮灭算子部分
\begin{equation}
\prod_{j=0}^{\mathrm{rank}(A_n) - 1} 
a^{(s_j, \alpha_{s_j})}_{X_{A_n,j},Y_{A_n, j}}
\end{equation}
一定是玻色的。
这保证了投影算子的每个非零项都是玻色的，所以投影算子整体是玻色的 [[cite:Dong2019,Zhang2024]]，
从而我们可以对正常的张量一样，随意交换投影算子。

由此可见，我们可以使用 $Z(2)$ 对称性的张量加上含有费米子的纠缠对湮灭算符，
作为费米子张量来构造用于描述费米子系统的张量网络。
这种情况下，我们必须使用纠缠对构造方式来理解张量网络态，因为我们需要在母态中包含含有费米子的纠缠对产生算符。

对于费米子张量来说，我们也可以使用更强的 $U(1)$ 对称性 [[cite:Singh2011]]，因为更强的对称性对分块有着更强的限制，
对称性条件依然能保证有费米子性质的元素一定为零。
而为了确保费米子张量的可交换性质，一定存在某个对称性保证张量是分块的。
为了区分，我们将这种对称性前面加上词缀 `{{{F}}}' ，
如 {{{F}}}-$U(1)$ 对称性 或者 {{{F}}}-$Z(2)$ 对称性。
而纠缠对中体现对称性的粒子中不存在费米子时，我们也可以在对称性前面加上词缀 `{{{B}}}-' 用于强调，如
{{{B}}}-$U(1)$ 对称性或者 {{{B}}}-$Z(2)$ 对称性。
同样，我们可以将这些对称群进行乘积，比如 {{{F}}}-$U(1) \times$ {{{B}}}-$U(1)$ 对称性，
其可以同时描述电子数和z方向自旋的守恒。

综上所述，费米子张量由某个群的对称性张量和含有费米子的纠缠对构成。
对称性张量即分块的张量，他的每个边上的每个维度都有一个对称群表示的属性，这些属性共同确定了张量分块的方案。
而一组纠缠对的性质中，每个纠缠对是否是费米的性质可以完全由张量边上的对称群表示确定，
但是每个张量边上的湮灭算子到底湮灭的是纠缠对中靠前的那个粒子还是靠后的那个粒子是不确定的。
为此，我们需要给每个边额外加上一个属性，标记这个边对应的产生算符处于纠缠对中的哪一个。
本论文中，使用一个名为``费米箭头'' [[cite:Dong2019]] 的布尔数标记纠缠对中的先后顺序：0 或 =False= 表示在纠缠对中靠前，1 或 =True= 表示在纠缠对中靠后。
当两个张量的边相连时，两个张量的边湮灭的是纠缠对中的两个粒子，必然一个靠前一个靠后，
所以彼此相连的两个边上的费米箭头必然一个为0一个为1。

** 费米子张量上的张量操作 <<sec::费米子张量上的张量操作>>

费米子张量中，
对称性张量的各种张量操作过程中与寻常的张量没有差别，
而纠缠对中引入费米子却会改变几乎所有的张量操作，
现在我们需要对各种张量运算一个一个考虑费米子的影响[[cite:Dong2019,Zhang2024]]。

*** 张量转置

张量转置是寻常张量中特别普遍的操作。寻常的张量转置仅仅是数据的重新排列，
但是对于费米子张量，边的顺序关系到了湮灭算符的顺序：
交换湮灭算符时，会产生符号。

考虑投影子
\begin{equation}
P_n = 
(A_n)_{i_{0} i_{1} \cdots}
a_0^{i_0} a_1^{i_1} \cdots ,
\end{equation}
交换相邻的两个湮灭算符，如第 $j$ 和第 $j+1$ 个湮灭算符时，如果 $p(a_j^{i_j}) p(a_{j+1}^{i_{j+1}}) = 1$ 则会产生符号，
如果为 $0$ 则不会产生符号，
其中
\begin{equation}
p (a) = \left\{\begin{aligned}
1  \quad & \text{如果} a \text{是费米的} \\
0  \quad & \text{如果} a \text{是玻色的} .
\end{aligned}\right.
\end{equation}
为了简单表述，我们称呼这时产生了 $p(a_j^{i_j}) p(a_{j+1}^{i_{j+1}})$ 个符号。

注意到费米子张量是分块的张量，每个分块上的边上有着相同的对称群表示，所以他们湮灭算符的费米子奇偶性也是一样的，
故张量转置时，每个分块产生的符号数是一样的，这为具体实现提供了很大的便利，
因为我们可以一个分块一个分块地分析符号，而不必每个元素单独分析一遍。

当进行更加复杂的转置时，可以分解为多个近邻的湮灭算符交换，容易验证：
\begin{equation}
\begin{aligned}
P_n &= 
(A_n)_{i_{0} i_{1} \cdots}
a_0^{i_0} a_1^{i_1} \cdots \\
&= (A'_n)_{i_{s_0} i_{s_1} \cdots} a_{s_0}^{i_{s_0}} a_{s_1}^{i_{s_1}} \cdots ,
\end{aligned}
\end{equation}
其中 $s_0, s_1, \cdots$ 为一个排列，描述了如何转置，而 $A'_n$ 满足：
\begin{equation}
(A'_n)_{i_{s_0} i_{s_1}\cdots} = (A_n)_{i_0 i_1 \cdots} (-1)^{\sum_{j<k,s_j>s_k} p(a_j^{i_j}) p(a_k^{i_k})} .
\end{equation}

*** 张量的共轭

共轭用于将波函数从希尔伯特空间转换到对偶空间，从而进行内积运算。
寻常的张量网络所表示的态进行共轭可以表示为每个张量都取共轭后所组成的张量网络。
对于费米子张量网络，依然有类似的性质。

考虑波函数 $P M | \Omega\rangle$ ，其中 $P$ 和 $M$ 为公式 [[eqref:eq:投影纠缠对构造的一般张量网络]] 所展示，
求共轭得到 $\langle \Omega | M^\dag P^\dag$ ，其中
\begin{equation}
\left\{
\begin{aligned}
M^\dag &=
\prod_{b=0}^{B-1} a_{b,1}^{d_b} a_{b,0}^{d_b}
\prod_{r=0}^{R-1} c_r^{d_{r+B}} a_{r+B,0}^{d_{r+B}} , \\
P^\dag &= 
\prod_{n=0}^{N-1} (A_n)^\dag_{i_{A_n, 0} i_{A_n, 1} \cdots i_{A_n, \mathrm{rank}(A_n) -1}}
\prod_{j=\mathrm{rank}(A_n) - 1}^{0}
a^{\dag i_{A_n, j}}_{X_{A_n,j},Y_{A_n, j}} . \\
\end{aligned}
\right.
\end{equation}
这里 $P^\dag$ 可以先恢复所有的产生算符的顺序得到
\begin{equation}
P^\dag = 
\prod_{n=0}^{N-1} (-1)^{\sum_{j<k} p(a_j^{i_j}) p(a_k^{i_k})}
(A_n)^\dag_{i_{A_n, 0} i_{A_n, 1} \cdots i_{A_n, \mathrm{rank}(A_n) -1}}
\prod_{j=0}^{\mathrm{rank}(A_n) - 1}
a^{\dag i_{A_n, j}}_{X_{A_n,j},Y_{A_n, j}} . \\
\end{equation}
然而现在，无论是纠缠对的母态 $M^\dag$ 还是投影子中的产生算符，都不符合费米子张量的形式，下面我们一步步地恢复原本的形式。

当计算某个物理量时，真正计算的是
\begin{equation}
\langle \Psi^\dag_1 |O| \Psi_2 \rangle = \langle \Omega | P^\dag_1 M^\dag_1 O M_2 P_2 | \Omega \rangle ,
\end{equation}
考虑其中某组虚拟粒子所在的子空间，表达式为
\begin{equation}
\langle \Omega | a^{d_1} a^{\dag d_2} a^{d_3} a^{\dag d_4} | \Omega \rangle  ,
\end{equation}
其中 $a^{d_1}$ ， $a^{d_2}$ ， $a^{d_3}$ ， $a^{d_4}$ 分别是  $P^\dag_1$ ， $M^\dag_1$ ， $M_2$ ， $P_2$ 中这组粒子的算符，
注意这些算符中的上标 $d_i$ 指的是不同的粒子。
我们可以将共轭空间中的虚拟粒子替换成新的虚拟粒子，其结果依然不变，得到
\begin{equation}
\langle \Omega | a^{d_1} a^{\dag d_2} a^{d_3} a^{\dag d_4} | \Omega \rangle =
\langle \Omega | a'^{d_1} a'^{\dag d_2} a^{d_3} a^{\dag d_4} | \Omega \rangle .
\end{equation}
综上，我们考虑共轭后的张量网络时，可以完全不考虑希尔伯特空间中相同的虚拟粒子的影响。

而对于连接两个张量 $P_x$ 和 $P_y$ 的虚拟边，考虑每个元素，我们可以将湮灭算符对往后面移动：
\begin{equation}
\begin{aligned}
&\overbrace{\left(\cdots (a'_1 a'_0) \cdots\right)}^{M^\dag}
\underbrace{\cdots \overbrace{\left(\cdots a_0^{\prime \dag} \cdots\right)}^{P^\dag_x} \cdots \overbrace{\left(\cdots a_1^{\prime \dag} \cdots\right)}^{P^\dag_y} \cdots}_{P^\dag} \\
= &\left(\cdots\right)\cdots \left(\cdots a'_1 a'_0 a_0^{\prime \dag} \cdots\right) \cdots \left(\cdots a_1^{\prime \dag} \cdots\right)\cdots \\
= &\left(\cdots\right)\cdots \left(\cdots a'_1 \cdots\right) \cdots \left(\cdots a'_0 a_0^{\prime \dag} a_1^{\prime \dag} \cdots\right)\cdots \\
= &\left(\cdots\right)\cdots \left(\cdots a'_1 \cdots\right) \cdots \left(\cdots a'_0 \cdots\right)\cdots (a_0^{\prime \dag} a_1^{\prime \dag}) .
\end{aligned}
\end{equation}
可见所有的虚拟边的共轭，都可以看作正常的费米子张量的费米箭头进行了翻转。

类似的，对于物理边，考虑每一个元素，我们一样可以将 $M^\dag$ 中的算符向后一定：
\begin{equation}
\begin{aligned}
&\overbrace{\left(\cdots (c a') \cdots\right)}^{M^\dag}
\underbrace{\cdots \overbrace{\left(\cdots a'^\dag \cdots\right)}^{P^\dag_n} \cdots}_{P^\dag} \\
= &\left(\cdots\right) \cdots \left(\cdots c a' a'^\dag \cdots\right) \cdots \\
= &\left(\cdots\right) \cdots \left(\cdots a' a'^\dag c \cdots\right) \cdots \\
= &\left(\cdots\right) \cdots \left(\cdots a' \cdots\right) \cdots (a'^\dag c) .
\end{aligned}
\end{equation}
而 $(a'^\dag c)$ 最终将和原空间中的 $(a^\dag c^\dag)$ 组合， 恢复张量网络的求和的形式，相关项目为：
\begin{equation}
\begin{aligned}
\sum_{d'} a'^{\dag {d'}} c^{d'} \sum_d a^{\dag d} c^{\dag d}
&= \sum_{d d'} a^{\dag d} a'^{\dag {d'}} c^{d'} c^{\dag d} \\
&= \sum_{d d'} a^{\dag d} a'^{\dag d'} \delta_{d d'} \\
&= \sum_{d} a^{\dag d} a'^{\dag d} .
\end{aligned}
\end{equation}
这意味这，我们可以简单地认为物理的产生算符在表示整个 $\langle \Psi_1 | O | \Psi_2 \rangle$ 的张量网络中是一个普通的边，
他对应的纠缠对中的产生算副靠前，而类似的，共轭空间中的湮灭算符在纠缠对中靠后。
这样不必再像公式 [[eqref:eq:投影纠缠对构造的一般张量网络]] 中的 $M$ 那样将物理边和虚拟边分开对待。

综上所述，当我们对一个费米子张量进行共轭时，我们需要
1. 对每个元素取共轭；
2. 加上一个全转置的符号 $(-1)^{\sum_{j<k} p(a_j^{i_j}) p(a_k^{i_k})}$ ；
3. 将所有的费米箭头翻转。

*** 翻转费米箭头

费米箭头用于表示纠缠对中产生算符的顺序，而调换产生算符的顺序常用于其他运算的预处理中。
考虑两个投影子以及母态中的纠缠对产生算符：
\begin{equation}
\begin{aligned}
P M =
&(A_n)_{i_{0} i_{1} \cdots} a_0^{i_0} a_1^{i_1} \cdots \\
&(B_n)_{j_{0} j_{1} \cdots} b_0^{j_0} b_1^{j_1} \cdots \\
& a_x^{\dag d} b_y^{\dag d} ,
\end{aligned}
\end{equation}
其中 $A$ 的第 $x$ 个边与 $B$ 的第 $y$ 个边相连，
交换纠缠对中的两个产生算符得到
\begin{equation}
\begin{aligned}
P M =
&(A_n)_{i_{0} i_{1} \cdots} a_0^{i_0} a_1^{i_1} \cdots \\
&(B_n)_{j_{0} j_{1} \cdots} b_0^{j_0} b_1^{j_1} \cdots \\
& (-1)^{p(a_x^{\dag d}) p(b_y^{\dag d})} b_y^{\dag d} a_x^{\dag d} .
\end{aligned}
\end{equation}
可见当我们翻转两个张量彼此相连的边上的费米箭头时，只产生了一个符号，
不妨将他放置在 $A$ 中，得到：
\begin{equation}
\begin{aligned}
P M =
& (-1)^{p(a_x^{i_x})} (A_n)_{i_{0} i_{1} \cdots} a_0^{i_0} a_1^{i_1} \cdots \\
&(B_n)_{j_{0} j_{1} \cdots} b_0^{j_0} b_1^{j_1} \cdots \\
& b_y^{\dag d} a_x^{\dag d} ,
\end{aligned}
\end{equation}
其中我们用到了
\begin{equation}\label{eq:翻转箭头时的符号推导}
\begin{aligned}
p(a_x^{\dag d}) p(b_y^{\dag d}) &= p(a_x^{\dag d}) ^ 2 \\
&= p(a_x^{\dag d}) \\
&= p(a_x^{i_x}) .
\end{aligned}
\end{equation}
公式 [[eqref:eq:翻转箭头时的符号推导]] 中第一行的等式来自纠缠对中两个粒子拥有相同的费米子奇偶性；
第二行的等式来自对于任意 $a$ ， $p(a)$ 取 $0$ 或者 $1$ ；
第三行的等式来自于整个张量网络中在 $a_x$ 这个粒子的子空间上的分量为
\begin{equation}
\langle \Omega | a^{i_x} a_x^{\dag d} |\Omega\rangle = \delta_{i_x, d} ,
\end{equation}
从而 $i_x \neq d$ 时，张量网络整体都为 $0$ 的事实。

类似的，我们也可以将符号放置在 $B$ 中，从而得到：
\begin{equation}
\begin{aligned}
P M =
& (A_n)_{i_{0} i_{1} \cdots} a_0^{i_0} a_1^{i_1} \cdots \\
& (-1)^{p(b_y^{j_y})}(B_n)_{j_{0} j_{1} \cdots} b_0^{j_0} b_1^{j_1} \cdots \\
& b_y^{\dag d} a_x^{\dag d} .
\end{aligned}
\end{equation}
在实现费米子张量时，我们需要注意在一个网络内翻转费米箭头时，只能会产生一个符号，需要选择放在相连接的两个张量中的哪一个内。
而对于复数张量，我们完全可以产生半个符号即：
\begin{equation}
\begin{aligned}
P M =
& \mathrm{i}^{p(a_x^{i_x})} (A_n)_{i_{0} i_{1} \cdots} a_0^{i_0} a_1^{i_1} \cdots \\
& \mathrm{i}^{p(b_y^{j_y})}(B_n)_{j_{0} j_{1} \cdots} b_0^{j_0} b_1^{j_1} \cdots \\
& b_y^{\dag d} a_x^{\dag d} .
\end{aligned}
\end{equation}

*** 边的合并与拆分

对于寻常张量，边的合并与拆分是很常见的，比如将矩阵视为一个向量，实际上就是将二阶张量的两个边合并为一个边的过程。
对于寻常的稠密张量，边的合并与拆分并不需要真正的数据移动或变换，但是对于对称性张量来说，数据移动是不可避免的。
假设相邻的两个边，其对称群表示分别是 $(s_0^0, s_0^1, \cdots s_0^{d_0-1})$ 和 $(s_1^0, s_1^1, \cdots s_1^{d_1-1})$ ，
其中 $d_0$ 和 $d_1$ 分别是两个边的总维度。
合并成一个边后，群表示为：
\begin{equation}
\begin{aligned}
( &S(s_0^0, s_1^0), S(s_0^0, s_1^1), \cdots S(s_0^0, s_1^{d_1-1}), \\
  &S(s_0^1, s_1^0), S(s_0^1, s_1^1), \cdots S(s_0^1, s_1^{d_1-1}), \\
  &\cdots \\
  &S(s_0^{d_0-1}, s_1^0), S(s_0^{d_0-1}, s_1^{d_0-1}), \cdots S(s_0^{d_0-1}, s_1^{d_1-1})) ,
\end{aligned}
\end{equation}
其中 $S$ 满足：
\begin{equation}
U_g^{s_0} U_g^{s_1} = U_g^{S(s_0, s_1)} , \forall g \in G .
\end{equation}

不难看出，对于 $Z(2)$ 群来说，群表示使用 $0$ 和 $1$ 标记， $S$ 则是布尔异或运算，其构成了表示空间上的 $Z(2)$ 群；
而对于 $U(1)$ 群来说，群表示使用整数标记， $S$ 则是整数加法运算，其构成了表示空间上的 $Z$ 群。
对于更加复杂的Abel群，群表示空间为子群的群表示空间的乘积，
我们可以直接使用子群们的表示空间群的乘积来得到自己的表示空间群，从而得到 $S$ 运算。
当我们得到合并后的边的对称群表示后，我们通常需要再交换各个维度，将相同对称群表示的维度放在一起，从而保证张量的分块数目尽可能地少。

而对于费米子张量，边上的对称群表示需要按照对称性张量的规则做变换外，纠缠对也需要进行变换。
仍然以合并两个相邻的边为例，考虑：
\begin{equation}
\begin{aligned}
P M =
&(A_n)_{i_{0} i_{1} \cdots} \left(\cdots a_x^{i_x} a_{x+1}^{i_{x+1}} \cdots\right)\\
&(B_n)_{j_{0} j_{1} \cdots} \left(\cdots b_y^{j_y} b_{y+1}^{j_{y+1}} \cdots\right) \\
&\left( a_x^{\dag d_0} b_y^{\dag d_0} \right) \left( a_{x+1}^{\dag d_1} b_{y+1}^{\dag d_1} \right) ,
\end{aligned}
\end{equation}
当我们合并边时，纠缠对也需要合并，得到：
\begin{equation}
\begin{aligned}
P M =
&(A_n)_{i_{0} i_{1} \cdots} \left(\cdots a_x^{i_x} a_{x+1}^{i_{x+1}} \cdots\right)\\
&(B_n)_{j_{0} j_{1} \cdots} \left(\cdots b_y^{j_y} b_{y+1}^{j_{y+1}} \cdots\right) \\
&
(-1)^{p(b_y^{d_0}) p(b_{y+1}^{d_1})}
(a_x^{d_0}a_{x+1}^{d_1})^\dag
(b_y^{d_0} b_{y+1}^{d_1})^\dag
.
\end{aligned}
\end{equation}
类似翻转费米箭头的情况，我们可以选择将产生的单个符号放在 $A$ 中或者 $B$ 中：
\begin{equation}
\begin{aligned}
PM=
&
(-1)^{p(a_x^{i_x}) p(a_{x+1}^{i_{x+1}})}
(A_n)_{i_{0} i_{1} \cdots} \left(\cdots a_x^{i_x} a_{x+1}^{i_{x+1}} \cdots\right)\\
&
(B_n)_{j_{0} j_{1} \cdots} \left(\cdots b_y^{j_y} b_{y+1}^{j_{y+1}} \cdots\right) \\
&
(a_x^{d_0}a_{x+1}^{d_1})^\dag
(b_y^{d_0} b_{y+1}^{d_1})^\dag
,
\end{aligned}
\end{equation}
或者
\begin{equation}
\begin{aligned}
PM=
&(A_n)_{i_{0} i_{1} \cdots} \left(\cdots a_x^{i_x} a_{x+1}^{i_{x+1}} \cdots\right)\\
&
(-1)^{p(b_y^{j_y}) p(b_{y+1}^{j_{y+1}})}
(B_n)_{j_{0} j_{1} \cdots} \left(\cdots b_y^{j_y} b_{y+1}^{j_{y+1}} \cdots\right) \\
&
(a_x^{d_0}a_{x+1}^{d_1})^\dag
(b_y^{d_0} b_{y+1}^{d_1})^\dag
.
\end{aligned}
\end{equation}

如果要合并并非相连的两个边，需要进行张量的转置，
而如果要合并费米箭头不一致的两个边，需要先对费米箭头进行翻转。
容易验证，对于合并连续的 $l$ 个边，其产生的符号等于这些合并的边的全转置产生的符号：
\begin{equation}
\begin{aligned}
PM=
&
(-1)^{\sum_{m<n} p(a_m^{i_m}) p(a_n^{i_n})}
(A_n)_{i_{0} i_{1} \cdots} \left(\cdots a_x^{i_x} a_{x+1}^{i_{x+1}} \cdots a_{x+l-1}^{i_{x+l-1}} \cdots\right)\\
&
(B_n)_{j_{0} j_{1} \cdots} \left(\cdots b_y^{j_y} b_{y+1}^{j_{y+1}} \cdots b_{y+l-1}^{j_{y+l-1}} \cdots\right) \\
&
(a_x^{d_0}a_{x+1}^{d_1}\cdots a_{x+l-1}^{d_{l-1}})^\dag
(b_y^{d_0} b_{y+1}^{d_1}\cdots b_{y+l-1}^{d_{l-1}})^\dag
,
\end{aligned}
\end{equation}
或者
\begin{equation}
\begin{aligned}
PM=
&
(A_n)_{i_{0} i_{1} \cdots} \left(\cdots a_x^{i_x} a_{x+1}^{i_{x+1}} \cdots a_{x+l-1}^{i_{x+l-1}} \cdots\right)\\
&
(-1)^{\sum_{m<n} p(b_m^{j_m}) p(b_n^{j_n})}
(B_n)_{j_{0} j_{1} \cdots} \left(\cdots b_y^{j_y} b_{y+1}^{j_{y+1}} \cdots b_{y+l-1}^{j_{y+l-1}} \cdots\right) \\
&
(a_x^{d_0}a_{x+1}^{d_1}\cdots a_{x+l-1}^{d_{l-1}})^\dag
(b_y^{d_0} b_{y+1}^{d_1}\cdots b_{y+l-1}^{d_{l-1}})^\dag
,
\end{aligned}
\end{equation}


值得一提的是，这些产生算符组合而来的复合粒子产生算符依然可以作为张量网络中的纠缠对，因为依然有
\begin{equation}
(b_y^{d'_0} b_{y+1}^{d'_1}\cdots b_{y+l-1}^{d'_{l-1}})
(b_y^{d_0} b_{y+1}^{d_1}\cdots b_{y+l-1}^{d_{l-1}})^\dag
=
\delta_{d_0 d'_0}
\delta_{d_1 d'_1}
\cdots
\delta_{d_{l-1} d'_{l-1}}
\end{equation}

在计算 $\sum_{m<n} p_m p_n$ 原本的两层循环可以使用一个技巧压缩为一层循环：
\begin{equation}
\begin{aligned}
\sum_{m<n} p_m p_n
&= \frac{\sum_{m,n} p_m p_n - \sum_{n} p_n^2}{2} \\
&= \frac{(\sum_{n} p_n)^2 - \sum_{n} p_n}{2} .
\end{aligned}
\end{equation}
由于他出现在 $-1$ 的指数上，我们只关注他的二进制第一位，即只关注$(\sum_{n} p_n)^2 - \sum_{n} p_n$ 的二进制第二位，
而对于任意 $x$ ， $x^2 - x$ 的二进制第二位和 $x$ 的二进制第二位相同，所以
\begin{equation}
(-1)^{\sum_{m<n} p_m p_n}
=
(-1)^{ \frac{2 \& \sum_n{p_n} }{ 2 }} ,
\end{equation}
其中 $\&$ 为按位与。

对于边的拆分，由于他是边的合并的逆运算，其产生的符号和边的合并产生的符号完全一样。

*** 张量的收缩

张量的收缩即将两个相连的张量的公共边的所有维度进行求和。
为了收缩两个费米子张量，我们可以按照合并边、做含有费米子的矩阵乘法，拆分边的思路来实现费米子张量的收缩。
接下来，我们介绍一种具体的方案。

对于两个费米子张量 $A$ 和 $B$ ，他们的边分为两组，即公共边和自由边：公共边连接了彼此，而其他边都是自由边。为了进行收缩，我们依次做：
+ 张量转置：将 $A$ 中所有的自由边放置在左侧，公共边放置在右侧，而 $B$ 中所有的公共边放置在左侧，自由边放置在右侧。
+ 翻转费米箭头：
  将 $A$ 中所有自由边的费米箭头翻转到位置 $0$ ，如果产生符号，则符号不放在本张量中；
  将 $A$ 中所有公共边的费米箭头翻转到位置 $1$ ，如果产生符号，则符号放在本张量中；
  将 $B$ 中所有自由边的费米箭头翻转到位置 $0$ ，如果产生符号，则符号不放在本张量中；
  将 $B$ 中所有公共边的费米箭头翻转到位置 $0$ ，如果产生符号，则符号不放在本张量中。
+ 边的合并：合并 $A$ 和 $B$ 中所有的公共边和自由边， 得到
\begin{equation}
\left\{
\begin{aligned}
P_A &= A_{i_0 i_1} a_0^{i_0} a_1^{i_1} ,\\
P_B &= B_{j_0 j_1} b_0^{j_0} b_1^{j_1} ,\\
M &= b_0^{\dag d} a_1^{\dag d} ,
\end{aligned}
\right.
\end{equation}
  其中，
  $A$ 的自由边合并时如果产生符号，则不放在本张量中；
  $A$ 的公共边合并时如果产生符号，则放在本张量中；
  $B$ 的自由边合并时如果产生符号，则不放在本张量中；
  $B$ 的公共边合并时如果产生符号，则不放在本张量中；
+ 矩阵乘法：直接进行矩阵乘法：
\begin{equation}
\begin{aligned}
P_A P_B M
&=
A_{i_0 i_1}a_0^{i_0} a_1^{i_1}
B_{j_0 j_1}b_0^{j_0} b_1^{j_1}
b_0^{\dag d} a_1^{\dag d} \\
&=
A_{i_0 i_1}
B_{j_0 j_1}
\delta_{j_0 i_1}
a_0^{i_0}
b_1^{j_1}.
\end{aligned}
\end{equation}
+ 边的拆分：拆分剩下的两个自由边，恢复张量原本的形状，产生的符号一律不放在本张量中。
+ 翻转费米箭头：
  将费米箭头翻转到 $A$ 和 $B$ 中原本的位置，产生的符号一律不放在本张量中。

在这个方案中，公共边的合并与费米箭头翻转产生的符号都放且仅放在张量 $A$ 中了。
而对于自由边的合并与第一次费米箭头翻转，完全和自由边的拆分与第二次翻转相互抵消。
由此，我们可以将费米子的张量收缩转换成对称性矩阵的矩阵乘法，即分块的矩阵乘法。

*** 张量的分解

张量的分解即张量变形为矩阵后的矩阵分解，包括QR分解，奇异值分解等。
作为张量收缩的逆操作，我们完全可以讲张量收缩的方案倒过来，作为张量分解的方案，除了最中间的矩阵乘法，替换为矩阵分解。
下面我们介绍一种张量分解的方案。

对于矩阵 $A$ ，我们要将他分解为 $A = B \prod_{k=0}^{K-1} C_k D$ 。
对于奇异值分解，我们有
\begin{equation}
\left\{
\begin{aligned}
B &= U \\
D &= V \\
K &= 1 \\
C_0 &= S.
\end{aligned}
\right.
\end{equation}
对于QR分解，我们有
\begin{equation}
\left\{
\begin{aligned}
B &= Q \\
D &= R \\
K &= 0 .
\end{aligned}
\right.
\end{equation}
对于LQ分解，我们有
\begin{equation}
\left\{
\begin{aligned}
B &= L \\
D &= Q \\
K &= 0 .
\end{aligned}
\right.
\end{equation}
为了进行张量的分解，我们沿着反方向的矩阵收缩过程，依次做：
+ 张量转置：
  将 $A$ 中的各个边调整到合适的位置，即最终出现在 $B$ 中的边放在左侧，而最终出现在 $D$ 中的边放在右侧。
+ 翻转费米箭头：
  讲张量 $A$ 中所有的费米箭头翻转到位置 $0$ ，如果产生了符号，则符号不放置在张量中。
+ 边的合并：
  将 $A$ 中所有最终出现在 $B$ 中的边合并成一个边，而最终出现在 $D$ 中的边合并成另一个边，如果产生了符号，则符号不放置在张量中。
+ 矩阵分解：直接进行矩阵分解：
\begin{equation}
\begin{aligned}
A_{i_0 i_1} a_0^{i_0} a_1^{i_1} =
&\left( B_{i_0 j_1} \prod_{j=0}^{K-1} C_{j_k, j_{k+1}} D_{j_K, i_1} \right) a_0^{i_0} a_1^{i_1}\\
=
&B_{i_0, j_0} a_0^{i_0} b_0^{j_0} \\
&\prod_{k=0}^{K-1} C_{j'_k, j_{k+1}} c_0^{j'_k} b_1^{j_{k+1}} \\
&D_{j'_{K}, i_1} c_K^{j'_K} a_1^{i_1} \\
&\prod_{k=0}^{K} c_k^{\dag d} b_k^{\dag d} .
\end{aligned}
\end{equation}
+ 边的拆分：拆分 $B$ 和 $D$ 中原先在 $A$ 中的边，恢复边原来的形状，如果产生了符号，则符号不放置在张量中。
+ 翻转费米箭头：将 $B$ 和 $D$ 中原先在 $A$ 中的边上的费米箭头翻转到原本的位置，如果产生了符号，则符号不放置在张量中。

类似张量的收缩，这种方法中，边的合并与第一次翻转费米箭头完全和边的拆分与第二次翻转费米箭头相互抵消。
而在矩阵分解的步骤中，在结果中选取合适的费米箭头，可以让计算成直接的分块张量分解，而没有任何其他的费米子性质。

*** 张量的迹

虽然大部分时候，求迹操作是多余的，但是求迹确实是一个基本操作。
为了对费米子张量进行求迹，我们可以将要求迹的两个边转置到相邻的位置上，并保证费米箭头为 $1$ 的边在费米箭头为 $0$ 的边的前方。
如此，对于将要对第 $x$ 个和第 $x+1$ 个边求迹的张量 $A$ ：
\begin{equation}
\def\a#1{a_{#1}^{i_{#1}}}
P_A = A_{i_0 i_1 \cdots i_{x-1} i_x i_{x+1} i_{x+2} \cdots} \a{0} \a{1} \cdots \a{x-1} \a{x} \a{x+1} \a{x+2} \cdots,
\end{equation}
我们可以得到
\begin{equation}
\def\a#1{a_{#1}^{i_{#1}}}
P_A \left(a_{x+1}^{\dag d} a_{x}^{\dag d} \right) = \left(\delta_{i_x i_{x+1}} A_{i_0 i_1 \cdots i_{x-1} i_{x} i_{x+1} i_{x+2}\cdots} \right) \a{0} \a{1} \cdots \a{x-1} \a{x+1} \cdots
\end{equation}
其中
\begin{equation}
\def\a#1{a_{#1}^{i_{#1}}}
\a{x} \a{x+1}a_{x+1}^{\dag d} a_{x}^{\dag d}
= \delta_{i_{x+1} d} \delta_{i_x d} = \delta_{i_x i_{x+1}} .
\end{equation}

*** 恒等张量

#+begin_export latex
\begin{figure}
\centering
\input{tikz/tensor-exp.tikz}
%\caption{张量指数的幂展开}
%\note{注：张量的指数由幂展开所定义。
\caption{张量指数的幂展开。张量的指数由幂展开所定义，
不同于矩阵，两个矩阵 $A$ 和 $B$ 相乘只有 $A B$ ，而张量相互收缩时，需要指定收缩时边的关系，即哪两个边应当彼此相连。
而幂展开中含有多个张量的收缩，所以在定义张量的指数时需要给定边之间的对应关系。
}
\label{fig:张量指数的幂展开}
\end{figure}
#+end_export

有时我们需要得到一个恒等的张量，比如在计算张量的指数时，需要通过进行幂展开：
\begin{equation}
\mathrm{e}^{A} = \sum_{n=0}^{\infty} \frac{1}{n!} A^n ,
\end{equation}
其中的 $A^0$ 为恒等张量， 而 $A^n, n>0$  为多个 $A$ 的收缩。
以一个四阶张量 $A$ 为例，其指数的图形标记如图 [[ref:fig:张量指数的幂展开]] 所示。

恒等的费米子张量需要保证讲其插入两个相连的张量中结果不变，即：
\begin{equation}\label{eq:恒等张量的定义}
(a^{\dag d} b^{\dag d}) = I (a^{\dag d} a^{\prime \dag d}) (b^{\prime \dag d} b^{\dag d}) ,
\end{equation}
易得：
\begin{equation}\label{eq:恒等张量的结果}
I = \delta_{i j} b^{\prime i} a^{\prime j} .
\end{equation}
这里 $(a^{\dag d} b^{\dag d})$ 为表示两个相连张量所连接的边的纠缠对，
当我们插入恒等费米子张量时，我们实际上将这个纠缠对切割成了两个纠缠对，然后使用恒等张量这个投影子对这两个纠缠对进行投影，其结果应当保持不变。

根据公式 [[eqref:eq:恒等张量的定义]] 和公式 [[eqref:eq:恒等张量的结果]] 所展示，
恒等的费米子张量在将费米箭头在位置 $0$ 处的边放置在费米箭头在位置 $1$ 处的边前方时，费米子张量内部的对称性张量正好是寻常的恒等张量。

** 对称性张量网络态和费米子张量网络态

根据
[[ref:sec::对称性张量和费米子张量]]
和
[[ref:sec::费米子张量上的张量操作]]
中的介绍，我们知道对称性张量和费米子张量与寻常的张量一样，可以进行各种张量运算，且与寻常的张量一样，无论是张量还是张量操作都可以随意交换顺序。
通过将一张张量网络态中的张量替换成对称性张量或者费米子张量，我们可以得到用于表示某个特定对称群下不变的波函数或者是费米子的波函数。

本章节中，张量分为寻常的张量，对称性张量和费米子张量，这是为了引入时的便利而划分的。
但这种分类并不合理，因为寻常的张量也可以看作是平凡群下的对称性张量，而费米子张量在不做各种张量操作时，也能体现对称性张量的性质。
现在更改一下不同张量类型的名称约定，这将应用于本论文的整个下文中。
无论是何种张量，都认为是对称性张量，而寻常的张量，则称作是平凡群下的对称性张量。
对称性张量根据纠缠对中，体现对称性的粒子是否存在费米子，分为费米子对称性张量和非费米子对称性张量。
为了简洁起见，费米子对称性张量也被称呼费米子张量，为非费米子张量也被称呼为玻色子对称性张量或者玻色子张量。

在第 [[sec:张量网络态算法]] 章我们将介绍与具体张量类型无关的各种张量网络态算法，其中提到的张量都指对称性张量。

* 张量网络态优化算法 <<sec:张量网络态算法>>

基于包括 {{{MPS}}} 和 {{{PEPS}}} 在内的 各种 {{{TNS}}} ，有多种计算方法以解决给定的量子多体系统。
本章节对一些 {{{TNS}}} 上的算法进行介绍，他们将被用于后续章节中。

** 虚时间演化算法

*** 严格波函数的虚时间演化算法

对于一个正定的矩阵，其最大本征值以及对应的本征态可以通过幂法迭代就得，即给定任意初始态 $x_0$ 后，使用
\begin{equation}\label{eq:幂法迭代}
x_{n} = M x_{n-1} , \quad n > 0,
\end{equation}
进行迭代， $x_n$ 随着 $n \to \infty$ 会收敛到最大本征值对应的本征态上。

这是因为使用 $M$ 的本征态 $e_i$ 做基对 $x_0$ 分解后，我们得到：
\begin{equation}
x_0 = e_i a_0^i,
\end{equation}
而矩阵 $M$ 分解得到：
\begin{equation}
M = e_i \lambda_i e_i^\dag,
\end{equation}
其中 $\lambda_i$ 为 $M$ 的本征值 ， $\lambda_0 > \lambda_1 > \lambda_2 > \cdots > 0$ 。
公式 [[eqref:eq:幂法迭代]] 写在此基下为：
\begin{equation}
\begin{aligned}
x_{n} &= e_i a_{n}^i \\
&= M x_{n} \\
&= e_{i'} \lambda_{i'} e_{i'}^\dag e_i a_{n-1}^i \\
&= e_{i'} \lambda_{i'} \delta_{i i'} a_{n-1}^i \\
&= e_{i} \lambda_{i} a_{n-1}^i \\
&= e_{i} \lambda_{i}^n a_0^i ,
\end{aligned}
\end{equation}
即 $a_{n}^i = \lambda_i ^{n} a_0^i$ 。
最大本征值对应的本征态分量相比于其他本征态，比值为：
\begin{equation}\label{eq:幂法的系数比值}
\frac{\lambda_0^n a_0^0}{\lambda_i^n a_0^i} = \left(\frac{\lambda_0}{\lambda_i}\right)^n \frac{a_0^0}{a_0^i} , \quad i>0,
\end{equation}
而 $\frac{\lambda_0}{\lambda_i} > 1$ ， 故 $n \to \infty$ 时，只要 $a_0^0 \neq 0$ ， 即初态含有最大本征值的分量，公式 [[eqref:eq:幂法的系数比值]] 会趋向无穷大，可见最后将收敛到最大本征值对应的本征态。

对于 {{{Hamiltonian}}} 为 $H$ 的系统，为了求得基态，可以使用 $M = \mathrm{e}^{- \tau H}$ 作为幂法中的矩阵进行迭代， 其中 $\tau > 0$ 。
$H$ 的本征值为 $\varepsilon_i$ ， $\varepsilon_0 < \varepsilon_1 < \varepsilon_2 < \cdots$ ，则 $M$ 的本征值为
$\lambda_i = \mathrm{e}^{- \tau \varepsilon_i}$ , $\lambda_0 > \lambda_1 > \lambda_2 > \cdots > 0$ 。
所以使用 $\mathrm{e}^{-\tau H}$ 迭代后，可以得到系统的基态，即：
\begin{equation}\label{eq:幂法虚时间演化}
\lim_{n\to\infty} \mathrm{e}^{-n\tau H} |\psi^0\rangle = |\psi^*\rangle ,
\end{equation}
其中 $| \psi^0 \rangle$ 为任意不和基态完全正交的初态， $|\psi^*\rangle$ 为基态。

如果将系统的无穷温时的密度矩阵 $\rho^0 = I$ 置入初态的位置，则迭代 $n$ 步后为：
\begin{equation}
\rho^n = \mathrm{e}^{-n \tau H} I = \mathrm{e}^{-\beta H} ,
\end{equation}
其中 $\beta = n \tau$ 。
而这便是系统温度为 $\frac{1}{\beta}$ 时的密度矩阵，可见，虚时间演化算法可以看成对系统的降温过程。

*** 逐块虚时间演化算法

严格的虚时间演化算法实际上就是严格对角化，只能计算粒子数最多约 30 的系统，对于更大的系统，态空间的维度指数上升，无法严格表示波函数。
对于一维只有近邻相互作用的系统，表示为 {{{MPS}}} 后，可以使用逐块虚时演化算法求得基态。

对于哈密顿量 $H = H_0 + H_1 + \cdots H_{N-1}$ ，虚时间演化的演化算符是
\begin{equation}\label{eq:多项的Hamiltonian演化算符}
U = \mathrm{e}^{-\tau (H_0 + H_1 + \cdots H_{N-1})}.
\end{equation}
我们希望可以将其化为多个局部的演化算符作用的乘积，类似：
\begin{equation}
\def\expH#1{\mathrm{e}^{-\tau H_{#1}}}
U = \expH{0} \expH{1} \cdots \expH{N-1},
\end{equation}
然而由于各个 $H_n$ 之间彼此不对易，矩阵指数无法直接拆开。
为了解决这个问题，我们需要使用矩阵指数的Trotter展开。

Trotter展开将矩阵和的指数变为矩阵指数的乘积。
对于矩阵 $M = M_0 + M_1$ ，考虑指数展开：
\begin{equation}
\left\{
\begin{aligned}
\mathrm{e}^{x M} &= I + x M + O (x^2), \\
\mathrm{e}^{x M_0} \mathrm{e}^{x M_1} & = (I + x M_0 + O(x^2)) (I + x M_1 + O(x^2)) ,
\end{aligned}
\right.
\end{equation}
展开得到：
\begin{equation}
\left\{
\begin{aligned}
\mathrm{e}^{x M} &= I + x (M_0 + M_1) + O (x^2), \\
\mathrm{e}^{x M_0} \mathrm{e}^{x M_1} & = I + x (M_0 + M_1) + O(x^2) ,
\end{aligned}
\right.
\end{equation}
所以我们有：
\begin{equation}
\mathrm{e}^{x (M_0 + M_1)} = \mathrm{e}^{x M_0} \mathrm{e}^{x M_1} + O(x^2),
\end{equation}
这便是一阶的Trotter展开。

而为了让误差更小，我们可以利用二阶的Trotter展开。考虑指数展开：
\begin{equation}
\left\{
\begin{aligned}
\mathrm{e}^{x M}
= &I + x M + \frac{1}{2} x^2 M^2 + O (x^3), \\
\mathrm{e}^{\frac{x}{2} M_0} \mathrm{e}^{x M_1} \mathrm{e}^{\frac{x}{2} M_0}
 =
&(I + \frac{1}{2} x M_0 + \frac{1}{8} x^2 M_0^2 + O(x^3)) \\
&(I + x M_1 + \frac{1}{2} x^2 M_1^2 + O(x^3))\\
&(I + \frac{1}{2} x M_0 + \frac{1}{8} x^2 M_0^2 + O(x^3))
,
\end{aligned}
\right.
\end{equation}
展开得到：
\begin{equation}
\left\{
\begin{aligned}
\mathrm{e}^{x M}                                                             = &I + x (M_0 + M_1) + \\
                                                                               &\frac{1}{2} x^2 (M_0^2 + M_1^2 + M_0 M_1 + M_1 M_0) + O (x^3), \\
\mathrm{e}^{\frac{x}{2} M_0} \mathrm{e}^{x M_1} \mathrm{e}^{\frac{x}{2} M_0} = &I + x (M_0 + M_1) + \\
                                                                               &\frac{1}{2} x^2 (M_0^2 + M_1^2 + M_0 M_1 + M_1 M_0) + O (x^3),
\end{aligned}
\right.
\end{equation}
所以我们有：
\begin{equation}
\mathrm{e}^{x (M_0 + M_1)} = \mathrm{e}^{\frac{x}{2} M_0} \mathrm{e}^{x M_1} \mathrm{e}^{\frac{x}{2} M_0}+ O(x^3),
\end{equation}
这便是二阶的Trotter展开。

对于多个矩阵相乘的情况， $M=M_0 + M_1 + \cdots M_{N-1}$ ，连续使用二阶的Trotter展开可得：
\begin{equation}\label{eq:多项求和的Trotter展开}
\begin{aligned}
\mathrm{e}^{x (M_0 + M_1 + \cdots M_{N-1})}
=&\mathrm{e}^{\frac{x}{2} M_0} \mathrm{e}^{x (M_1 + M_2 + \cdots M_{N-1})} \mathrm{e}^{\frac{x}{2} M_0}+ O(x^3) \\
=&\mathrm{e}^{\frac{x}{2} M_0}(
\mathrm{e}^{\frac{x}{2} M_1}
\mathrm{e}^{x (M_2 + M_3 + \cdots M_{N-1})}
\mathrm{e}^{\frac{x}{2} M_1} + O(x^3))
\mathrm{e}^{\frac{x}{2} M_0}
+O(x^3) \\
=&\cdots \\
=&\mathrm{e}^{\frac{x}{2} M_0}
\mathrm{e}^{\frac{x}{2} M_1}
\cdots
\mathrm{e}^{\frac{x}{2} M_{N-2}}
\mathrm{e}^{\frac{x}{2} M_{N-1}} \\
&
\mathrm{e}^{\frac{x}{2} M_{N-1}}
\mathrm{e}^{\frac{x}{2} M_{N-2}}
\cdots
\mathrm{e}^{\frac{x}{2} M_1}
\mathrm{e}^{\frac{x}{2} M_0}
+O(N x^3), \\
\end{aligned}
\end{equation}
将公式 [[eqref:eq:多项的Hamiltonian演化算符]] 代入公式 [[eqref:eq:多项求和的Trotter展开]] ，我们可以得到：
\begin{equation}\label{eq:逐块虚时间演化算法的最终公式}
\begin{aligned}
U
=&\mathrm{e}^{-\tau (H_0 + H_1 + \cdots H_{N-1})} \\
=&\mathrm{e}^{\frac{-\tau}{2} H_0}
\mathrm{e}^{\frac{-\tau}{2} H_1}
\cdots
\mathrm{e}^{\frac{-\tau}{2} H_{N-2}}
\mathrm{e}^{\frac{-\tau}{2} H_{N-1}} \\
&
\mathrm{e}^{\frac{-\tau}{2} H_{N-1}}
\mathrm{e}^{\frac{-\tau}{2} H_{N-2}}
\cdots
\mathrm{e}^{\frac{-\tau}{2} H_1}
\mathrm{e}^{\frac{-\tau}{2} H_0}
+O(N \tau^3). \\
\end{aligned}
\end{equation}
公式 [[eqref:eq:逐块虚时间演化算法的最终公式]] 即为逐块虚时间演化算法的核心公式。

{{{MPS}}} 上进行逐块虚时间演化时，每次仅需要在原有的 {{{MPS}}} 上作用 $U_i=\mathrm{e}^{\frac{-\tau}{2}H_i}$ ，这个 由于其位置与量子计算中的线路门一样， $U_i$ 演化算符有时也被称作门张量。
如图 [[ref:fig:朴素的itebd]] (a)，对于仅有近邻相互作用的系统，所有的 $U_i$ 只会作用在两个相邻的张量上，标记为第 $x$ 个张量和第 $y$ 个张量， 这里  $y=x+1$ 。
我们可以直接收缩 $U_i$ 以及第 $x$ 个张量 $A_x$ 和 第 $y$ 个张量 $A_y$ ，得到一个大张量 $U_i A_x A_y$ ，如图 [[ref:fig:朴素的itebd]] (b)。
随后，为了恢复 {{{MPS}}} 的形式，我们需要对收缩后的四阶张量进行分解，进行SVD分解后， {{{MPS}}} 变为图 [[ref:fig:朴素的itebd]] (c) 中的结构。
最后，将多余的奇异值矩阵 $s$ 收缩到左侧的 $u$ 张量或者右侧的 $v$ 张量中，从而完全恢复{{{MPS}}}的形式，即图 [[ref:fig:朴素的itebd]] (d)。

#+begin_export latex
\begin{figure}
\centering
\input{tikz/trivial_itebd.tikz}
%\caption{矩阵乘积态上朴素的逐块虚时间演化}
%\note{注：(a) 作用在 $A_x$ 和 $A_y$ 上的 $U_i$ ； (b) 收缩三个张量 ；(c) 对收缩后的张量进行SVD分解；  (c) 收缩奇异值张量，恢复矩阵乘积态的形式。
\caption{矩阵乘积态上朴素的逐块虚时间演化。 (a) 作用在 $A_x$ 和 $A_y$ 上的 $U_i$ ； (b) 收缩三个张量 ；(c) 对收缩后的张量进行SVD分解；  (c) 收缩奇异值张量，恢复矩阵乘积态的形式。
}
\label{fig:朴素的itebd}
\end{figure}
#+end_export

作用上 $U_i$ 后， 分解后得到的 $A'_x$ 和 $A'_y$ 张量之间的指标的维度从原来的 $D$ 上升至 $Dd$ ，这使得演化过程不可持续。
为此，我们可以舍弃SVD得到的奇异值矩阵中较小的奇异值，仅保留最大的 $D$ 个奇异值，从而保证经过以此 $U_i$ 演化后，{{{MPS}}} 的所有指标的维度不变。

SVD后舍弃小的奇异值，是低秩近似的实现。
对于 $m \times n$ 的矩阵 $A$ ，进行SVD分解得到 $A = U S V^T$ ，那么 $A_k = \sum_{i=1}^{k} S_i U_i V_i^T$ 是秩为 $k$ 的矩阵中，希尔伯特-施密特范数下，最接近 $A$ 的矩阵。
而希尔伯特-施密特范数是将矩阵向量化后的 $2$ 范数， {{{MPS}}} 中，张量的组合最后会得到希尔伯特空间中的向量，因而我们应当在这里考虑希尔伯特-施密特范数。
具体的证明如下，令 $\sigma_i (A)$ 为 $A$ 的第 $i$ 个奇异值。
易得，$|A-A_k|^2=\sum_{i=k+1}^{n} \sigma_i(A)$ ，这里不妨设 $m \le n$ 。
由于 $\sigma_1$ 本身可以作为矩阵的谱范数，对于 $B=B' + B''$ ， 我们有 $\sigma_1(B) \le \sigma_1(B') + \sigma_1(B'')$ 。
而对于任意 $i$ 和 $j$ ，有
\begin{equation}
\begin{aligned}
\sigma_i(B') + \sigma_j(B'')
&= \sigma_1(B' - B'_{i-1}) + \sigma_1(B''-B''_{j-1}) \\
&\ge \sigma_1(B - B'_{i-1} - B''_{j-1}) \\
&\ge \sigma_1(B - B_{i+j-2}) \\
&= \sigma_{i+j-1}(B) .
\end{aligned}
\end{equation}
由于任意秩为 $k$ 的矩阵 $C$ ，有 $\sigma_{k+1}(C) = 0$ ，我们有 $\sigma_i(A-C) + \sigma_{k+1}(C) = \sigma_i(A-C) \ge \sigma_{k+i}(A)$ 。
故, $|A-C|^2 = \sum_{i=1}^{n} \sigma_i(A-C)^2 \ge \sum_{i=k+1}^{n}\sigma_i(A)^2 = |A-A_k|^2$ 。
即 $A_k$ 是秩为 $k$ 的矩阵中最接近 $A$ 的矩阵。

在进行低秩近似时，矩阵两侧插入酉矩阵不影响近似的结果，所以我们在 {{{MPS}}} 中进行SVD前，如果能保证两侧的整体为酉矩阵，那么SVD的近似不仅是当前两个张量的低秩近似，而且还是整个 {{{MPS}}} 的低秩近似。
实际操作过程中，例如正在将演化算子作用在相邻的格点 $x$ 和 $y$ 时，其中 $x+1=y$ ，可以自 $i=0$ 开始，对格点张量进行 QR 分解， $Q$ 张量保留物理指标和左侧指标，$R$ 保留右侧指标。
随后$R$ 张量向第 $i+1$ 个格点处的张量收缩，由于 QR 分解产生的指标维度为 $Q$ 和 $R$ 保留指标维度的最小值， 而 $R$ 右侧指标维度为 {{{MPS}}} 自身的截断 $D$ ，进行一步这样的操作后，没有破坏 {{{MPS}}} 的形式和维度截断。
随后 令 $i=1$ ，执行相同的操作，QR分解并把 $R$ 张量向右收缩。
一直迭代到 $i=x-1$ ，此时对于所有的 $i<x$ ， $i$ 处的格点张量都是酉的。
类似的，再令 $j=L-1$ ，从右向左迭代地进行LQ分解并将 $L$ 向左收缩，最后 所有 $j>y$ ， $j$ 处的格点张量也都是酉的。
这种 {{{MPS}}} 的形式被称为正则形式。
对于只有近邻相互作用的系统， 公式 [[eqref:eq:逐块虚时间演化算法的最终公式]] 中， 我们可以调整作用的顺序，使得连续作用的两个演化算符总是有共同格点的，
比如 $H_0$ 作用在第 $0$ 和 第 $1$ 个格点， $H_1$ 作用在第 $1$ 和 第 $2$ 个格点，他们有共同的第 $1$ 个格点。
当我们在为了作用 $H_i$ 算子而将 {{{MPS}}} 转变为正则系统，当前算子收缩上两个格点后并SVD分解得到三个张量时，我们可以直接将截断后的奇异值矩阵向下一次演化算符将要作用的两个近邻格点之一上收缩，从而保证下次作用时， {{{MPS}}} 依然是正则形式。

*** 简单更新算法 <<sec:::简单更新>>

逐块虚时间演化算法中，主要误差来源于SVD分解时的低秩近似。
虽然一维的情况下，保证更新时两侧的环境都为酉可以使得单步近似达到最优，但是对于二维系统来说，我们无法将环境通过简单的变换转化为酉的。

对于 {{{MPS}}} 的一维张量链，除了通过QR分解和LQ分解保证的正则形式，还有一种 $\Gamma-\Lambda$ 的正则形式 [[cite:Vidal2003]] 。
其在公式 [[eqref:eq:一维系统波函数的MPS展开]] 中每两个 $A$ 中插入一个对角矩阵 $\Lambda$ ，并记 $A$ 为 $\Gamma$ ，得到
\begin{equation}
T^{\sigma_0,\sigma_1,\cdots,\sigma_{L-1}} =
(\Gamma_0 ^ {\sigma_0})_{v_1} (\Lambda_0)_{v_1}
(\Gamma_1 ^ {\sigma_1})_{v_1 v_2} (\Lambda_1)_{v_2}
(\Gamma_2 ^ {\sigma_2})_{v_2 v_3} (\Lambda_2)_{v_3}
\cdots (\Gamma_{L-1} ^ {\sigma_{N-1}})_{v_{N-1}} ,
\end{equation}
对于每个对角矩阵 $\Lambda_i$ ，其左侧和右侧整体都是酉的。
这种 $\Gamma-\Lambda$ 形式可以直接通过一般的 {{{MPS}}} 进行多次SVD得到。
在这种形式的 {{{MPS}}} 上进行逐块虚时间演化时，作用在 $\Gamma_x$ 和 $\Gamma_{y}$ 两个格点上的演化算子，只需要收缩再 $\Lambda_{x-1}$, $\Lambda_{y}$ 以及这两个 $\Gamma$ 张量中间的 $\Lambda_{x}$ 即可保证系统其余部分都是酉的，从而能够使用SVD进行全局的低秩近似。
经过演化算符的作用，并进行SVD后依然可以保证当前两个格点的两侧是酉的。
而在其他格点看来，只是远处有两个的格点作用上了一个酉矩阵，依然不改变原来的酉的性质。

这种方法被推广为二维，被称为简单更新 [[cite:Jiang2008]] ，其可以以较少的代价获取仅有近邻相互作用的二维系统中接近基态的投影纠缠对态。
简单更新方案中，投影纠缠对态中每个相连的张量中间插入了一个对角矩阵，类比 $\Gamma-\Lambda$ 形式中的 $\Lambda$ ，通常被称为环境张量。

图 [[ref:fig:su]] (a1-a4) 展示了简单更新的步骤。
当演化两个相邻格点 $A$ 和 $B$ 时，首先将 $A$ 和 $B$ 周围的六个环境和之间的一个环境，一共七个环境张量收缩到一起，如图 图 [[ref:fig:su]] (a1)，并作用上演化算子得到张量 $C$  , 如图 [[ref:fig:su]] (a2)。
随后进行SVD分解，产生的奇异值矩阵作为 $A$ 和 $B$ 格点之间新的环境，如图 [[ref:fig:su]] (a3)。
而之前在 $A$ 和 $B$ 周围的六个被收缩过的环境通过让 SVD后得到的 $A'$ 和 $B'$ 收缩环境的逆来 恢复，从而维护了含有环境张量的投影纠缠对态的形式，如图 [[ref:fig:su]] (a4)。

图 [[ref:fig:su]] (b1-b4) 展示了一种改进的简单更新方案。
程序存储的数据中， 个点张量已经收缩过自身四周的所有环境了。
演化两个相邻格点 $A$ 和 $B$ 时，只需要收缩 $A$ 、  $B$ 和他们中间的环境张量的逆即可，如图 [[ref:fig:su]] (b1)。
作用上演化算子后，得到张量 $C$ ， 如图 [[ref:fig:su]] (b2) 。
这里的 $C$ 和标准的 {{{SU}}} 方法中的 $C$ 应当是相等的。
随后依然进行SVD，得到 $A$ 和 $B$ 中间新的环境张量 ，如图 [[ref:fig:su]] (b3)。
此时 $A$ 和 $B$ 只需要乘上新的环境变量即可恢复含有环境张量、但格点张量已经收缩过四周环境张量的投影纠缠对态的形式，如图 [[ref:fig:su]] (b4)。
这种方案在单步演化过程中，可以减少十次环境的收缩操作。

#+begin_export latex
\begin{figure}
\centering
\includegraphics[width=0.8\textwidth]{su-scheme.pdf}
%\caption{简单更新的步骤}
%\note{注：
\caption{简单更新的步骤。
简单更新优化过程的示意图中涉及两个张量，$A$ 和 $B$。绿色菱形代表环境张量，而黄色菱形代表其逆。圆圈表示张量网络中的节点。
在左侧面板中，传统的一步虚时间演化过程如下图所示：
(a1) 张量 $A$ 和 $B$ 与所有相关环境张量及时间演化门的收缩。
(a2) 由此收缩得到的张量 $C$。
(a3) 对步骤 (a2) 中的张量进行SVD分解得到的张量。
(a4) 通过与环境张量的逆（以黄色菱形表示）进行收缩，恢复为 (a1) 中的原始构型。
在右侧面板中，我们展示了一种改进的一步简单更新演化方案：
存储的张量 $A$ 和 $B$ 已经包含了必要的环境信息。
(b1) 张量 $A$、张量 $B$、他们之间的环境逆和时间演化门的收缩。
(b2) 步骤 (b1) 的结果，与传统方法的 (a2) 结果等效。
(b3) 通过对步骤 (b2) 中的张量进行SVD分解得到的结果张量，与传统方法中的 (a3) 等效。
(b4) 与新的环境（以绿色菱形表示）进行收缩，恢复步骤 (b1) 中的原始张量形式。这个方案比标准步骤节省了十次环境收缩操作。
}
\label{fig:su}
\end{figure}
#+end_export

** 采样方法 <<sec::各种采样方法>>

张量网络态可以有效表示服从面积定律的态函数，但是各种张量网络的优化算法难以得到精确的基态，而受限于虚拟指标的维度，严格计算包括能量在内的观测量也有着难以忍受的复杂度。
通过采样方法即蒙特卡罗方法，可以有效减少在张量网络态上计算观测量和能量时的计算复杂度 [[cite:Sandvik2007,Liu2017]] 。
传统上，我们通常使用马尔可夫链进行{{{Metropolis}}}采样，这种采样方法普适性强，但是采得的样本之间有有限关联，有效的样本数比实际样本数更少。
近年来，直接采样方法 [[cite:Vieijra2021]] 通过避免样本之间的关联而提高了采样的效率。
而自然梯度法 [[cite:Neuscamman2012]] 的引入则提高了优化的效率，使得 {{{PEPS}}} 上的变分蒙特卡罗方法不再依赖简单更新的结果作为初态，使得优化无法进行简单更新的长程关联系统称为可能。

*** 基于采样的观测量计算

对于观测量 $O$ ，我们可以将其分解为多项之和 $O = \sum_i O_i$ ，比如整体的 $z$ 方向自旋 $S_z = \sum_{i} S_z^i$ ，其中 $i$ 遍历所有的格点，而 $S_z^i$ 是 $i$ 格点处的自旋算符。
通常，量子多体系统很少涉及四体以上的相互作用，我们可以认为每个 $O_i$ 只作用在较少个格点上。
而无论是计算观测量，还是计算梯度，都可以看作计算单项 $O_i$ 或其梯度后，再计算简单的多项之和，所以不改变问题难度，本章的下文中， $O$ 仅代表观测量的一项。

使用 $O$ 对 $|\psi\rangle$ 进行测量时，观测量为 $\langle O \rangle=\frac{\langle \psi | O | \psi \rangle}{\langle \psi | \psi \rangle}$ 。
当 $|\psi\rangle$ 使用 {{{TNS}}} 作为 {{{Ansatz}}} 进行表示时，比如二维的{{{PEPS}}}，如果直接计算观测量，我们需要收缩双层的网络 $\langle \psi | O | \psi \rangle$ 。
如果使用边界MPO的近似方式，复杂度高达 $O(D^4 D_c^3 + d D^6 Dc^2)$  [[cite:Liu2017]] ，其中 $Dc$ 为边界MPO方法中的截断参数，通常 $D_c \propto D^2$。
而使用蒙特卡罗方法，可以避免双层网络的收缩。

蒙特卡罗方法中，首先对 $\langle O \rangle$ 进行变形，得到
\begin{equation}\label{eq:观测量变形}
\langle O \rangle=\frac{\sum_{s,s'}\langle \psi | s | O | s' | \psi \rangle}{\sum_{s}\langle \psi | s | \psi \rangle} , 
\end{equation}
其中 $s$ 和 $s'$ 是希尔伯特空间中对某个构型上的投影算子。
我们这里的表述与标准的变分蒙特卡罗算法有些不同，比如 我们写成 $\langle \psi | s | \psi \rangle$ 而不是 $\langle \psi | s\rangle \langle s|\psi \rangle$ 。
这是因为使用费米子张量作为波函数表示时，我们无法将 $\langle \psi | s \rangle$ 写成构型无关的复数，而是得到 $\langle \psi | s$ 作为一个费米子张量，他可以进一步和 $|\psi\rangle$ 收缩得到复数。

在公式 [[eqref:eq:观测量变形]] 中，有两个指标需要在整个希尔伯特空间中遍历，即 $s$ 和 $s'$ ，这是不可接受的，因为希尔伯特空间的大小高达 $d^N$ ，其中 $d$ 为单个物理指标的维度， $N$ 为物理指标的数目。
为了解决这个问题，使用蒙特卡罗方法进行采样 $s \sim S$ ，其中 $S$ 为用于采样的分布， $s$ 被采样的概率设为 $p_s$ 。
我们可以估计观测量为
\begin{equation}\label{eq:观测量采样}
\widehat{\langle O \rangle} = \frac{\sum_{s \sim S} \frac{\langle\psi|s|\psi\rangle}{p_s}\frac{\sum_{s'} \langle \psi | s | O | s' | \psi \rangle}{\langle\psi|s|\psi\rangle}}{\sum_{s \sim S} \frac{\langle \psi | s | \psi \rangle}{p_s}} .
\end{equation}

对观测量进行蒙特卡罗计算的时候，我们实际上是在进行多项分布的采样，令构型 $s$ 被采样到的次数为 $n_s$ ，则 $n_s \sim M(n, p_s)$  ，其中 $n$ 为总采样量。
记多项分布下， $X$ 的期望为 $\langle X \rangle_M$ 。
令 $q_s = \frac{n_s}{n}$ ，对于任意 $q_s-p_s$ 的函数 $F$ ，由于
$\langle q_s - p_s \rangle_M = 0$ 和 $\langle (q_s - p_s) (q_t - p_t) \rangle_M = \frac{\delta_{st} p_s - p_s p_t}{n}$ ，
而 对于 $k > 2$ ， $\langle (q_s-p_s)^k \rangle_M = O(1/n^2)$ ，
我们有
\begin{equation}\label{eq:多项分布期望}
\langle F(q_s-p_s) \rangle_M = F(0) + \frac{1}{2n} \sum_{st} (\delta_{st} p_s - p_s p_t) \frac{\partial^2 F}{\partial \delta_s \delta_t}(0) + O(1/n^2) ,
\end{equation}

令 $r_s = \frac{\langle \psi|s|\psi\rangle}{p_s}$， $O_s = \frac{\sum_{s'}\langle\psi|s|O|s'|\psi\rangle}{\langle\psi|s|\psi\rangle}$ ，
定义 $\langle X \rangle_p=\sum_{s}X_s p_s$ ，$\langle X \rangle_\psi = \frac{\langle X_s r_s \rangle_p}{\langle r_s \rangle_p}$ ，
记   $r'_s=\frac{r_s}{\langle r\rangle_p}$ 。
我们有观测量的严格表达式
\begin{equation}\label{eq:严格观测量}
\langle O \rangle = \frac{\sum_s p_s r_s O_s}{\sum_s p_s r_s} = \frac{\langle r O \rangle_p}{\langle r\rangle_p} = \langle O \rangle_\psi,
\end{equation}
而通过采样得到的观测量估计为
\begin{equation}\label{eq:采样观测量}
\widehat {\langle O \rangle} = \frac{\sum_s q_s r_s O_s}{\sum_s q_s r_s},
\end{equation}
这和真实的观测量不同。

将公式 [[eqref:eq:严格观测量]] 和公式 [[eqref:eq:采样观测量]] 的差值与差值平方代入公式 [[eqref:eq:多项分布期望]] ，我们得到
\begin{equation}\label{eq:采样的偏差和方差}
\left\{
\begin{aligned}
\langle \widehat {\langle O \rangle} - \langle O \rangle \rangle_M &= - \frac{1}{n}\langle ( O - \langle O \rangle_\psi ) (r' - \langle r' \rangle_\psi) \rangle_\psi + O(1/n^2), \\
\langle (\widehat {\langle O \rangle} - \langle O \rangle)^2 \rangle_M &= \frac{1}{n}\left\langle (O - \langle O \rangle_\psi)^2 r' \right\rangle_\psi + O(1/n^2).
\end{aligned}
\right.
\end{equation}
可见 $\langle r' \rangle_\psi = r'_s$ ，即 $p_s \propto \langle \psi | s | \psi \rangle$ 时，通过蒙特卡罗计算的观测量的偏差是  $O(1/n^2)$ 的，当涉及到调整权重的重要采样时，对观测量的估计一般有一个 $1/n$ 级的偏差。

*** 基于采样方法的变分法 <<sec:::变分采样>>

蒙特卡罗方法用于计算梯度即 {{{VMC}}} 方法，考虑某个 {{{Ansatz}}}表示的态 $|\psi\rangle$ ，{{{Ansatz}}} 的参数为 $T_i$ ，对公式 [[eqref:eq:观测量变形]] 进行求导，令 $O=H$ ，得到
\begin{equation}
\left\{
\begin{aligned}
\frac{\partial E}{\partial T_i^*}&=\frac{\sum_{s,s'}\langle \partial_{T_i^*}\psi | s | H | s' | \psi \rangle}{\sum_{s}\langle \psi | s | \psi \rangle} - E \frac{\sum_s\langle \partial_{T_i^*}\psi|s|\psi\rangle}{\langle\psi|\psi\rangle} , \\
\frac{\partial E}{\partial T_i}&=\frac{\sum_{s,s'}\langle \psi | s' | H | s | \partial_{T_i}\psi \rangle}{\sum_{s}\langle \psi | s | \psi \rangle} - E \frac{\sum_s\langle\psi|s|\partial_{T_i}\psi\rangle}{\langle\psi|\psi\rangle} .
\end{aligned}
\right.
\end{equation}
类似公式 [[eqref:eq:观测量采样]] ，我们可以将梯度写成采样估计的形式
\begin{equation}
\left\{
\begin{aligned}
\widehat{\frac{\partial E}{\partial T_i^*}}&=\frac{\sum_{s \sim S} r_s \frac{\sum_{s'} \langle \partial_{T_i^*}\psi | s | H | s' | \psi \rangle}{\langle\psi|s|\psi\rangle}}{\sum_{s \sim S} r_s} - \hat E \frac{\sum_{s \sim S} r_s \frac{\langle \partial_{T_i^*}\psi | s | \psi \rangle}{\langle\psi|s|\psi\rangle}}{\sum_{s \sim S} r_s} ,\\
\widehat{\frac{\partial E}{\partial T_i}}&=\frac{\sum_{s \sim S} r_s \frac{\sum_{s'} \langle \psi | s' | H | s | \partial_{T_i}\psi \rangle}{\langle\psi|s|\psi\rangle}}{\sum_{s \sim S} r_s} - \hat E \frac{\sum_{s \sim S} r_s \frac{\langle \psi | s | \partial_{T_i}\psi \rangle}{\langle\psi|s|\psi\rangle}}{\sum_{s \sim S} r_s} .
\end{aligned}
\right.
\end{equation}
而对于任意 $\langle a|$ 和 $|b \rangle$ ，有 $\langle a | s | b \rangle = \frac{\langle a | s | \psi \rangle \langle \psi | s | b \rangle}{\langle \psi | s | \psi \rangle}$ ，令 $\Delta_s^i = \frac{\langle \partial_{T_i^*} \psi|s|\psi\rangle}{\langle \psi|s|\psi \rangle}$ ，
经过化简，我们有
\begin{equation}
\left\{
\begin{aligned}
\widehat{\frac{\partial E}{\partial T_i^*}}&=\frac{\sum_{s \sim S} r_s \Delta_s^i E_s }{\sum_{s \sim S} r_s}- \hat E \frac{\sum_{s \sim S} r_s \Delta_s^i }{\sum_{s \sim S} r_s} \\
\widehat{\frac{\partial E}{\partial T_i}}&=\frac{\sum_{s \sim S} r_s \Delta_s^{i*} E_s^* }{\sum_{s \sim S} r_s}- \hat E \frac{\sum_{s \sim S} r_s \Delta_s^{i*} }{\sum_{s \sim S} r_s} .
\end{aligned}
\right.
\end{equation}

令 $G=\frac{\partial E}{\partial T_i^*}$ ，为了分析梯度的偏差和方差，我们写成多项分布采得的 $q_s$ 的形式，得到
\begin{equation}\label{eq:梯度的严格和估计}
\left\{
\begin{aligned}
G&=\frac{\sum_{s} p_s r_s \Delta_s E_s }{\sum_{s} p_s r_s}- \frac{\sum_s p_s r_s E_s}{\sum_s p_s r_s} \frac{\sum_{s} p_s r_s \Delta_s}{\sum_{s} p_s r_s} , \\
\hat G&=\frac{\sum_{s} q_s r_s \Delta_s E_s }{\sum_{s} q_s r_s}- \frac{\sum_s q_s r_s E_s}{\sum_s q_s r_s} \frac{\sum_{s} q_s r_s \Delta_s}{\sum_{s} q_s r_s} .
\end{aligned}
\right.
\end{equation}
将公式 [[eqref:eq:梯度的严格和估计]] 代入公式 [[eqref:eq:多项分布期望]] ，我们得到
\begin{equation}\label{eq:梯度的偏差和方差}
\left\{
\begin{aligned}
\langle \frac{n}{n-1}\hat G - G\rangle_M &= \frac{1}{n-1}\left(\langle G\rangle_\psi + \langle r'\rangle_\psi \langle G \rangle_\psi - 2 \langle r' G \rangle_\psi\right) + O(1/n^2), \\
\langle (\frac{n}{n-1}\hat G - G)^2 \rangle_M &= \frac{1}{n}\left\langle (G - \langle G \rangle_\psi)^2 r' \right\rangle_\psi + O(1/n^2) .
\end{aligned}
\right.
\end{equation}
与观测量的情况类似，如果 $\langle r' \rangle_\psi = r'_s$ 即 $p_s \propto \langle \psi | s | \psi \rangle$ 时，梯度估计的偏差为 $O(1/n^2)$ ，而涉及到调整权重的重要采样时，则有 $1/n$ 级的偏差。

*** 基于采样的自然梯度法 <<sec:::自然梯度法>>

度量空间中，梯度下降算法可以被自然梯度法所取代。
考虑局部最小化函数 $E(x_i,x_i^*)$ 的任务，我们需要寻找 $\min_{\delta x_i^* g^{ij} \delta x_j = r^2} \hat E(x_i + \delta x_i, x_i^* + \delta x_i^*)$ 。
其中 $\hat E$ 通过当前点 $(x_i,x_i^*)$ 处的梯度估计得到，即
\begin{equation}
\hat E(x_i+\delta x_i, x_i^* + \delta x_i^*)=E(x_i,x_i^*) + \frac{\partial E}{\partial x_i} \delta x_i + \frac{\partial E}{\partial x_i^*}\delta x_i^* .
\end{equation}
使用拉格朗日乘子，定义
\begin{equation}
L(\delta x_i, \delta x_i^*, \lambda) = E(x_i) + \frac{\partial E}{\partial x_i} \delta x_i + \frac{\partial E}{\partial x_i^*} \delta x_i^* + \lambda (\delta x_i^* g^{ij} \delta x_j - r^2) ,
\end{equation}
并求导得到
\begin{equation}
\left\{
\begin{aligned}
0&=\frac{\partial L}{\partial \delta x_i} = \frac{\partial E}{\partial x_i} + \lambda \delta x_j^* g^{ji}, \\
0&=\frac{\partial L}{\partial \delta x_i^*} = \frac{\partial E}{\partial x_i^*} + \lambda g^{ij} \delta x_j .
\end{aligned}
\right.
\end{equation}
所以，
\begin{equation}\label{eq:自然梯度法}
\left\{
\begin{aligned}
\delta x_i &= -\frac{1}{\lambda} g_{ij}\frac{\partial E}{\partial x_j^*} , \\
\delta x_i^* &= - \frac{1}{\lambda} g_{ij}^* \frac{\partial E}{\partial x_j} . \\
\end{aligned}
\right.
\end{equation}

使用 {{{Ansatz}}} 表示量子态时，参数空间的性质与 {{{Hilbert}}}空间 性质相差极大，由于 {{{Ansatz}}}本身的原因，可能导致在{{{Ansatz}}} 的参数空间中难以进行梯度下降。
而希尔伯特空间中，能量函数有着较简单的形式，假设希尔伯特空间有平凡度规 ， 即 $g^H_{ij}=\delta_{ij}$ ，则可以在表示态的{{{Ansatz}}}参数空间中诱导出{{{Ansatz}}}参数空间的度规，从而提高优化效率。
这种方法就是自然梯度，在 {{{VMC}}} 方法中，这种改进也被称为随机重构型方法。

对于两个度量空间 $A$ 和 $B$ ， $x^{A*}_i g^{Aij} y^A_j = x^{B*}_i g^{Bij} y^B_j$ 所以
\begin{equation}\label{eq:度规诱导}
g^{Aij} = \frac{\partial x^{B*}_k}{\partial x^{A*}_i} g^{Bkl} \frac{\partial y^B_l}{\partial y^A_j} .
\end{equation}
希尔伯特空间是射影空间，我们首先将希尔伯特空间的度规诱导至对应的复向量空间中。
由于
\begin{equation}
\psi_i^H = \frac{\psi_i^C}{\sqrt{\sum_k \psi_k^{C*} \psi_k^C}} ,
\end{equation}
我们有
\begin{equation}\label{eq:C和H}
\frac{\partial \psi^H_i}{\partial \psi^C_j} = \frac{1}{|\psi^C|} (\delta_{ij} - \frac{1}{2}\frac{\psi^C_i \psi^{C*}_j}{|\psi^C|^2}) .
\end{equation}
将公式 [[eqref:eq:C和H]] 代入公式 [[eqref:eq:度规诱导]] ，我们得到
\begin{equation}
\begin{aligned}
g^{Cij}
&= \frac{1}{|\psi^C|}(\delta_{ki} - \frac{\psi^{C*}_k \psi^C_i}{|\psi^C|^2}) \delta_{kl} \frac{1}{|\psi^C|}(\delta_{lj} - \frac{\psi^C_l \psi^{C*}_j}{|\psi^C|^2}) \\
&= \frac{1}{|\psi^C|^2}(\delta_{ki} - \frac{\psi^{C*}_k \psi^C_i}{|\psi^C|^2}) (\delta_{kj} - \frac{\psi^C_k \psi^{C*}_j}{|\psi^C|^2}) \\
&= \frac{1}{|\psi^C|^2}(\delta_{ij} - \frac{\psi^C_i \psi^{C*}_j}{|\psi^C|^2}) .
\end{aligned}
\end{equation}

而对于参数 $T_i$ 所在的{{{Ansatz}}}参数空间 $T$ ，其度规为
\begin{equation}\label{eq:度规推导}
\begin{aligned}
g^{Tij}
&= \frac{\partial \psi_k^*}{\partial T_i^*} \frac{1}{|\psi|^2}(\delta_{kl} - \frac{\psi_k \psi_l^*}{|\psi|^2}) \frac{\partial \psi_l}{\partial T_j} \\
&= \frac{1}{|\psi|^2}\frac{\partial \psi_k^*}{\partial T_i^*} (\delta_{kl} - \frac{\psi_k \psi_l^*}{|\psi|^2}) \frac{\partial \psi_l}{\partial T_j} \\
&= \frac{1}{|\psi|^2} \left(\frac{\partial \psi_k^*}{\partial T_i^*} \frac{\partial \psi_k}{\partial T_j} - \frac{\partial \psi_k^*}{\partial T_i^*} \frac{\psi_k \psi_l^*}{|\psi|^2} \frac{\partial \psi_l}{\partial T_j}\right) .
\end{aligned}
\end{equation}
将公式 [[eqref:eq:度规推导]] 写成方便采样估计的形式，得到
\begin{equation}
g^{Tij} = \frac{\sum_k\langle \partial_{T_i^*}\psi|k|\partial_{T_j}\psi\rangle}{\langle \psi | \psi \rangle} - \frac{\sum_k\langle \partial_{T_i^*}\psi|k|\psi\rangle}{\langle\psi|\psi\rangle} \frac{\sum_l\langle\psi|l|\partial_{T_j}\psi\rangle}{\langle\psi|\psi\rangle} .
\end{equation}
可以采样估计
\begin{equation}\label{eq:度规的采样计算}
\widehat{g^{Tij}} = \frac{\sum_{s \sim S} r_s \Delta_s^i \Delta_s^{j*}}{\sum_{s \sim S} r_s} - \frac{\sum_{s \sim S} r_s \Delta_s^i}{\sum_{s \sim S} r_s} \frac{\sum_{s \sim S} r_s \Delta_s^{j*}}{\sum_{s \sim S} r_s} .
\end{equation}

至此，我们可以得到任意用于表示量子态的函数的参数空间中的度规，这样便我们可以利用公式 [[eqref:eq:自然梯度法]] ，将度规的逆作用在梯度上，得到自然梯度下参数更新的方向。

*** 直接采样

直接采样提供了在 {{{PEPS}}} 上的一种自回归、无构型关联的采样方法 [[cite:Vieijra2021]] 。
变分蒙特卡洛方法中，我们需要找到一个采样方法，使得 $r_s = \frac{ \langle \psi | s | \psi \rangle}{p_s} \approx 1$ ，因为 $r_s$ 的分布不均匀会给能量和梯度的估计都带来偏差。

直接采样方案，对投影纠缠对态上的每个物理指标，依次进行采样。
首先， 其试图计算第 0 个物理指标处的约化密度矩阵，即
\begin{equation}
\left(\rho_0\right)_{r_0,t_0} = \sum_{s_1 s_2 \cdots} \langle \psi | (r_0 s_1 s_2 \cdots) \rangle \langle (t_0 s_1 s_2 \cdots) | \psi \rangle ,
\end{equation}
其中 $s = (s_0 s_1 s_2 \cdots)$, $s_i$ 表示构型 $s$ 在第 $i$ 个物理指标上的值。
得到 $\rho_0$ 后，模仿在第 0 个格点上进行测量，即以 $\left(\rho_0\right)_{0,0}, \left(\rho_0\right)_{1,1}, \cdots \left(\rho_0\right)_{d-1,d-1}$ 为概率进行采样，得到 $s_0$ ，其中 $d$ 为这个指标的维度。
接下来计算在第0个点已经坍缩至 $s_0$ 的情况下， 下一个格点的约化密度矩阵，即
\begin{equation}
\left(\rho_1\right)_{r_1,t_1} = \sum_{s_2 s_3 \cdots} \langle \psi | (s_0 r_1 s_2 s_3 \cdots) \rangle \langle (s_0 t_1 s_2 s_3 \cdots) | \psi \rangle ,
\end{equation}
随后执行相同的操作来进行采样。
即在采样第 $i$ 个格点时， 第 $0, \cdots i-1$ 个格点均已经采样完毕，此时计算 第 $i$ 个格点的约化密度矩阵
\begin{equation}\label{eq:直接采样的公式}
\left(\rho_i\right)_{r_i,t_i} = \sum_{s_{i+1} s_{i+2} \cdots} \langle \psi | (s_0 s_1 \cdots s_{i-1} r_i s_{i+1} s_{i+2} \cdots) \rangle \langle (s_0 s_1 \cdots s_{i-1} t_i s_{i+1} s_{i+1} \cdots) | \psi \rangle .
\end{equation}
然后模拟在第 $i$ 个格点上的测量，从而完成 对 第 $i$ 个格点的采样。

由于 {{{PEPS}}} 网络精确收缩代价极高，采样边界MPS和边界MPO方法对计算公式 [[eqref:eq:直接采样的公式]] 中的约化密度矩阵进行计算 [[cite:Liu2017,Murg2007,Verstraete2008,Liu2021]] 。
由于会重加权，虽然 $r_s$ 的均匀性会影响能量和梯度的偏差，但是直接采样过程中的边界MPO方法里，并不需要很大的 $Dc$ ，通常边界MPO中可以取 $Dc=4$ 甚至 $2$ 。
而直接采样中的边界MPS的计算可以在后续计算观测量时复用，所以并没有效率上的影响。

* 张量网络态程序在神威 \cdot 太湖之光上的优化 <<sec:神威优化>>

** 背景与概述

基于 {{{PEPS}}} 的 {{{VMC}}} 算法是二维大体系量子多体系统的有效的解决方案 [[cite:He2018,Liu2018]] 。
而得益于 {{{MC}}} 采样算法的特性，基于 {{{PEPS}}} 的 {{{VMC}}} 算法有着高度的可扩展性。
近年来，国产超级计算机发展取得了长足的进步 [[cite:Yang2016,Fu2017]] ，而这些进步使得国产超级计算机上的科学计算的移植工作变得更加意义。
这不仅为科学计算本身开拓了更宽阔的平台，也为会正反馈地参与发展国产计算系统的生态建设。
为了进一步拓宽基于 {{{PEPS}}} 的 {{{VMC}}} 算法的边界， 提高模拟软件执行效率的优化工作，特别是针对超级计算机系统上的适配优化十分重要。

国产超级计算机神威 \cdot 太湖之光超级计算机使用申威处理器，每个CPU中有260个核心，其中4个主核，每个主核调控64个从核共同完成计算任务。
其于2016年的测试中，超过天河二号，成为当年世界上最快的超级计算机。
由于神威 \cdot 太湖之光超级计算机 的 每个CPU上有高达260个计算核心，并行性能高的算法十分适合在其平台运行，使之可以充分发挥多核优势。
移植过程中，软件应当首先确保在主核上运行成功，而后尝试利用从核分担计算任务以实现加速。
所以虽然主核与从核指令集相同，但针对申威处理器的移植其实是异构计算的工作。
与图形处理器通用计算不同，申威架构中，从核与主核均能够直接访问内存，这简化了程序的移植和优化工作的复杂性。

我们在国产超级计算机神威 \cdot 太湖之光上对 基于{{{PEPS}}} 的 {{{VMC}}} 进行了深度的优化和适配。
最终，我们的软件从100进程拓展到40000进程时，并行效率依然高大 $90.74\%$ 。
而单进程执行效率相比于刚能够成功运行时提高了6倍。

** 软件结构分析

在摩尔定律逐渐失效的今天，超级计算机上的程序优化工作中，衡量并行性能的可扩展性相比于单核性能的优化的重要性逐步上升。
而由于 {{{MC}}} 算法对构型采样的特性，实现基于 {{{PEPS}}}的{{{VMC}}} 算法时，可以轻松将采样任务无依赖地分配给每个计算单元。
而待每个计算单元将观测量与梯度计算完毕后，为了进行统计所有样本结果而执行的 =MPI_Allreduce= [[cite:mpi40]] 是软件唯一的通信来源。
因此，我们的工作将主要围绕单进程性能优化进行。

由于我们的软件实现中，有大量的张量运算，计算性能应为软件的单核性能瓶颈。
而张量的各种运算 又 通过 BLAS和 LAPACK [[cite:lapack]] 的矩阵运算加上张量的高阶转置来实现。
这些矩阵运算主要包括，用于实现张量收缩的 =xGEMM= ，用于实现SVD分解的 =xGESVD= 和
用于 QR分解 =xGEQRF= 、 =xGELQF= 、 =xORGQR= 、 =xORGLQ= 以及对应的复数版本 =xUNGQR= 与 =xUNGLQ= 。
对于抽象的张量来说，转置操作是平凡的，故张量的QR分解可以被实现为转置后矩阵的QR分解，也可以被实现为另一种方式的转置后矩阵的LQ分解。
由于对称性张量被实现为分块的张量，进行各种张量运算时，无论是张量收缩还是分解，转变为矩阵操作后，都将变成大量无依赖的相对小的矩阵操作，特别是张量的收缩操作。
所以，批量版本的 BLAS 和 LAPACK 运算实现 和 高度优化的张量高阶转置实现 应是软件单进程优化的重点。

** 主核程序移植工作

我们 基于 {{{PEPS}}}的{{{VMC}}} 算法 实现 软件 中，除了 BLAS和 LAPACK [[cite:lapack]]，并没有其他的依赖项目，这使我们在主核移植中，没有遇到太大的困难。
我们直接使用 Netlib 的 BLAS 和 LAPACK [[cite:lapack]] ，尝试进行编译。
通过添加编译选项 =-mieee= 以启用IEEE浮点运算标准 [[cite:ieee]] ，确保程序中的浮点运算符合IEEE标准 ，修复运行时浮点异常后，软件的依赖问题在主核解决。

软件本体实现为Fortran 和 少量 C++ ，通过修复部分误用的 GNU 扩展， 如 Fortran中的 =cdsqrt= 函数后，软件本体可以成功在主核上运行。

** 软件热点分析与单进程性能优化

我们以 $t-J$ 模型为例， 参数设置为 $N = 8 \times 8$ 的 {{{L4}}} ， 粒子数限制为 56 ， {{{PEPS}}}的虚拟指标维度设置为  $D=20$ , 进行 {{{VMC}}} 优化。
经过单进程10步采样后进行性能分析，结果列于表 [[ref:table:最开始的profiling]] 中。
如表 [[ref:table:最开始的profiling]] 所示，前四个热点函数均为BLAS运算。

#+caption: \label{table:最开始的profiling} 软件移植主核后的性能分析
#+ATTR_LATEX: :font \scriptsize
|---------------------------+---------------------+----------+---------|
| 热点函数                    | 来源                 | 运行时间   |     占比 |
|---------------------------+---------------------+----------+---------|
| =xGEMM=                   | BLAS ，用于张量收缩    | 2763.53s |  52.36% |
| =xCOPY=                   | BLAS ，部分用于张量转置 | 662.46s  |  12.55% |
| =xGEMV=                   | BLAS ，用于张量收缩    | 645.60s  |  12.23% |
| =xGER=                    | BLAS ，用于张量收缩    | 457.72s  |   8.67% |
| =xLASR=                   | LAPACK ，用于张量分解  | 96.94s   |   1.83% |
| =permutation_rank3_data3= | 用于张量转置           |          |         |
|---------------------------+---------------------+----------+---------|
| 程序整体                    |                     | 5277.54s | 100.00% |
|---------------------------+---------------------+----------+---------|

BLAS 中的 =xGEMM= ， =xGEMV= 和 =xGER= 以及 LAPACK中的 =xLASR= 作为张量运算的核心矩阵操作，无法在主核上进一步优化。
而 =xCOPY= 有部分用于实现张量转置， 以双进度实数浮点数为例， 其形式如 代码 [[ref:code:dcopy.f]] 所示，其调用中，有大量 =INCX= 、 =INCY= 都为 1 的情况。
这在通常使用的商用计算机中，大部分都被编译器自动地进行向量化优化了，而申威架构的编译器实现并没有针对此的优化。
所以我们手动进行优化，具体而言，就是在 =xCOPY= 中检测 =INCX= 和 =INCY= 是否都为 1,
如果是，则使用向量化数据复制操作，双进度实数浮点数的情况如代码 [[ref:code:better-dcopy.f]] 所示。
其中 =FAST_DCOPY= 为针对连续数据复制任务优化后的函数，而 =REFERENCE_DCOPY= 为Netlib中原有的 =DCOPY= 实现。

\begin{lstlisting}[caption={DCOPY的申明},label={code:dcopy.f},language=Fortran]
SUBROUTINE DCOPY(N, DX, INCX, DY, INCY)
\end{lstlisting}

\begin{lstlisting}[caption={DCOPY的优化},label={code:better-dcopy.f},language=Fortran]
SUBROUTINE DCOPY(N, DX, INCX, DY, INCY)
    INTEGER, INTENT(IN) :: N, INCX, INCY
    DOUBLE PRECISION, INTENT(IN) :: DX(*)
    DOUBLE PRECISION, INTENT(INOUT) :: DY(*)

    IF (INCX == 1 .AND. INCY == 1) THEN
        CALL FAST_DCOPY(N, DX, DY)
    ELSE
        CALL REFERENCE_DCOPY(N, DX, INCX, DY, INCY)
    END IF
END SUBROUTINE DCOPY
\end{lstlisting}

针对 =xCOPY= 作出优化后，我们重新进行性能分析，结果如表 [[ref:table:第二次profiling]] 。
如表 [[ref:table:第二次profiling]] 所示，经过优化后 =xCOPY= 的时间占比极大减少，
在 =INCX= 与 =INCY= 均为 1 的情况中，耗时仅 0.30s 。
=xCOPY= 其余的 264.67s 消耗于非平凡的数据搬运中，难以优化。

#+caption: \label{table:第二次profiling} \texttt{xCOPY} 优化后的性能分析
#+ATTR_LATEX: :font \scriptsize
|---------------------------+---------------------+---------------+---------|
| 热点函数                    | 来源                 | 运行时间        |     占比 |
|---------------------------+---------------------+---------------+---------|
| =xGEMM=                   | BLAS ，用于张量收缩    | 2763.83s      |  52.63% |
| =xGEMV=                   | BLAS ，用于张量收缩    | 645.61s       |  13.23% |
| =xGER=                    | BLAS ，用于张量收缩    | 457.46s       |   9.37% |
| =xCOPY=                   | BLAS ，部分用于张量转置 | 264.67s+0.30s |   5.43% |
| =xLASR=                   | LAPACK ，用于张量分解  | 96.71s        |   1.98% |
| =permutation_rank3_data3= | 用于张量转置           |               |         |
|---------------------------+---------------------+---------------+---------|
| 程序整体                    |                     | 4880.28s      | 100.00% |
|---------------------------+---------------------+---------------+---------|

考虑到现有的前三个热点函数均为矩阵运算的 BLAS 函数，我们对其利用从核针对性地进行优化。
以 双精度实数浮点数矩阵乘积运算 =DGEMM= 为例， 当主核遇到 =DGEMM= 任务时，
利用其对应的 64个可以并行运算 的 从核所组成的从核组，同时执行大量浮点运算。
简单来说，矩阵乘积运算时，通过精心设计的方式对矩阵进行分块，从而将一个矩阵乘积运算任务分解为众多小型矩阵的乘积任务。
然后将这些任务分配给这64个从核来进行并行计算，每个从核负责计算一个矩阵分块的部分。
通过这样的并行运算，可以大幅减少计算时间并提高矩阵乘积运算的整体性能。
同时，使用优化后的数据访问策略，来减少缓存失效导致的瓶颈。

经过从核的加速，我们再次进行性能分析，其结果如表 [[ref:table:第三次profiling]] 所示。
可见此时本软件的底层热点函数分布已经比较均匀。
而原先的热点函数，经过从核优化，运行时间都已经降低很多，具体的数据如 表 [[ref:table:第四次profiling]] 所示。
如 表 [[ref:table:第四次profiling]] 所示， 至此，软件整体的性能已经优化到最初的 3.60 倍。

#+caption: \label{table:第三次profiling} 从核优化后的性能分析
#+ATTR_LATEX: :font \scriptsize
|---------------------------------+--------|
| 热点函数                          |    占比 |
|---------------------------------+--------|
| =memcpy=                        | 25.30% |
| =set_all_data_int=              |  7.65% |
| =dlasr=                         |  7.13% |
| =permutation_rank3_data3_real8= |  6.96% |
| =pthread_mutex_lock=            |  2.19% |
| =dlamch=                        |  1.82% |
| =dscal=                         |  1.72% |
|---------------------------------+--------|

#+caption: \label{table:第四次profiling} 从核优化后的原热点函数性能分析
#+ATTR_LATEX: :font \scriptsize
|---------+------------------+-------------+----------------+-------|
| 热点函数  | 来源              | 优化前运行时间 | 从核优化后运行时间 |  加速比 |
|---------+------------------+-------------+----------------+-------|
| =xGEMM= | BLAS ，用于张量收缩 | 2763.83s    | 168.30s        | 16.42 |
| =xGEMV= | BLAS ，用于张量收缩 | 645.61s     | 110.78s        |  5.83 |
| =xGER=  | BLAS ，用于张量收缩 | 457.46s     | 71.28s         |  6.41 |
|---------+------------------+-------------+----------------+-------|
| 程序整体  |                  | 4880.28s    | 1354.99s       |  3.60 |
|---------+------------------+-------------+----------------+-------|

为了更好地进行进一步优化，我们对上层函数进行插桩计时，以了解上层程序结构的热点情况。
我们发现，此时软件的主要耗时 数据复制 很多出现在张量的元信息的复制上，比如指标名称等。
为此，我们重新设计了软件的上层数据结构，使得 访存不再是热点。
此外，我们重新设计了对称性张量的高阶转置函数， 直接使用一次高阶转置，而不使用原先的多次矩阵转置来实现张量转置。
虽然新的转置方法没有进行向量化优化，但是由于减少了数据移动的次数，使得张量转置的总耗时占比下降到 $5\%$ 。
而个类型访存函数耗时下降后， 单进程 BLAS 和 LAPACK 函数 ，耗时总占比再次提高达到 $87\%$ 。

由于我们的对称性张量是分块张量，进行收缩时，会有大量无依赖的矩阵乘积运算。
这在单核上，没有什么问题，但是在多核的情况下，却会导致性能无法充分发挥。
一方面，包括神威架构在内的异构系统，调用从核时会有启动开销，对于特别多次小矩阵的矩阵乘积，相比于利用并行获得的加速，启动开销让效率得不偿失。
另一方面，多核共同完成矩阵乘积任务时，我们会将矩阵切割成多个更小的矩阵来将子任务分配给各个计算核心来获得加速。
但是分块张量收缩时的矩阵乘积任务中的矩阵本身已经很小了，难以更好的分割任务。
而这些矩阵乘积任务本身就是无依赖的，如果将这一批矩阵乘积任务综合考虑如何分割任务并利用从核进行并行运算，可以获得更好的性能提升。
我们实现了这种批量版本矩阵乘积函数，经过测试，相比于无批量的从核版本的矩阵乘积方案，新函数性能提升了3倍。

至此，我们通过的多层次优化，从底层的矩阵乘积实现，到上层的数据结构调整，使得软件的整体性能相比于最开始的版本提高了6倍。

** 可扩展性测试

从 {{{MC}}} 算法的原理上看，我们的程序仅有独立采样后的最后一部 =MPI_Allreduce= 需要进程之间的通信，故理论上我们的软件并行性能应当很好。
为了确认这一看法，我们测试了一个40000进程的任务，相比于相同任务使用100个进程执行，加速了 $362.96$ 倍。
这说明即使在万级别的并行环境下，我们依然有高达 $90.74\%$ 并行效率。

** 小结

我们在国产超级计算机神威 \cdot 太湖之光上， 成功移植了我们实现的 基于{{{PEPS}}} 的 {{{VMC}}} 软件。
同时，在本移植工作中，也发现过神威 \cdot 太湖之光系统中的一些问题，通过反馈，实现国产超级计算机的生态建设的参与。
我们进行了多层次、有针对性的优化，下至矩阵乘积的批量版本实现，上至张量数据结构的调整，并最终使得软件的整体性能相比于最开始的版本提高了6倍。
我们的软件有先天的并行优势，在40000进程的情况下，相比于100进程，依然有 $90.74\%$ 的并行效率。
此工作探索了基于 {{{PEPS}}} 的 {{{VMC}}} 算法在程序设计与高并行运算的边界，为后续计算大尺寸量子多体问题提供了参考。

* {{{TNSP}}}(TNSP) <<sec:软件>>

** 背景介绍

现代凝聚态物理学在求解强关联多体系统时面临挑战，传统的数值方法如严格对角化 (ED)、量子蒙特卡洛 (QMC) [[cite:Kashurnikov2007,Syljusen2002]] 和密度矩阵重整化 (DMRG) [[cite:White1992,White1993]] 虽取得成功，
但各有局限性 ，特别是在高维系统中 [[cite:Schollwck2011]] 或在有阻挫和费米子系统中 [[cite:Troyer2005]] 时。
近年来，基于张量网络态的方法，尤其是投影纠缠对态 (PEPS) [[cite:Schollwck2011,Garcia2006,Verstraete2008,Jiang2008,Vidal2008,Verstraete2004,Sfondrini2010,Verstraete2006b]] ，显示出强大的模拟能力，
在研究阻挫自旋模型和费米子系统方面取得显著进展 [[cite:Wang2016,Vidal2007,MllerHermes2012]] 。
然而，费米子投影纠缠对态方法因反对易性质的复杂性而面临困难，尽管有策略将费米子张量转为玻色子张量，但这增加了网络构建的复杂性 [[cite:Kraus2010,Corboz2010]]。
因此，开发新的数值算法尤为迫切。

我们在 文献 [[cite:Dong2019]] 中提出并在 第 [[ref:sec:张量和张量网络]] 章 中详细介绍的费米子张量方案，在编程应用中显示出相当大的适应性。
在这种方案中，我们引入了所谓的``费米箭头''来定义费米子算符的顺序，并通过建立特定的操作规则来重新定义费米子张量，这些规则有效地管理了费米子的交换反对易性质。
这些规则包括诸如收缩、转置和分解等基本操作， 从而使得这种方案可以极大简化上层的费米子 {{{PEPS}}} 方法。
另一种处理 费米子 {{{PEPS}}} 的方法是 {{{Grassmann}}} 张量方案 [[cite:Gu2010,Yosprakob2023]] ，他与我们的方法有很多相似之处。
然而，尽管做出了这些努力，费米子 {{{PEPS}}} 方法及其相关软件的开发仍然极具挑战性。
费米子张量的复杂性加剧了  支持 费米子 {{{TNS}}} 开发复杂需求的软件包的匮乏。

在我们之前的工作中，我们开发了一个专门为 {{{TNS}}} 方法设计的 Fortran2003 库，名为 TNSPackage [[cite:Dong2018]]。
该库包含了一套最常用的张量操作，如乘法、收缩、排列、奇异值分解（SVD）和各种矩阵分解函数，显著简化了{{{TNS}}}的编程过程，特别是对于 {{{PEPS}}} 的方法。
然而，TNSPackage的初始版本仅支持适用于玻色子和自旋模型的{{{TNS}}}方法，无法处理费米子 {{{TNS}}}。
我们对TNSPackage进行了重大升级，以支持费米子 {{{TNS}}} 方法。
我们构建了一个名为 {{{TNSP}}}(TNSP) [[cite:TNSP-repo]] 的框架，旨在支持玻色子和费米子 {{{TNS}}} 编程。
{{{TNSP}}} 主要由两个组件组成：一个名为TAT的底层张量包，是 ``TAT is A Tensor package'' 的递归缩写，以及一个名为 tetragono 的上层接口包，在希腊语中意为``方形''。

TAT继承了上版本TNSPackage的核心功能，并使用C++重写，并整合了 第 [[ref:sec:神威优化]] 章中的成果。
它具有良好设计的架构，为各种张量类型提供了一致的接口，包括标准张量、费米子张量和各种对称性张量类型，这展示了其卓越的适应性。
此外，我们还为其开发了一个Python3接口，进一步简化在跨C++和Python的环境中的编程。

tetragono包提供了一套专为开发正形晶格上物理模型的 (费米子) {{{PEPS}}} 程序设计的高级接口。
值得注意的是，其他类型的晶格模型可以映射到正方形晶格上[[cite:Zhang2022,Dong2023]]。
该接口集成了几种广泛使用的张量网络态算法，如简单更新 [[cite:Jiang2008]] 和各种基于采样的方法 [[cite:Sandvik2007,Liu2017,Dong2019]] 。
用户可以通过命令行模式或脚本模式访问应用程序接口，或将其作为包来开发更复杂的算法，使用tetragono中预定义的算法和组件。
其架构基本上是模块化的，便于轻松集成插件以实现自定义物理模型和采样方法。
此外，为了支持并行计算，他通过mpi4py [[cite:Dalcn2005]] 使用MPI [[cite:mpi40]] 。
利用tetragono显著简化了不同 (费米子) {{{PEPS}}} 算法或物理模型的实现，使用户能够轻松使用各种功能，而无需深入了解底层实现细节。
此外，我们在 {{{TNSP}}} 内为一些流行的典型物理模型 (如海森堡模型和哈伯德模型) 实现了一系列预定义的插件。
这些模型被收集到一个名为 tetraku 的库中，其中``ku''在中文中意为 ``库''。
用户可以直接使用这些物理模型，而无需进行额外的编程。

我们发布的包是一个稳定的，经过全面测试的版本，并在我们的研究中利用其使用 {{{TNS}}}方法解决了重要的量子多体问题。
例如，我们使用这个包模拟了 $t-J$ 模型中的条纹相，如文献 [[cite:Dong2020]]中所述。
最近，我们还发现了 基塔耶夫-{{{Hubbard}}} 模型中可能存在的自旋液体相，如文献 [[cite:Dong2023]] 中所讨论的。

** 张量网络态计算套件概述

{{{TNSP}}} [[cite:TNSP-repo]] 通过抽象张量类型的细节，简化了 {{{TNS}}} 方法的开发过程，特别是对于 {{{PEPS}}} ，无论底层张量是费米子张量、对称性张量还是常规张量。
它提供了一个以用户友好的接口，便于应用常见的 {{{TNS}}} 方法，包括简单更新 [[cite:Jiang2008]] 、 梯度优化以及各种采样技术 [[cite:Sandvik2007,Liu2017,Dong2019]]。
该套件的设计本身十分具有灵活性，允许用户通过Python3插件无缝集成自定义的物理模型和优化策略。

{{{TNSP}}} 是  早期版本 TNSPackage [[cite:Dong2018]] 的进化，并进行了显著的改进。
新版本的程序保留了原有的一些特性，例如能够为每条边命名，同时扩展了支持范围，包括对称性张量和费米子张量。
最新的 {{{TNSP}}} 版本从 Fortran90 的旧版 重新开发，重写为 C++17。
C++17 的使用极大地简化了编码工作，并利用泛型和面向对象编程范式，增强了框架的可读性、可维护性和可扩展性。
此外，该框架在上层提供了一个强大且一致的接口，用于执行各种 {{{TNS}}} 中需要的操作。
它还配备了一个全面的预定义物理模型和{{{TNS}}}优化方法库，用户可以直接使用这些库，或作为学习如何开发自己插件的示例。

#+begin_export latex
\begin{figure}
\centering
\includegraphics[width=0.8\textwidth]{figures/structure-of-tnsp.pdf}
%\caption{张量网络态计算套件的结构}
%\note{注：
\caption{张量网络态计算套件的结构。
张量网络计算套件的结构。该套件的核心是张量库TAT，他使用C++17设计，以提供各种张量类型的统一接口。
通过pybind11为该张量库创建了Python接口。
在Python接口的基础上，开发了一个名为tetragono的包，提供了一个易于访问和统一的接口，用于适用于不同物理模型和张量类型的多种TNS方法。
tetragono可以通过插件进行自定义修改。
套件还包括一个名为tetraku的模型库，其中包含了一系列预定义的插件，这些插件涵盖了各种物理模型、采样策略等。
此外，tetragono还使用了几个辅助库：lazy\_graph，提供了一种在计算中使用的惰性求值机制；以及PyScalapack，提供了ScaLAPACK的Python接口。
}
\label{fig:张量网络态计算套件的结构}
\end{figure}
#+end_export

该套件的总体结构如图 [[ref:fig:张量网络态计算套件的结构]] 所示。
套件内的核心张量库TAT旨在为各种类型张量提供统一的接口。
TAT实现为一个C++17的头文件库，通过泛型编程统一实现不同张量类型。
TAT通过使用所谓的对称性类型（Symmetry）来区分张量类型，对称性类型用于包含量子数，并提供关于这些量子数是费米子还是玻色子的相关信息。
根据指定的对称性类型，TAT定义了一个边类型（Edge）来表示张量指标的性质，该边类型涵盖了由对称性类型表征的一系列值及其各自的简并度。
随后，张量类型（Tensor）由一系列边的名称和一系列边构建，并提供各种张量操作的接口，如奇异值分解（SVD）、收缩或边的分割/合并，这些操作在不同张量类型中保持接口的一致性。
一旦构建了具有特定对称群的张量，其各种操作的函数接口都保持一致。

如图 [[ref:fig:张量网络态计算套件的结构]] 所示，我们使用pybind11 [[cite:pybind11-repo]] 将TAT的C++接口进行了封装，开发了一个Python3接口。
用户可以直接通过C++代码访问TAT库，也可以通过Python接口进行访问。

在核心张量库之上，我们开发了tetragono，以提供针对不同物理模型和张量类型的各种{{{TNS}}}方法，特别是{{{PEPS}}}的简便且统一的接口。
tetragono引入了抽象态类型（AbstractState）的概念以记录物理模型中的各种信息，以及一个抽象晶格类型（AbstractLattice），涵盖了{{{PEPS}}}虚拟指标的详细信息。
在这两个抽象类之上，tetragono实现了各种{{{TNS}}}方法，包括 [[ref:sec:::简单更新]] 中介绍的 简单更新和各种基于采样的方法。
在基于采样的方法中，tetragono实现了物理观测量的计算和优化方法，例如 [[ref:sec:::变分采样]] 中介绍的梯度下降 [[cite:Liu2017]] 和 [[ref:sec:::自然梯度法]] 中介绍的 随机重构算法 [[cite:Sorella1998,Neuscamman2012,Stokes2020]]。
同时提供了一个简单的直接对角化方法，可用于对小系统中各个{{{TNS}}}方法的结果进行基准测试。
为提高重用性，各种组件如用于单层的边界MPS方法或双层网络的边界MPO方法 [[cite:Murg2007]] 的辅助张量系统也被独立封装。
目前，tetragono仅支持{{{L4}}}上的{{{PEPS}}}。
但我们注意到，三角晶格上的模型可以直接利用为 {{{L4}}} 设计的{{{PEPS}}} [[cite:Zhang2022]] 。
此外，通过引入在某一位置处的多个物理指标，我们可以把其他晶格几何结构，如 笼目晶格 和 {{{L6}}}，映射到{{{L4}}}上 [[cite:Dong2023]] 。

tetragono提供了一个接口，使用户能够开发自己的插件，从而在套件内自定义物理模型和算法。
例如，在基于采样的算法 [[cite:Sandvik2007,Liu2017,Dong2019]] , 中，用户可以修改采样规则，以针对特定物理模型提高效率。

我们在套件内为一些常见的物理模型实现了一系列插件，并将他们整合到一个名为tetraku的库中。tetraku被设计为与tetragono无缝集成的插件集，使用户无需额外编程即可直接利用这些物理模型和配置。

** 套件各组件的设计

*** 张量库(TAT)

作为套件的中最基础的部分，张量包TAT旨在为各种类型的张量提供统一的接口。
TAT， 作为一个C++17头文件库， 利用泛型编程实现了各种张量类型的统一实现， 通过使用对称性类型来区分不同的张量类型。
这种对称性类型包含量子数， 并标记他们是费米的还是玻色的， 使TAT能够区分不同的张量类型: 普通的对称性张量， 费米子对称性张量或常规的张量， 每种都与特定的量子群相关联。
在非对称情况下， 没有量子数， 而 $U(1)$ 对称性涉及整数量子数， $Z(2)$ 对称性使用布尔值。
更复杂的场景涉及具有不同类型和任意长度的量子数元组作为乘积类型来表示对称群。
TAT通过静态处理指示每个量子数的费米玻色性质， 提高了代码的可读性和可重用性。

根据对称性类型， TAT定义了一种边类型， 用于表示张量指标的属性， 封装了由对称性类型表征的一系列值及其对应的简并性。
这种边由若干个`段'组成， 并且在适用的情况下， 还包含一个布尔值， 指示费米子情况下的费米箭头。
其中若干段中的每一段是对称性类型的值与其简并性构成的对。
一个分块多维数组， 或者说Core类型， 是由这些边的序列通过公式  [[eqref:eq:Abel对称性张量的形式]] 创建而成的， 为了性能效率， 将分块数据存储为一维数组。
然后， 张量类型由指向这个Core类型的指针和一个边名称的序列组成， 这允许在不直接改变原始张量的情况下， 通过轻量级的非就地边重命名来操纵张量元数据。
TAT提供了张量操作的各种接口， 如奇异值分解， 收缩， 或边的分割/合并。
一旦使用每个对称性所需要的独特属性构建完成了张量， 其他所有的张量操作接口就能在不同的张量类型和对称性组之间保持一致。

TAT的代码位于仓库的 =/TAT/include/TAT= 目录中，包含 =TAT。hpp= 主文件和四个目录： =structure= 、 =implement= 、 =utility= 和 =miscellaneous= 。在 =structure= 目录中，文件的组织如下：
+ =name.hpp= 描述了用作指标名称的类型。
+ =symmetry.hpp= 定义了泛型的对称性类型 =Symmetry= ，用于表示量子数。他可以被实例化为各种对称性类型， 如 =NoSymmetry= 、 =BoseU1Symmetry= 、 =BoseZ2Symmetry= 、 =FermiZ2Symmetry= 、 =FermiU1Symmetry= 等 。
+ =edge.hpp= 定义了基于对称性类型的边类型用以描述张量指标， 包括一个段和费米箭头， 这里的段被表示为一个C++的向量， 该向量由对称性类型(Symmetry)和维度(dimension)的对所组成 。
+ =core.hpp= 定义了核心类型，用于包含边序列和分块多维数组。
+ =tensor.hpp= 通过结合指向核心类型的指针 =shared_ptr<Core>= 和指标名称序列 =vector<Name>= 来描述张量类型，并声明了张量操作的函数，这些函数的实现可以在 =implement= 目录中的相应文件中找到。
此外，TAT包的各种实用函数和类放置在 =utility= 目录中。在 =miscellaneous= 目录中，文件 =io.hpp= 专门用于定义张量的I/O函数， =scalar.hpp= 处理张量的标量算术，而 =mpi.hpp= 则专注于为张量提供各种MPI [[cite:mpi40,Dalcn2005]] 操作的函数 。

Python接口封装的代码位于仓库的 =/PyTAT= 目录中，包含三个主要文件：
+ =PyTAT.hpp= 定义了模板函数，这些函数用于封装张量和边。
+ =dealing_tensor.cpp.in= 用于生成文件， 这些文件实例化 =PyTAT。hpp= 中针对不同张量类型的函数。 文件的生成过程由 =CMakeLists.txt= 协调。
+ =PyTAT.cpp= 负责定义Python模块中的所有其他组件。

TAT通过使用特定的描述符， 称为 =SymmetryType= ， 来区分属于不同对称性群的张量， 该描述符通常是模板类 =Symmetry<Args...>= 的实例化。
在这里，  =Args...= 表示包含指示对称性单群们的可变模板参数。
由模板类表示的对称性群是这些单群的乘积。
值得注意的是，  $U(1)$ 对称性由整数类型表示， 使用 =U1= 作为别名， 而 $Z(2)$ 对称性由布尔类型表示， 使用 =Z2= 作为别名。
例如，  =Symmetry<U1, Z2>= 表示群 $U(1) \otimes Z(2)$ 。
为了描述费米子对称性， 表明体现这种对称性的粒子是费米子，
TAT使用类型包装器 =fermi= 来封装单群的标记。
例如， =Symmetry<fermi<U1>>= 表示费米-$U(1)$ 对称性。
为了增强表示的美观性和一致性， 用户还可以使用身份包装器 =bose= 为非费米子对称性群标记。
例如，  =Symmetry<fermi<Z2>， bose<U1>>= 表示费米-$Z(2)$ $\otimes$ 玻色-$U(1)$ 群。
至于非对称性情况， TAT使用 =Symmetry<>= 。

在TAT中，张量类型被定义为 =Tensor<ScalarType， SymmetryType， NameType>= ， 这是一个模板类，
其中 =ScalarType= (默认为 =double= )表示张量的内部标量类型，  =SymmetryType= (默认为 =Symmetry<>= )指定了张量所保持的对称群，
而 =NameType= (默认为 =string= )表示用于标记张量边的名字的类型。
用户可以通过使用统一的接口 =Tensor(name_list， edge_list)= 轻松生成不同类型的张量。
这里， =name_list= 指的是包含边名字的C++向量， 每个边名字都是 =NameType= 的一个值， 而 =edge_list= 表示由边组成的C++向量。

不同对称性类型的边表现出不同的形式。
在无对称性张量的情况下， 每个边可以直接由一个整数表示。
例如， 代码 [[ref:code:nosymmetry-cpp]] 创建了一个没有任何对称性的张量， 并初始化填充为零。
其创建了一个名为 =A= 的2阶张量， 他有两个边, =i= 和 =j= ， 这两个指标的维度分别为 =3= 和 =4= 。
\begin{lstlisting}[caption={无对称性张量的创建},label={code:nosymmetry-cpp},language=C++]
auto A = TAT::Tensor<double, TAT::Symmetry<>>(
             {"i", "j"},
             {3, 4},
).zero_();
\end{lstlisting}

非费米子对称性张量使用``段''来定义边， 这些段是一系列量子数及其相应简并度的对构成的列表。
如代码 [[ref:code:bose-symmetry-cpp]] 生成了一个 $Z(2)$ 对称性张量和一个 $U(1)$ 对称性张量。
在这里， $Z(2)$ 对称群的不可约表示为一个布尔值， 而对于 $U(1)$ 对称群， 他由一个整数表示。
对于张量 =A= ， 他有两个分块。
第一个分块具有不可约表示 ={false， false}= ， 维度为 $2 \times 4$ 。
第二个块具有不可约表示 ={true， true}= ， 维度为 $4 \times 1$ 。
对于张量 =B= ， 他由三个分块组成。
不可约表示分别为 ={-1， +1}= ， ={0， 0}= ， 和 ={+1， -1}= 。
每个块根据这些多重数具有不同的维度.
\begin{lstlisting}[caption={对称性张量的创建},label={code:bose-symmetry-cpp},language=C++]
auto A = TAT::Tensor<double, TAT::Symmetry<TAT::bose<TAT::U1>>>(
             {"i", "j"},
             {
                 {{false, 2}, {true, 4}},
                 {{false, 3}, {true, 1}},
             }
).zero_();
auto B = TAT::Tensor<double, TAT::Symmetry<TAT::bose<TAT::Z2>>>(
             {"i", "j"},
             {
                 {{-1, 2}, {0, 4}, {+1, 1}},
                 {{-1, 3}, {0, 2}, {+1, 1}},
             }
).zero_();
\end{lstlisting}

费米子张量的情况更加复杂。
边由一系列段以及所谓的`费米箭头'决定，而费米箭头是一个布尔值。
代码 [[ref:code:fermi-symmetry-cpp]] 创建了一个费米子 $U(1)$ 对称性张量，
其费米子性质由 $U(1)$ 对称性携带， 其两个边的费米箭头分别为 =false= 和 =true= 。
如我们在 [[ref:sec:::费米子张量]] 中所介绍，在费米子张量网络中， 我们需要引入了费米箭头， 这是因为在网络的每条边后面存在一个含有费米子的纠缠对。
通过一条边连接的两个张量包含纠缠对的两个湮灭算符， 而对于可能含有费米子纠缠对， 两个算符的顺序是重要的。
因此， 在TAT中， 使用费米箭头来表示哪一侧的算符在另一侧之前。
具体来说， TAT假设费米箭头为 =false= 的算符在费米箭头为 =true= 的算符之前。
\begin{lstlisting}[caption={费米子张量的创建},label={code:fermi-symmetry-cpp},language=C++]
auto A = TAT::Tensor<double, TAT::Symmetry<TAT::fermi<TAT::U1>>>(
             {"i", "j"},
             {
                 {{{-1, 2}, {0, 4}, {+1, 1}}, false},
                 {{{-1, 3}, {0, 2}, {+1, 1}}, true},
             }
).zero_();
\end{lstlisting}

对于非单群的对称性张量, 他们的不可约表示实际上可以用一个元组而不是单个布尔值或整数来表示, 如代码 [[ref:code:complex-symmetry-cpp]] 所示。
\begin{lstlisting}[caption={更复杂的张量类型},label={code:complex-symmetry-cpp},language=C++]
using Symmetry = TAT::Symmetry<TAT::fermi<TAT::U1>, TAT::bose<TAT::Z2>>;
auto A = TAT::Tensor<double, Symmetry>(
             {"i", "j"},
             {{{
                   {{-1, false}, 2},
                   {{0, false}, 4},
                   {{+1, false}, 1},
                   {{-1, true}, 4},
                   {{0, true}, 2},
                   {{+1, true}, 1},
               },
               false},
              {{
                   {{-1, false}, 3},
                   {{0, false}, 2},
                   {{+1, false}, 1},
                   {{-1, true}, 1},
                   {{0, true}, 2},
                   {{+1, true}, 3},
               },
               true}}
).zero_();
\end{lstlisting}

由于Python接口的封装是TAT这个C++头文件库的简单封装， 他不支持标量类型或对称性类型的多态性。
因此， Python中的每个不同张量都有其特定的类型。
张量类型的命名约定为 =TAT.<SymmetryType>.<ScalarType>.Tensor= 。
这里, =<SymmetryType>= 表示张量保持的对称性属性， 而 =<ScalarType>= 代表张量内部使用的标量数据类型。
=<ScalarType>= 的可用值在表 [[ref:table:可用的scalar]] 中总结。
表 [[ref:table:可用的symmetry]] 总结了 =<SymmetryType>= 的可选值。

#+caption: \label{table:可用的scalar} TAT的Python接口中可选的 =ScalarType=
#+ATTR_LATEX: :font \scriptsize
|------------------------------+------------------------+---------------------|
| =<ScalarType>=               | C++的标量类型          | Fortran中的等价类型 |
|------------------------------+------------------------+---------------------|
| =S=, =float32=               | =float=                | =real(kind=4)=      |
| =D=, =float64=, =float=      | =double=               | =real(kind=8)=      |
| =C=, =complex64=             | =std::complex<float>=  | =complex(kind=4)=   |
| =Z=, =complex128=, =complex= | =std::complex<double>= | =complex(kind=8)=   |
|------------------------------+------------------------+---------------------|

#+caption: \label{table:可用的symmetry} TAT的Python接口中可选的 =SymmetryType=
#+ATTR_LATEX: :font \scriptsize
|------------------+----------------------------------+---------------------------|
| =<SymmetryType>= | C++中的对称性类型                | 守恒量的例子              |
|------------------+----------------------------------+---------------------------|
| =No=, =Normal=   | =Symmetry<>=                     | 没有任何守恒              |
| =BoseZ2=, =Z2=   | =Symmetry<bose<Z2>>=             | z方向自旋宇称             |
| =BoseU1=, =U1=   | =Symmetry<bose<U1>>=             | z方向自旋                 |
| =FermiU1=        | =Symmetry<fermi<U1>>=            | 费米子数目                |
| =FermiU1BoseZ2=  | =Symmetry<fermi<U1>, bose<Z2>>=  | 费米子数目和z方向自选宇称 |
| =FermiU1BoseU1=  | =Symmetry<fermi<U1>, bose<U1>>=  | 费米子数目和z方向自选     |
| =FermiZ2=        | =Symmetry<fermi<Z2>>=            | 费米子数目宇称            |
| =FermiU1FermiU1= | =Symmetry<fermi<U1>, fermi<U1>>= | 两个不同的费米子数目      |
|------------------+----------------------------------+---------------------------|

和C++接口一样， 用户可以通过使用统一的接口 =Tensor(name_list, edge_list)= 来创建各种类型的张量，如代码 [[ref:code:complex-symmetry-py]] 展示了代码 [[ref:code:complex-symmetry-cpp]] 的等价Python版本。
\begin{lstlisting}[caption={Python接口创建的类型更复杂的张量},label={code:complex-symmetry-py},language=Python]
import TAT

A = TAT.FermiU1BoseZ2.D.Tensor(["i", "j"], [
    ([
        ((-1, False), 1),
        ((0, False), 1),
        ((+1, False), 1),
        ((-1, True), 1),
        ((0, True), 1),
        ((+1, True), 1),
    ], False),
    ([
        ((-1, False), 1),
        ((0, False), 1),
        ((+1, False), 1),
        ((-1, True), 1),
        ((0, True), 1),
        ((+1, True), 1),
    ], True),
]).zero_()
\end{lstlisting}

TAT的Python接口封装提供了与其他 Python 包出色的互操作性，能够通过 pickle 对 TAT 张量进行序列化和反序列化。此外，他支持将张量块导出为 NumPy [[cite:Harris2020]] 数组，并保持内存共享，从而实现与 Python 生态系统的无缝集成。
TAT中常用的函数列在表 [[ref:table:TAT-functions]] 中，由于C++和Python接口高度一致，这里只展示Python的接口。

#+begin_export latex
\begin{table} [h]
\begin{center}
\caption{\label{table:TAT-functions} TAT的Python接口中 常用的函数}
\scriptsize
\begin{tabular}{cc}
\hline
函数 & 例子 \\\hline
\texttt{clear\_symmetry} & \texttt{A.clear\_symmetry()} \\
\texttt{conjugate} & \texttt{A.conjugate()} \\
\texttt{contract} & \texttt{A.contract(B, {("i", "o")})} \\
\texttt{edge\_rename} & \texttt{A.edge\_rename({"i": "j"})} \\
\texttt{exponential} & \texttt{A.exponential({("i", "o")})} \\
\texttt{identity\_} & \texttt{A.identity\_({("i", "o")})} \\
\texttt{map} & \texttt{A.map(lambda x: x + 1)} \\
\texttt{merge\_edge} & \texttt{A.merge\_edge({"ij": ["i","j"]})} \\
\texttt{qr} & \texttt{A.qr('r', {"i"}, "q", "r")} \\
\texttt{randn\_} & \texttt{A.randn\_(0, 1)} \\
\texttt{rand\_} & \texttt{A.rand\_(0, 1)} \\
\texttt{reverse\_edge} & \texttt{A.reverse\_edge({"i"})} \\
\texttt{split\_edge} & \texttt{A.split\_edge({"ij": [("i", seg\_i), ("j", seg\_j)]})} \\
\texttt{svd} & \texttt{A.svd({"i"}, "u", "v", "su", "sv")} \\
\texttt{trace} & \texttt{A.trace({("i", "o")})} \\
\texttt{transform\_} & \texttt{A.transform\_(lambda x: x + 1)} \\
\texttt{transpose} & \texttt{A.transpose(["j","i"])} \\
\texttt{zero\_} & \texttt{A.zero\_()} \\\hline
\end{tabular}
\note{注：
1. 函数名遵循就地操作函数以下划线 ``\texttt{\_}'' 结尾的名称约定。
2. \texttt{clear\_symmetry} 函数旨在最大程度地消除对称性信息。对于非费米子对称性张量，此操作生成一个非对称性张量。反之，对于费米子张量，该操作的结果是一个费米-$Z(2)$ 对称性张量。
3. \texttt{contract} 函数的第二个参数是一个包含指标名称对的集合，每个对包含第一个张量中的一个边名及其在第二个张量中的对应边名。
4. \texttt{exponential}、\texttt{identity\_} 和 \texttt{trace} 函数需要一组指标名称对来确认边的关系，明确指出张量中哪条边与哪条边对应。
5. 在 \texttt{qr} 函数中，当第一个参数为 \texttt{'r'} 时，第二个参数表示新形成的 \texttt{R} 张量的自由边。相反，如果第一个参数是 \texttt{'q'}，第二个参数则指定 \texttt{Q} 张量的自由边。最后两个参数表示 QR 分解过程中新创建的边的名称。
6. \texttt{randn\_} 函数根据指定的均值和标准差生成正态随机数并填充到张量中，而 \texttt{rand\_} 函数在给定的上下边界内生成均匀随机数并填充到张量中。
7. \texttt{split\_edge} 函数需要新边的分段信息，因为在合并过程中边的分段信息会丢失。
8. 与 \texttt{qr} 函数相比，\texttt{svd} 函数需要为对角 \texttt{S} 张量额外指定两个边名。然而，由于在 SVD 中 \texttt{U} 和 \texttt{V} 是对称的，用户应始终指定新 \texttt{U} 张量的自由边。
}
\end{center}
\end{table}
#+end_export

*** 张量网络态库(tetragono)

tetragono是一个多功能的软件包， 为各种{{{TNS}}}(TNS)方法提供了一个统一的接口， 适用于不同的物理模型和张量类型。
他包含了多种{{{TNS}}}方法， 包括 {{{SU}}} (SU) 和基于采样的技术。
对于基于采样的方法， 他方便了物理观测量的计算， 并引入了优化算法， 如梯度下降和随机重构型。
此外， tetragono提供了{{{ED}}}(ED)方法， 可以作为在小系统中验证其他算法得到的结果的基准。
他建立在张量包 TAT 的Python接口之上， 支持不同类型的对称性张量和费米子张量。
用户可以通过编写插件来扩展其功能， 修改现有算法或引入自定义物理模型。

tetragono主要支持由{{{PEPS}}}(PEPS)表示的方形格子系统。
然而， 通过在{{{PEPS}}}的基础上为单个张量中添加多个物理边， 可以适应其他几何形状的晶格。
tetragono提供了多种接口， 包括一个名为tetragono shell的命令行界面(CLI)应用程序， 以方便使用。
其组件可以单独使用， 赋予用户构建更复杂算法的能力。

tetragono首先定义一个抽象态类型（AbstractState）以概述晶格系统的基本信息，包括：
+ 晶格的尺寸。
+ 每个晶格点的物理边数目，使用轨道索引区分相同位置的多条物理指标。
+ 每条物理指标的量子数及简并信息。
+ 总的哈密顿量，表示为局部哈密顿量之和，每个局部哈密顿量由一个张量表示，以及该张量所作用的晶格坐标的信息。
+ 如果系统具有非平凡的总量子数（例如电子总数），则还会有可能的总量子数。

随后，从抽象态类型衍生得到抽象晶格类型（AbstractState），添加有关{{{PEPS}}}中每个虚拟指标的量子数和简并的信息。
在此基础上，基于这两个抽象类实现了各种{{{TNS}}}方法，如简单更新法或多种基于采样的方法。
我们还实现了基于采样的优化方法，包括梯度优化，以及随机重构型方法。
该软件包支持遍历、直接采样和{{{Metropolis}}}采样作为采样方法。
tetragono通过插件支持定义抽象态和抽象晶格来描述自定义物理模型和{{{PEPS}}}形式，也可以对在包中实现的算法中进行定制，比如马尔可夫链中的采样规则。

tetragono的代码位于仓库的 =/tetragono= 目录下，组织如下：
+ 抽象态 (AbstractState) 实现在  =abstract_state.py=  中。
+ 抽象晶格 (AbstractLattice) 实现在  =abstract_lattice.py=  中。
+ {{{ED}}}算法实现在  =exact_state.py=  中。
+ {{{SU}}}算法实现在  =simple_update_lattice.py=  中。
+ 鉴于采样方法的多样性，相关函数实现在  =sampling_lattice=  子目录中。在这个目录中：
  + =lattice.py=  指定了包含数据的晶格类型和个别采样结果的配置类型。
  + =sampling.py=  包含了若干方法，包括遍历、直接采样和{{{Metropolis}}}采样。
  + =observer.py=  用于从采样结果中测量并计算梯度。
  + 最后，所有这些功能通过 =gradient.py=  中的驱动函数集成并执行。
+ =utility.py=  包含各种工具函数。
+ =auxiliaries=  目录，利用 =lazy_graph= ，如图 [[ref:fig:张量网络态计算套件的结构]] 所述，用于构型类型，包含几个辅助系统，旨在最小化在边界MPO方法和边界MPS方法中张量网络收缩的冗余计算，特别是移除或替换多个格点的张量时。
+ =conversion.py=  中定义了适用于不同算法的对象转换函数。
+ 最后， =shell.py=  提供了一个高层次、用户友好的接口，称为tetragono shell，用于访问tetragono中的所有功能。

用户可以在命令行中执行 =python -m tetragono.shell= 进入 tetragono shell。
在tetragono shell中输入 =help= 或 =?= 将显示可用命令。 要获取特定命令的详细使用信息, 用户可以输入 =help <command>= 。
用户可以在tetragono shell中逐行执行命令, 也可以在脚本文件中列出多个命令, 并使用 =python -m tetragono.shell <script_file>= 运行他们。
通过这种方式, 可以自动利用 MPI [[cite:mpi40,Dalcn2005]] ， 这意味着如果用户使用 =mpirun python -m tetragono.shell <script_file>= 执行脚本文件, tetragono 内部实现的每个算法都将在可能的情况下使用 MPI 并行运行，从而加快程序执行速度。

*** 常见模型合集(tetraku)

我们使用tetragono实现了几种流行的典型物理模型。
这些模型包括{{{L4}}}上的 $J_1-J_2$ 模型、{{{L6}}}上的 {{{Hubbard}}} 模型、{{{L4}}} 上的 {{{Rydberg}}} 模型等。
我们将这些模型收集到 tetraku 库中。
对于这些预定义模型，用户可以直接使用，无需进一步编码。
此外，这些模型也可用作参考，或直接修改以包括额外的相互作用，从而创建更复杂的模型。

** 套件的使用展示

在本章节中，我们通过一个例子展示了 {{{TNSP}}} 中TAT的Python接口的使用。
这是一个使用费米子{{{PEPS}}}方法解决方格晶格上的无自旋费米子模型的例子。
随后，我们重新使用tetragono接口来改写此示例，相较于直接使用TAT，这种方法更为简便。

{{{L4}}} 上自由费米子模型的哈密顿量为
\begin{equation}
H = \sum_{\langle i, j \rangle} (c_i^\dagger c_j + h.c.),
\end{equation}
其中， $\sum_{\langle i, j \rangle}$ 表示对最近邻对 $i$ 格点和 $j$ 格点的求和，本例采用开边界条件（OBC）。
这个模型的波函数将使用费米子张量构成的{{{PEPS}}} 作为{{{Ansatz}}} 表示，并采用 [[ref:sec:::简单更新]] 中介绍的 简单更新的虚时间演化方法 [[cite:Jiang2008]] 来优化这个波函数。

*** 使用Python接口TAT实现的简单更新

我们使用费米-$Z(2)$ 对称性和双精度实张量来处理自由费米子模型，这在TAT中定义为张量类型 =TAT.FermiZ2.float64.Tensor= 。
在代码 [[ref:code:node-for-peps.py]] 中，我们定义了一个数据结构类 =Node= ，用于存储与每个格点相关的数据。
在 =Node= 类结构中， =Tensor= 负责容纳{{{PEPS}}}波函数的最主要的格点张量，该张量是一个五阶张量。
此张量包含四个指标对应于虚拟边，一个阶数用于物理指标。
此外，我们定义了四个环境张量： =left= 、 =right= 、 =up= 和 =down= 。
这些张量用于存储关于四个虚拟指标的环境信息，每个都是一个秩为2的张量，即矩阵。
环境张量的默认值设置为 =None= ，表示环境张量是一个单位矩阵。
边界边没有分配环境张量。
需要注意的是，通过一条边连接的相邻节点共享相同的环境张量。

\begin{lstlisting}[language=Python, label={code:node-for-peps.py}, caption={PEPS中的格点}]
from dataclasses import dataclass
import TAT
from TAT import parity

Tensor = TAT.FermiZ2.float64.Tensor


@dataclass
class Node:
    site: Tensor  # 存储每个格点的张量
    left: Tensor | None = None  # 存储环境张量
    right: Tensor | None = None  # 存储环境张量
    up: Tensor | None = None  # 存储环境张量
    down: Tensor | None = None  # 存储环境张量
\end{lstlisting}

在代码 [[ref:code:init-peps.py]] 中，我们为费米子{{{PEPS}}}波函数生成具有费米-$Z(2)$ 对称性的费米子张量。
在第2-10行，我们准备了五条边，每条边由段（以量子数及其相应简并度的对列表表示）与费米箭头组成。费米箭头表示位于两个张量之间的纠缠对中产生算符的顺序。
对于每条边，费米-$Z(2)$ 对称性可能的两个量子数是偶性(+1)和奇性(-1)。
物理边的简并度统一设置为 =1= 。
虚拟边两个量子数的简并度设置为 =D1= 和 =D2= ，边界边的简并度设置为 =1= 和 =0= 。这里，参数 =D1= 和 =D2= 可以自由设置，只要他们的和等于表示虚拟指标总维度 =D= 。在更新过程中， =D1= 和 =D2= 将自动调整到最佳值。
这里需要注意的是，虽然 $Z(2)$ 对称性内部实现使用 =False= 和 =True= 作为量子数，但是由于历史原因，我们提供了一个接口 =parity(+1)=False= ， =parity(-1)=True= 。

随后，在代码 [[ref:code:init-peps.py]] 的第11-19行中，我们通过Python生成器创建一个二维列表，循环遍历{{{PEPS}}}中的每个点， =l1= 范围从 =0= 到 =L1-1= ， =l2= 范围从 =0= 到 =L2-1= ，其中 =L1= 和 =L2= 是晶格的大小。
该列表由 =Node= 类的实例组成。
张量使用指标的名称构建，例如 =left= 、 =right= 等。
出于历史原因 [[cite:Verstraete2008]] ，这里使用的坐标系统中， =l1= 表示行， =l2= 表示列。当然，用户可以选择自己的坐标系统。
环境张量保持默认值，这意味着对于内部边，环境是一个单位矩阵，而对于边界边，则没有环境张量。

\begin{lstlisting}[language=Python, label={code:init-peps.py}, caption=PEPS的初始化]
def initialPEPS(L1, L2, D1, D2):
    phyEdge           = ([(parity(+1), 1 ), (parity(-1), 1 )], False)
    leftEdge          = ([(parity(+1), D1), (parity(-1), D2)], False)
    boundaryLeftEdge  = ([(parity(+1), 1 ), (parity(-1), 0 )], False)
    rightEdge         = ([(parity(+1), D1), (parity(-1), D2)], True)
    boundaryRightEdge = ([(parity(+1), 1 ), (parity(-1), 0 )], True)
    upEdge            = ([(parity(+1), D1), (parity(-1), D2)], False)
    boundaryUpEdge    = ([(parity(+1), 1 ), (parity(-1), 0 )], False)
    downEdge          = ([(parity(+1), D1), (parity(-1), D2)], True)
    boundaryDownEdge  = ([(parity(+1), 1 ), (parity(-1), 0 )], True)
    return [[
        Node(site=Tensor(["phy", "left", "right", "up", "down"], [
            phyEdge,
            boundaryLeftEdge if l2 == 0 else leftEdge,
            boundaryRightEdge if l2 == L2 - 1 else rightEdge,
            boundaryUpEdge if l1 == 0 else upEdge,
            boundaryDownEdge if l1 == L1 - 1 else downEdge,
        ]).randn_()) for l2 in range(L2)
    ] for l1 in range(L1)]
\end{lstlisting}

哈密顿量是各项局部哈密顿量的和，每个局部哈密顿量是邻近位置 $i$, $j$ 上的两体相互作用 $h_{i,j} = c^\dag_i c_j + c^\dag_j c_i$ 。
其中， $c^\dag_i$ 表示在格点 $i$ 上费米子的生成算符，而 $c_i$ 是从格点 $i$ 的湮灭算符。
算符 $h_{i,j}$ 可视为具有费米-$Z(2)$ 对称性的四阶张量，并可在 TAT 包中表示为相应类型的费米子张量。
在代码 [[ref:code:prepare-H.py]] 的第 1-13 行中，函数 =initialH= 被设计用来准备局部哈密顿量项 $h_{i,j}$ 。
在后续的函数 =initialGate= ， 第 16-18 行中，我们定义了一个门算符 $\mathrm{Gate} = \mathrm{e}^{−\tau h_{i,j}}$，其中 $\tau$ 是时间步长。
门张量的指数函数的形式被定义为展开的级数，如图 [[ref:fig:张量指数的幂展开]] 所示。

\begin{lstlisting}[language=Python, label={code:prepare-H.py}, caption={准备虚时间演化的门张量}]
def initialH():
    # 准备物理指标即其共轭
    edge_out = ([(parity(+1), 1), (parity(-1), 1)], False)
    edge_in  = ([(parity(+1), 1), (parity(-1), 1)], True)
    # 初始化局部哈密顿量为零
    H = Tensor(
        ["Oi", "Oj", "Ii", "Ij"],
        [edge_out, edge_out, edge_in, edge_in],
    ).zero_()
    # 设置局部哈密顿量非零元素
    H[{"Oi": 1, "Oj": 0, "Ii": 0, "Ij": 1}] = 1
    H[{"Oi": 0, "Oj": 1, "Ii": 1, "Ij": 0}] = 1
    return H


def initialGate(H, tau):
    # 从哈密顿量得到演化门算子
    return (-abs(tau) * H).exponential({("Ii", "Oi"), ("Ij", "Oj")})
\end{lstlisting}

在代码 [[ref:code:su-two-site.py]] 中的 =step= 函数中，我们展示了使用门张量对两个格点进行简单更新，如 [[ref:sec:::简单更新]] 中介绍的那样。
\begin{lstlisting}[language=Python, label={code:su-two-site.py}, caption=两个格点上的单步演化]
def step(A, env, B, gate, cutoff, A_dir, B_dir):
    # 为了复用，这里输入的三个张量这样相连
    # -A_dir-[A]-B_dir- -A_dir-[env]-B_dir- -A_dir-[B]-B_dir-
    # A_dir 和 B_dir 是指标名

    # A和B各自进行QR，以将酉部分提取出去，从而降低后续复杂度
    q_A, r_A = A.qr('r', {"phy", B_dir}, B_dir, A_dir)
    q_B, r_B = B.qr('r', {"phy", A_dir}, A_dir, B_dir)
    # 重命名R张量的指标，避免后续冲突
    r_A = r_A.edge_rename({"phy": "Oi"})
    r_B = r_B.edge_rename({"phy": "Oj"})
    # 收缩A、环境的逆（如果非空）、B和门张量
    C = r_A
    if env is not None:
        C = C.contract(env.reciprocal(), {(B_dir, A_dir)})
    C = C.contract(r_B, {(B_dir, A_dir)})
    C = C.contract(gate, {("Oi", "Ii"), ("Oj", "Ij")})
    # 对收缩结果进行SVD，并截断
    new_A, new_env, new_B = C.svd({A_dir, "Oi"}, B_dir, A_dir, A_dir, B_dir, cutoff)
    # 归一化环境张量
    new_env = new_env / new_env.norm_max()
    # 恢复PEPS的形式，将SVD的结果和新环境与先前的酉矩阵收缩
    new_A = new_A \
        .contract(new_env, {(B_dir, A_dir)}) \
        .contract(q_A, {(A_dir, B_dir)}) \
        .edge_rename({"Oi": "phy"})
    new_B = new_B \
        .contract(new_env, {(A_dir, B_dir)}) \
        .contract(q_B, {(B_dir, A_dir)}) \
        .edge_rename({"Oj": "phy"})
    return new_A, new_env, new_B
\end{lstlisting}

在代码 [[ref:code:su.py]] 中，函数 =simple_update= 通过对所有近邻邻点调用 =step= 函数来对整个系统执行单步简单更新。

\begin{lstlisting}[language=Python, label={code:su.py}, caption=PEPS上单步简单更新]
def simple_update(peps, gate, L1, L2, D):
    # 循环所有的横向边
    for l1 in range(L1):
        for l2 in range(L2 - 1):
            # 获取将更新的张量
            A = peps[l1][l2].site
            env = peps[l1][l2].right
            B = peps[l1][l2 + 1].site
            # 调用step
            A, env, B = step(A, env, B, gate, D, "left", "right")
            # 更新张量
            peps[l1][l2].site = A
            peps[l1][l2 + 1].site = B
            peps[l1][l2].right = peps[l1][l2 + 1].left = env
    # 循环所有的竖向边
    for l2 in range(L2):
        for l1 in range(L1 - 1):
            # 获取将更新的张量
            A = peps[l1][l2].site
            env = peps[l1][l2].down
            B = peps[l1 + 1][l2].site
            # 调用step
            A, env, B = step(A, env, B, gate, D, "up", "down")
            # 更新张量
            peps[l1][l2].site = A
            peps[l1 + 1][l2].site = B
            peps[l1][l2].down = peps[l1 + 1][l2].up = env
\end{lstlisting}

定义了 =simple_update= 后， 函数可以直接用于执行简单更新的计算。
代码 [[ref:code:runsu.py]] 中通过在 $4 \times 4$ 格子上执行 $50$ 步简单更新提供了一个示例， 虚拟指标维度被设置为 $D=4$ 。初始态中， $D$ 的一半分配给偶性，另一半分配给奇性 。

\begin{lstlisting}[language=Python,label={code:runsu.py}, caption=使用\texttt{simple\_update}函数]
L1 = L2 = 4
D = 4
tau = 0.1
step_number = 50

peps = initialPEPS(L1, L2, D // 2, D // 2)
gate = initialGate(initialH(), tau)
for i in range(step_number):
    simple_update(peps, gate, L1, L2, D)
\end{lstlisting}

从这个例子中，我们看到通过使用TAT，可以像编写普通的、用于玻色子或自旋系统的{{{PEPS}}}方法那样为费米子系统编写代码。
一旦系统的哈密顿量和初始参数确定，就无需再在后续使用过程中考虑费米子的反对易性质。

*** 使用tetragono实现的简单更新 <<sec:::tet-example>>

在本章节中，我们使用tetragono接口重写了自由费米子模型的简单更新，与直接使用TAT相比，这大大简化了过程。
一旦定义了物理模型，tetragono中实现的每个算法都可以通过一个命令访问。
要描述自定义的物理模型，用户只需定义两个函数： =abstract_state= 用于确定模型的物理指标和哈密顿量，以及 =abstract_lattice= 用于设置{{{PEPS}}}中的虚拟指标。

\begin{lstlisting}[language=Python, label={code:tet-abs-state.py}, caption=自由费米子的描述：\texttt{abstract\_state}]
import TAT
from TAT import parity
import tetragono as tet


def abstract_state(L1, L2):
    # 创建抽象态，大小设置为 L1 * L2
    # 张量类型为 费米-Z(2) 对称性的双精度实浮点数张量
    state = tet.AbstractState(TAT.FermiZ2.D.Tensor, L1, L2)
    # 每个格点一个轨道
    for l1 in range(L1):
        for l2 in range(L2):
            state.physics_edges[l1, l2, 0] = [(parity(+1), 1), (parity(-1), 1)]
    # 获取预定义的CC算符用作哈密顿量
    CC = tet.common_tensor.Parity.CC.to(float)
    # 设置所有近邻格点有CC相互作用
    for l1 in range(L1):
        for l2 in range(L2):
            if l1 != 0:
                state.hamiltonians[(l1 - 1, l2, 0), (l1, l2, 0)] = CC
            if l2 != 0:
                state.hamiltonians[(l1, l2 - 1, 0), (l1, l2, 0)] = CC
    return state
\end{lstlisting}

在代码 [[ref:code:tet-abs-state.py]] 中，我们为自由费米子模型定义了 =abstract_state= ，包括系统大小和张量类型开始，以及每个格点的物理指标。
该指标由两个段组成：一个量子数为偶性 ，另一个为奇性 ；每个段的简并度都是 =1= 。
根据 [[ref:sec:::费米子张量]] 中的讨论，物理指标的费米箭头默认设置为 =False= 。
在tetragono中，每个格点可以承载多个物理指标，并通过其轨道索引区分。
在本例子中，由于每个格点只有一个物理指标，所有轨道索引都是 =0= 。

\begin{lstlisting}[language=Python, label={code:tet-abs-lattice.py}, caption=用于自由费米子的费米子PEPS描述：\texttt{abstract\_lattice}]
def abstract_lattice(L1, L2, D):
    # 从抽象态创建抽象晶格
    lattice = tet.AbstractLattice(abstract_state(L1, L2))
    # 设置竖向边
    for l1 in range(lattice.L1 - 1):
        for l2 in range(lattice.L2):
            lattice.virtual_bond[l1, l2, "D"] = [(parity(+1), D // 2), (parity(-1), D // 2)]
    # 设置横向边
    for l1 in range(lattice.L1):
        for l2 in range(lattice.L2 - 1):
            lattice.virtual_bond[l1, l2, "R"] = [(parity(+1), D // 2), (parity(-1), D // 2)]
    return lattice
\end{lstlisting}

要为给定模型构建{{{PEPS}}}波函数，还需要描述虚拟指标。
这在 =abstract_lattice= 函数中实现，该函数根据在 =abstract_state= 函数获得的虚拟态的基础上，加上虚拟指标信息。
如代码 [[ref:code:tet-abs-lattice.py]] 所示，每个边缘由两个段组成：一个段的量子数为偶性 ，简并度为 =D/2= ；另一个段的量子数为奇性 ，简并度相同。
当我们为格点 =(l1, l2)= 的设置下指标 ="D"= 时，对应格点 =(l1 + 1, l2)= 的上指标 ="U"= 会自动设置为其共轭，水平边上的指标也有相同的行为。

一旦定义了这两个函数，他们可以被保存到如名为 =ff.py= 的文件中。
随后，可以编写一个脚本，如代码 [[ref:code:tet-script.tet]] 所示，以对这个费米子{{{PEPS}}}执行简单更新算法。
在第1行，他初始化一个自由费米子模型的晶格，参数为 =L1=4= 、 =L2=4= 和 =D=4= ，这些参数对应于 =ff.py= 中的 =abstract_lattice= 函数。
在第2行，他应用了简单更新算法，这里指定了总步骤、 $\Delta \tau$ 和简单更新中的维度截断。

\begin{lstlisting}[label={code:tet-script.tet}, caption=创建晶格系统并执行简单更新的 \texttt{tetragono} 脚本]
su_create free_fermion.parity L1=4 L2=4 D=4
su_update 100 0.01 4 # 总步数为100的简单更新，tau=0.01、 D=4
\end{lstlisting}

通过将这个脚本文件保存为如名为 =network_example.tet= 的文件，我们可以使用命令 =python -m tetragono.shell network_example.tet= 运行他，即创建一个 $4 \times 4$ 费米子{{{PEPS}}}上的自由费米子模型，随后进行简单更新。

*** 使用 tetraku 进行的简单更新

无自旋的自由费米子等常见模型已经在 tetraku 库中实现，对于 {{{F}}}-$Z(2)$ 对称性，其被命名为 =free_fermion.parity= 。
因此， [[ref:sec:::tet-example]] 讨论的例子可以通过代码 [[ref:code:tetraku-example.tet]] 中的脚本轻松实现，无需额外编码。

\begin{lstlisting}[label={code:tetraku-example.tet}, caption=使用 \texttt{tetraku} 中的描述文件进行的简单更新]
su_create free_fermion.parity L1=4 L2=4 D=4
su_update 100 0.01 4 # 总步数为100的简单更新，tau=0.01、 D=4
\end{lstlisting}

** 小结

在这项工作中，我们基于C++和Python， 对先前开发的TNSPackage进行了全面升级和优化， 构建了{{{TNSP}}}。
通过重构为C++，我们提升了代码的效率和可维护性，为未来的增强和优化奠定了坚实基础。
此套件扩展了包括 {{{F}}}子 {{{TNS}}}方法的能力，并提供了一种统一的方法来处理玻色子、费米子和各种不同的对称性张量网络态。
{{{TNSP}}}通过抽象掉复杂的张量操作并提供友好的编程接口和用户界面，显著简化了用于处理强关联系统的 {{{F}}} 子 {{{TNS}}}程序的开发。
这一套件包括了底层的TAT包和高级的tetragono接口。
TAT作为一个通用的张量包，可以用于复杂的张量操作，而tetragono则专门设计用于简化在{{{L4}}}上开发复杂的物理模型的过程。
{{{TNSP}}}套件为探索量子多体系统，特别是费米子系统，提供了一套强大且易于使用的工具。

* 六角晶格中的 {{{Hubbard}}} 模型的掺杂基态模拟计算 <<sec:超导>>

** 背景介绍与主要结论

对高温超导现象 [[cite:Bednorz1986,Wu1987]] 的理解是当代凝聚态物理学中最具挑战性的课题之一。
普遍认为，通过研究掺杂的Mott绝缘体 [[cite:Lee2006]] 可以产生高温超导，而 {{{Hubbard}}} 模型 [[cite:Hubbard1964]] 是描述这类绝缘体的基本工具。
然而，多年来的研究表明，在 {{{L4}}} 上原始的 {{{Hubbard}}} 模型并不能产生稳定的超导态 [[cite:Rozhkov2011,Kitatani2019,Qin2020]] 。
这引起了人们对使用{{{Hubbard}}}模型来研究 {{{L6}}} 上电子电子关联的兴趣 [[cite:Pathak2010,BlackSchaffer2014,Wang2012,Xu2016,Jiang2014,Gu2020,Kiesel2012,Raghu2010,Honerkamp2008,Ying2020,Wolf2018,Nandkishore2012,Watanabe2013,Ma2014,Wu2013]] 。
与{{{L4}}}相比，{{{L6}}}因其六边形结构展现出独特的电子特性。
{{{L6}}}的能带结构在费米能级处具有Dirac锥，同时在 $1/8$ 电子和空穴掺杂的情况下，表现出对数型 Van Hove 奇异性以及显著的费米面嵌套现象，
这些特性可能增强 {{{L6}}} 上的长程超导相 [[cite:Pathak2010,Nandkishore2012]]。

尽管在半填充时观察到在约 $U_c = 3.8$ 处有从半金属到反铁磁态的相变 [[cite:Otsuka2016]] ，但关于掺杂对 {{{L6}}}上{{{Hubbard}}}模型中的反铁磁态的影响仍然没有彻底研究。
许多研究都探讨了 {{{L6}}} 上的超导性，但结果存在争议。
一个关于{{{L6}}}上{{{Hubbard}}}模型的 变分{{{QMC}}}（vQMC）研究提出，在掺杂石墨烯中存在具有手性d + id对称性的超导 [[cite:Pathak2010]] 。
另外，另一项QMC模拟也预测了在强相互作用区间会出现金手性 $d + id$ 波超导性 [[cite:BlackSchaffer2014]] 。
同样，{{{Grassmann}}} 张量乘积态（GTPS）研究也表明在大U极限下， $t-J$ 模型中存在手性超导态 [[cite:Gu2013]] 。
然而，最新的密度矩阵重整化群（DMRG）模拟结果与这些研究相矛盾，指出在{{{L6}}}上的掺杂{{{Hubbard}}}模型中，{{{Cooper}}}对关联中没有准长程序 [[cite:Qin2022]] 。

然而，这些数值方法各自有其局限性。
{{{VMC}}} 方法依赖于基于先验知识设定的初态，这可能导致结果有偏。
{{{DMRG}}} 方法对于一维或准一维系统有效，但可能无法充分捕捉二维系统的特性。
此外，文献 [[cite:Gu2013]] 中使用的 {{{Grassmann}}} 张量乘积态 使用了简单更新算法，在时间演化过程中涉及近似处理，可能影响结果的准确性。

为了深入探究{{{L6}}}中{{{Hubbard}}}模型掺杂后的性质，我们在一个较宽的参数范围内通过第 [[ref:sec:张量和张量网络]] 章中介绍的费米子 {{{PEPS}}} 研究了空穴掺杂的{{{L6}}}{{{Hubbard}}}模型。
我们利用 第 [[ref:sec:软件]] 章中的 {{{TNSP}}}， 使用第 [[ref:sec:张量网络态算法]] 章介绍的各种优化方法对 {{{PEPS}}} 进行优化，确保了可控的精度。
这些方法一方面避免了简单更新优化过程中忽略环境影响而导致的误差，另一方面显著降低了与张量网络截断 $D$ 相关的复杂度问题，使得能够利用更大的网络截断，从而在大系统中实现高度精确且收敛的结果。
我们观察到准长程超导秩序的存在，其特征是 {{{Cooper}}} 对关联随距离呈幂律衰减，但衰减指数 $K > 1$ 。
我们还研究了系统中的竞争相，包括{{{CDW}}}（CDW）序和{{{AFM}}}（AFM）序。
结果发现，在低掺杂浓度下，基态呈现 {{{AFM}}} 序，然而随着掺杂浓度的增加，这一秩序逐渐减弱，并最终在 $\delta>0.05$ 时消失。
相比之下，即使在较高的掺杂浓度下，基态仍持续表现出稳定的 {{{CDW}}} 序。

** 计算方法

{{{Hubbard}}}模型的哈密顿量公式为
\begin{equation}
H = -t \sum_{\langle i,j \rangle, \sigma} \left( c_{i, \sigma}^\dagger c_{j, \sigma} + \text{h.c.} \right) + U \sum_i n_{i \uparrow} n_{i \downarrow},
\end{equation}
其中， $t$ 和 $U$ 分别为相邻格点之间的跃迁参数和格点上的库伦相互作用。
这里， $c_{i, \sigma}$ 表示在格点 $i$ 处具有自旋 $\sigma$ 的电子湮灭算符，且 $n_{i\sigma} = c_{i\sigma}^\dagger c_{i\sigma}$ 。 本文中，默认 $t = 1$ 。

该哈密顿量的多粒子波函数由费米子{{{PEPS}}}表示。为了简化实现，我们将{{{L6}}}映射到如图 [[ref:fig:六角格子映射]] 所示的方格子上。
对于方格子上的每个格点，我们定义一个承载{{{L6}}}上的两个物理指标的张量，左上和右下两个角上的张量除外，他们依然只有一个物理指标。
因此，{{{PEPS}}}中的大部分张量的物理指标维度为 $4^2 = 16$ 。

#+begin_export latex
\begin{figure}
\centering
\includegraphics[width=0.6\textwidth]{figures/honeycomb.pdf}
%\caption{六角晶格到方格子的映射}
%\note{注：
\caption{六角晶格到方格子的映射。
六角晶格到方格子的映射，用于 投影纠缠对态 方法。每个灰色椭圆对应于 投影纠缠对态 中一个单独的张量，他们包含了两个六角晶格的格点，左下角和右上角除外。黄色区域表示选择用于计算库珀对关联函数的区域。
}
\label{fig:六角格子映射}
\end{figure}
#+end_export

我们首先通过应用简单更新方案来优化{{{PEPS}}}波函数  [[cite:Jiang2008]]  。
得出的{{{PEPS}}}波函数随后作为初始态，利用梯度下降法进行进一步优化  [[cite:Sandvik2007,Liu2017,Dong2019]] 。
在整个优化过程中，总粒子数始终保持守恒，以确保符合预期的掺杂浓度。
这一守恒性是通过强制要求 {{{PEPS}}}的 {{{F}}}-$U(1)$ 对称性来实现的 [[cite:Singh2010]] 。
在简单更新过程中，我们通过降序排列奇异值并保留最大的奇异值来截断虚拟指标，从而决定虚拟指标上量子数的选择。
通过简单更新过程确定的虚拟指标量子数随后不再更新并用于梯度下降优化计算。
为了计算能量和梯度，我们采用了文献 [[cite:Vieijra2021]] 中提出的直接采样技术。
这种方法非常高效，因为避免了采样构型之间的关联，提高了计算效率和结果精度。
从最初的虚拟指标维度 $D=4$ 开始，我们在简单更新过程中，逐步增加维度到 $D=16$ ，使能量收敛到约 $10^{-3}$ 的水平，如图 [[ref:fig:超导D收敛]] 所示。
边界MPS方法中的截断维度被设置为 $D_c=2D$ ，同时，在优化{{{PEPS}}}过程中使用的采样数设定为 $N=10^4$ 。
这些优化步骤和参数选择确保了我们在计算中能够获得准确和可靠的结果，为后续分析提供可靠的基础。

#+begin_export latex
\begin{figure}
\centering
\includegraphics[width=0.6\textwidth]{figures/converge-D.pdf}
%\caption{六角晶格上哈伯德模型的能量随 $D$ 的收敛图}
%\note{注：
\caption{六角晶格上哈伯德模型的能量随 $D$ 的收敛图。
对于 $10 \times 10$ 的晶格（ $198$ 个格点 ），在参数 $U=8$ 和 $δ=0.1$ 的情况下，系统的能量作为虚拟指标维度 $D$ 的倒数的函数呈现收敛趋势。当 $D$ 接近 $16$ 时，能量大约收敛到 $10^{-3}$。
}
\label{fig:超导D收敛}
\end{figure}
#+end_export

我们获得基态波函数后，则利用直接采样技术 [[cite:Vieijra2021]] 计算物理量和关联函数。
为了确保高精度，采样次数设定为 $10^5$ 次。此外，我们在此还提高了截断维度到 $D_c = 6D$ ，以尽可能减少截断误差。

** 计算结果与分析

*** 超导性质

我们首先研究了在 {{{L6}}} 上的空穴掺杂{{{Hubbard}}}模型的超导现象存在的可能性。
在{{{L6}}}上，单态和三态的{{{Cooper}}}对算符分别定义为
\begin{equation}
\left\{
\begin{aligned}
\Delta_s^a(i) &= \frac{1}{\sqrt{2}}(c_{i\uparrow}c_{j\downarrow} - c_{i\downarrow}c_{j\uparrow}) ,\\
\Delta_t^a(i) &= \frac{1}{\sqrt{2}}(c_{i\uparrow}c_{j\downarrow} + c_{i\downarrow}c_{j\uparrow}) ,\\
\end{aligned}
\right.
\end{equation}
其中，$j = i + a$，$a$ 是围绕格点 $i$ 的三条边的方向之一。
{{{Cooper}}}对可以根据他们的对称性进一步组合分类，他们都是 $\Delta_s^a(i)$ 和 $\Delta_t^a(i)$ 的线性组合。

具有超导性的系统可以根据其{{{Cooper}}}对配对的对称性进行分类。在{{{L6}}}上，可能的{{{Cooper}}}对对称性在文献 [[cite:Faye2015]] 中被定义为单态或三态对的组合，具体表达式如下为
\begin{equation}\label{eq:cooper-sym}
\left\{
\begin{aligned}
    \Delta_{s}(i)    &= \Delta^s_1(i) + \Delta^s_2(i) + \Delta^s_3(i) , \\
    \Delta_{d+id}(i) &= \Delta^s_1(i) + e^{2\pi i/3} \Delta^s_2(i) + e^{4\pi i/3}\Delta^s_3(i) , \\
    \Delta_{d-id}(i) &= \Delta^s_1(i) + e^{-2\pi i/3} \Delta^s_2(i) + e^{-4\pi i/3}\Delta^s_3(i) , \\
    \Delta_{f}(i)    &= \Delta^t_1(i) + \Delta^t_2(i) + \Delta^t_3(i) , \\
    \Delta_{p+ip}(i) &= \Delta^t_1(i) + e^{2\pi i/3} \Delta^t_2(i) + e^{4\pi i/3}\Delta^t_3(i) , \\
    \Delta_{p-ip}(i) &= \Delta^t_1(i) + e^{-2\pi i/3} \Delta^t_2(i) + e^{-4\pi i/3}\Delta^t_3(i) .
\end{aligned}
\right.
\end{equation}
在此， $\Delta_1$ 、 $\Delta_2$ 和 $\Delta_3$ 分别三条边上的{{{Cooper}}}对，如图 [[ref:fig:cooper-pairs]]。

#+begin_export latex
\begin{figure}
\centering
\includegraphics[width=0.6\textwidth]{cooper-pairs.pdf}
%\caption{六角晶格上库珀对的对称性示意图}
%\note{注：
\caption{六角晶格上库珀对的对称性示意图。
(a) 对于 $s$ 波和 $f$ 波对，三个库珀对具有相同的相位；
(b) 对于 $p$ 波和 $d$ 波对，三个库珀对 $\Delta_1$ 、 $\Delta_2$ 和 $\Delta_3$ 分别具有相同的、 ${\rm exp(\pm 2/3 \pi i)}$ 和 ${\rm exp(\pm 4/3 \pi i)}$ 相位。
}
\label{fig:cooper-pairs}
\end{figure}
#+end_export

根据以往研究 [[cite:Pathak2010,BlackSchaffer2014,Xu2016]] ，有一些证据支持在 {{{L6}}} 上的{{{Hubbard}}}模型中存在超导性。
例如，变分{{{QMC}}}研究表明，在 $U = 2.4$ 和 $\delta = 0.2$ 的情况下，{{{Hubbard}}}模型中的单态{{{Cooper}}}对具有恒定关联 [[cite:Pathak2010]] 。
此外，基于 {{{Grassmann}}} 张量乘积态 的变分方法在大 $U$ 极限 （即 $t-J$ 模型）下显示出非零的{{{Cooper}}}对，表明该系统中可能存在超导性 [[cite:Gu2013]] 。
然而，他们的研究并未计算{{{Cooper}}}对的关联函数。
而最近的{{{DMRG}}}和变分{{{QMC}}}计算则表明，{{{L6}}}的{{{Hubbard}}}模型中不存在超导性 [[cite:Qin2022]] 。该研究发现{{{Cooper}}}对的关联长度是有限的。
为了进一步研究优化后的态中的超导性可能性，我们计算了跨越两列的区域内{{{Cooper}}}对的关联函数，如图 [[ref:fig:六角格子映射]] 所示。

{{{Cooper}}}对的关联函数定义为
\begin{equation}
C(\Delta r) = \frac{1}{N} \sum_{|{r}_1 - {r}_2| = \Delta r} |\langle \Delta({r}_1)^\dagger \Delta({r}_2) \rangle|,
\end{equation}
其中， $r_1$ 和 $r_2$ 为图 [[ref:fig:六角格子映射]] 所示的长条区域中满足 $|{r}_1 - {r}_2| = \Delta r$ 条件的点。
关联函数由对相同 $\Delta r$ 的N个对关联进行平均得到的。
当 $\delta = 0$ 时，基态是{{{AFM}}} (AFM)绝缘体，{{{Cooper}}}对关联函数应呈指数衰减，这一点通过我们的数值计算得到验证，如图 [[ref:fig:指数衰减的超导]]。

#+begin_export latex
\begin{figure}
\centering
\includegraphics[width=0.6\textwidth]{exp-decay.pdf}
%\caption{六角晶格上哈伯德模型上 反铁磁态的库珀关联衰减趋势}
%\note{注：
\caption{六角晶格上哈伯德模型上 反铁磁态的库珀关联衰减趋势。
库珀对关联函数在 $\delta=0$ 时呈指数衰减。 系统为 $198$ 个格点的六角Hubbard模型；(a) $U=4$, (b) $U=8$, (c) $U=12$ 。}
\label{fig:指数衰减的超导}
\end{figure}
#+end_export

图 [[ref:fig:超导power-law]] 展示了在不同掺杂浓度下， $U=8$ 时的{{{Cooper}}}对关联函数。
具体来说，图 [[ref:fig:超导power-law]] (a) 显示了$\delta = 0.05$ 时的关联函数。
单态和三态的关联函数均表现出幂律衰减现象，即
\begin{equation}
C(\Delta r) \propto \Delta r^{-K} .
\end{equation}
然而，拟合出的衰减指数 $K_s \sim K_t = 3.8$ 非常大，表明关联函数迅速趋近于零。
其中， $K_s$ 表示单态的衰减指数，$K_t$ 表示三态的衰减指数。
这些结果说明，在这一掺杂浓度下， {{{L6}}} 上的{{{Hubbard}}}模型的超导性被抑制了。

#+begin_export latex
\begin{figure}
\centering
\includegraphics[width=0.6\textwidth]{power-decay.pdf}
%\caption{六角晶格上哈伯德模型上 幂律衰减下的库珀对关联函数}
%\note{注：
\caption{六角晶格上哈伯德模型上 幂律衰减下的库珀对关联函数。
在198个格点的六角晶格上，对于不同的空穴掺杂浓度 $\delta$ ，计算了 $U = 8$ 时的单态和三态库珀对关联函数 $C(\Delta r)$ 。
关联函数和 $\Delta r$ 均使用对数刻度表示。
实线为通过幂律衰减函数拟合的结果：$ C(\Delta r) \propto \Delta r^{-K} $ 。
}
\label{fig:超导power-law}
\end{figure}
#+end_export

图 [[ref:fig:超导power-law]] (b) 和图 [[ref:fig:超导power-law]] (c)分别展示了 $\delta = 0.15$ 和 $\delta = 0.25$ 时的关联函数。
与 $\delta = 0.05$ 的情况类似，这些关联函数也表现出幂律衰减。
拟合出的衰减指数 $K$ 随着掺杂浓度的增加而减小。
对于 $\delta = 0.15$ ， $K \sim 1.5$ ，而对于 $\delta = 0.25$ ， $K \sim 1.2$ 。
在三角格子上的 $t-J$ 模型中也发现了类似的幂律衰减现象 [[cite:Jiang2021]]。

随后，我们在更广阔的参数区间中进行了{{{Hubbard}}}模型的模拟，参数 $U$ 从 $4$ 到 $12$ ，探索了不同的掺杂浓度。
由于之前的研究表明， 当 $U < U_c \approx 3.8$ 时，在广泛的掺杂范围内，{{{L6}}}上的{{{Hubbard}}} 模型基态为半金属 [[cite:Otsuka2016]] ，因此我们未研究 $U < 4$ 的情况。
我们的发现表明，在这些特定参数范围内，关联函数始终表现出幂律衰减行为。
单态($K_s$)和三态($K_t$)关联的衰减指数总结在图 [[ref:fig:k-plot]] 中，可以观察到几个显著的趋势。
随着掺杂浓度的增加，衰减指数 $K_s$ 和 $K_t$ 的值趋于减小。
对于 $U = 4$ 且掺杂浓度 $\delta$ 超过 $0.05$ 的情况， 参数 $K$ 始终小于2。
在 $\delta=0.2$ 的情况下， $K_s$ 和 $K_t$ 均接近 $1$ 。
此外，对于 $U = 8$ 且 $\delta$ 大于 $0.1$ 的情况，衰减指数 $K$ 继续保持在2以下，表明当温度趋近于0时超导磁化率发散 [[cite:Peng2023]] 。
有人提出在 Van Hove 奇点附近可能会发展出长程超导序 [[cite:Pathak2010,Nandkishore2012]]。
然而，图 [[ref:fig:k-plot]] 中 $1/8$ 掺杂附近的结果并未显示出显著的行为。

#+begin_export latex
\begin{figure}
\centering
\includegraphics[width=0.6\textwidth]{k-plot.pdf}
%\caption{六角晶格上哈伯德模型上 基态库珀对关联衰减指数$K$}
%\note{注：
\caption{六角晶格上哈伯德模型上 基态库珀对关联衰减指数$K$。
在包含198个格点的六角晶格上，不同的相互作用强度 $U$ 下， 单态对关联函数的幂律衰减指数 $K_s$ 和三态对关联函数的幂律衰减指数 $K_t$ 随空穴掺杂 $\delta$ 的变化关系。
(a) 单态对关联函数的幂律衰减指数 $K_s$ 随空穴掺杂 $\delta$ 的变化关系；
(b) 三态对关联函数的幂律衰减指数 $K_t$ 随空穴掺杂 $\delta$ 的变化关系。
}
\label{fig:k-plot}
\end{figure}
#+end_export

在空穴掺杂 $\delta=0.25$ 时， $K_s$ 接近 $1$ 。
然而，当 $U$ 达到 $12$ 且 $\delta=0.15$ 时，$K$ 的值超过了其他空穴浓度下的观察值。
这可能归因于存在一种竞争序，抑制了超导相。
值得注意的是，即使使用公式 [[eqref:eq:cooper-sym]] 中定义的对称库珀对计算对关联函数，这些结果依然保持一致且稳定。

在之前的一项研究中，秦明普利用 {{{DMRG}}}（DMRG）计算分析了 {{{L6}}} 上的{{{Hubbard}}}模型，结果表明超导序具有指数衰减的特性 [[cite:Qin2022]]。
需要注意的是，这些计算是在一个长而窄的准一维格子上进行的。
而我们的研究结果显示，对关联在距离 $\Delta r < 8$ 范围内呈现幂律衰减，在 $\Delta r = 8$ 处对关联值约为 $10^{-5} \sim 10^{-4}$ 。
在此距离范围内，我们的结果与文献 [[cite:Qin2022]] 的报告结果一致。
然而，文献 [[cite:Qin2022]] 的结果在 $\Delta r > 8$ 时显示出更快的衰减，可以用指数函数拟合。
这种差异可能来源于文献 [[cite:Qin2022]] 中使用的窄准一维格子。
在文献 [[cite:Peng2023]] 中，也观察到了库珀对关联的幂律衰减。
但值得注意的是，该文中报告的衰减指数比我们研究中得到的要小。

*** {{{AFM}}}序与{{{CDW}}}序

与超导有竞争关系的相态中，最常观察到的两种相是{{{AFM}}}（AFM）和{{{CDW}}}（CDW）。
图 [[ref:fig:sc-lattice]] 显示了在 $U = 12$ 和 $\delta = 0.05$ 条件下， 198个格点的系统的空穴密度 $n_h = 1 - n_{\uparrow} - n_{\downarrow}$ 和自旋密度 $S_z = \frac{1}{2}(n_{\uparrow} - n_{\downarrow})$。
在图 [[ref:fig:sc-lattice]] 中，圆圈的大小对应于空穴密度，而颜色则表示自旋密度的方向和大小。
系统表现出带有畴壁结构的弱反铁磁性。
空穴密度的空间变化则暗示了可能存在{{{CDW}}}序。
最近的{{{DMRG}}}结果也揭示了在 $1/16 < \delta < 1/12$ 范围内，$U = 8$ 条件下，长而窄的{{{L6}}}（最多 $4 \times 32$ 个格子）上的电荷和自旋均处在条纹状态 [[cite:Qin2022]]。
在文献 [[cite:Qin2022]] 中，这些条纹垂直于系统的长边边界，这可能与系统尺寸和圆柱形边界条件有关。
我们的结果为这些条纹图案提供了额外的证据。

#+begin_export latex
\begin{figure}
\centering
\includegraphics[width=0.6\textwidth]{sc-lattice.pdf}
%\caption{六角晶格上哈伯德模型的基态实空间图}
%\note{注：
\caption{六角晶格上哈伯德模型的基态实空间图。
六角晶格上哈伯德模型在 $U=12$ 和 $\delta=0.05$ 条件下，198个格子上的空穴密度 $\langle n_h \rangle$ 和自旋 $\langle S_z \rangle$ 。
颜色方案表示 $S_z$ 的幅值，红色表示自旋上，蓝色表示自旋下。圆圈的大小对应于空穴密度。
}
\label{fig:sc-lattice}
\end{figure}
#+end_export

在 $\delta = 0.05$ 和较大 $U$ 值的情况下，存在畴壁结构。
然而，当 $U$ 下降至 $U = 8$ 时，畴壁结构减弱，并在 $U = 4$ 时完全消失。
另一方面，当 $\delta$ 增加到 $0.10$ 时，畴壁结构也会消失。

为了更定量地描述基态性质，我们计算了空穴和自旋的结构因子，定义为
\begin{equation}
\left\{
\begin{aligned}
S_{h}(\mathbf{k}) &= \frac{1}{\delta^2N^2}\sum_{i,j}\langle n_h^i n_h^j  e^{2\pi i (\mathbf{R}_i-\mathbf{R}_j)\cdot \mathbf{k}}\rangle, \\
S_{z}(\mathbf{k}) &= \frac{1}{N^2}\sum_{i,j}\langle S_z^i S_z^j e^{2\pi i (\mathbf{R}_i-\mathbf{R}_j)\cdot \mathbf{k}}\rangle,
\end{aligned}
\right.
\end{equation}
其中 $N$ 是系统中的总格点数。
为了最小化边界效应，我们在求和时排除了位于边界上的格点。
在 $U = 12$ 和 $\delta = 0.05$ 时，空穴和自旋的结构因子如图 [[ref:fig:k-space]] (a)和(b)所示。
空穴结构因子显示出具有动量 $(4/3\pi, 0)$ 的电荷密度波 (CDW)序 ，如 $S_h(\mathbf{k})$ 在 $K$ 点的峰值所示。
这里的 {{{CDW}}} 序可能来源于费米面嵌套和电子-电子关联， 进一步讨论请参见文献 [[cite:Nandkishore2012,Hur2009]] 。
同样，自旋结构因子在 $K$ 点附近也显示出峰值，表明存在反铁磁 (AFM) 序。
这与方格子上的 {{{AFM}}} 不同，后者的自旋结构峰值在 $(\pi, \pi)$。

#+begin_export latex
\begin{figure}
\centering
\includegraphics[width=0.6\textwidth]{k-space.pdf}
%\caption{六角晶格上哈伯德模型的基态中空穴和自旋的结构因子}
%\note{注：
\caption{六角晶格上哈伯德模型的基态中空穴和自旋的结构因子。
(a) 空穴结构因子 $S_{h}({\bf k})$ 和 (b) 自旋结构因子 $S_z ({\bf k})$ 。
系统为198个格点的哈伯德模型模型，$U=12$ , $\delta=0.05$ 。
}
\label{fig:k-space}
\end{figure}
#+end_export

为了表征系统在不同 $U$ 和 $\delta$ 下的整体趋势，我们计算了不同参数下的自旋结构因子 $S_z (K)$ 和空穴结构因子 $S_h(K)$。
在图 [[ref:fig:factor-plot]] (a)、(b)、(c) 和 (d) 中，我们分别展示了 $U$ 值为 $16$ 、 $12$ 、 $8$ 和 $4$ 的结果。
反铁磁（AFM）序在不同 $U$ 下表现出类似的趋势，即随着空穴掺杂 $\delta$ 的增加而减小。
同样地，电荷密度波（CDW）序在不同 $U$ 参数下也表现出类似的趋势。
在 $\delta = 0$ 时，即未掺杂时，基态在 $U > 3.8$ 时预计为 {{{AFM}}}态 [[cite:Otsuka2016]]，这得到了我们的计算结果的验证。
然而，随着掺杂浓度的增加 ($\delta > 0$），{{{AFM}}} 序迅速减弱，在 $\delta=0.1$ 时几乎接近于零。
不过，在 $\delta = 0.05$ 时，我们仍然可以观察到显著的 {{{CDW}}} 序，这展现在一个较大的 $S_h(K)$ 值上。
随着掺杂浓度的进一步增加，{{{CDW}}} 序逐渐减弱。
然而，即使在相对较高的掺杂浓度如 $\delta = 0.2$ 时，仍然存在相当显著的 {{{CDW}}} 序。
这些发现表明，系统从 $\delta = 0$ 时的 {{{AFM}}} 基态逐渐过渡到随着掺杂浓度增加带来的 {{{CDW}}} 主导状态。
{{{AFM}}} 序逐渐被抑制，而 {{{CDW}}} 序变得更加显著。
即使在较高的掺杂浓度下，显著的 {{{CDW}}} 序仍然存在。

#+begin_export latex
\begin{figure}
\centering
\includegraphics[width=0.6\textwidth]{factor-plot.pdf}
%\caption{六角晶格上哈伯德模型各个参数下的反铁磁序与电荷密度波序}
%\note{注：
\caption{六角晶格上哈伯德模型各个参数下的反铁磁序与电荷密度波序。
反铁磁（AFM，$S_{z}(K)$，用红色菱形表示）和电荷密度波（CDW，$S_{h}(K)$，用蓝色方块表示）的序参数，分别对应 (a) $U=4$，(b) $U=8$，(c) $U=12$ 和 (d) $U=16$，掺杂 $\delta$ 从 $0.00$ 到 $0.20$，系统为一个  198个格点的六角晶格上哈伯德模型。
}
\label{fig:factor-plot}
\end{figure}
#+end_export

为了研究有限尺寸效应的影响，我们考察了不同晶格尺寸下反铁磁（AFM）序和电荷密度波（CDW）序随空穴掺杂 $\delta$ 的变化情况，特别是针对 $U = 12$ 的情况。
相应的结果如图 [[ref:fig:finite-scaling-cdw-afm]] 所示。
我们发现，随着晶格尺寸的增加，{{{AFM}}} 序和 {{{CDW}}} 序的结果逐渐收敛。
值得注意的是，在 198 个站点的晶格上，有限尺寸效应已经变得很小。
因此，对于这一晶格尺寸所得到的结果可以认为是对系统基态性质的可靠近似。

#+begin_export latex
\begin{figure}
\centering
\includegraphics[width=0.6\textwidth]{finite-scaling-cdw-afm.pdf}
%\caption{六角晶格哈伯德模型上 反铁磁与电荷密度波序 的有限尺寸效应}
%\note{注：
\caption{六角晶格哈伯德模型上 反铁磁与电荷密度波序 的有限尺寸效应。
(a) 反铁磁序 $S_{z}(K)$ 和 (b) 电荷密度波序 $S_{h}(K)$ 关于 $\delta$ 的变化趋势，系统为 $U=12$ 时， 198个格点的六角晶格上哈伯德模型。
}
\label{fig:finite-scaling-cdw-afm}
\end{figure}
#+end_export

超导（SC）与电荷密度波（CDW）之间的关系是当前研究热点。
尽管普遍认为 {{{SC}}} 和 {{{CDW}}} 是竞争相，但仍有研究表明 {{{SC}}} 序和 {{{CDW}}} 序 可以共存，例如文献 [[cite:Morosan2006,Wang2015]] 中的实例。
因此，这仍然是一个活跃的研究领域，这些相之间的关系依然是一个未解之谜。

** 小结

我们通过使用费米子 {{{PEPS}}} 方法研究了 {{{L6}}} 上空穴掺杂的{{{Hubbard}}}模型的基态。
我们在 从 $\delta=0$ 到 $0.25$ 的广泛空穴掺杂浓度，以及从 $U/t=4$ 到 $16$ 的相互作用强度范围的参数空间内，发现{{{Cooper}}}对表现出准长程序，遵循幂律衰减，衰减指数 $K$ 大于 $1$ 但小于 $2$ 。
此外，我们的研究揭示，在低掺杂浓度下，基态表现出反铁磁（AFM）序。
然而，随着掺杂浓度的增加，这种有序性逐渐减弱，最终在 $\delta > 0.05$ 时消失。
相反，基态始终表现出持续的电荷密度波（CDW）序。
这些观察结果表明，系统的基态从 $\delta = 0$ 的 {{{AFM}}} 主导的状态逐渐过渡到随着掺杂浓度增加的 {{{CDW}}} 主导的状态。
此外，在大 $U$ 和小 $\delta$ 区域，系统显示出明显的畴壁结构。

* 基于自然梯度法的有限温算法 <<sec:有限温>>

** 背景介绍

二维强关联系统可以承载许多引人入胜的现象，包括量子自旋液体 [[cite:Savary2016,Zhou2017,Broholm2020]] 和高温超导 [[cite:Bednorz1986,Keimer2015]] 等。
{{{QMC}}}（QMC）方法在研究部分二维量子多体系统方面取得了巨大成功，但在研究阻挫和费米子系统时，常常受到``符号问题''的困扰。
开发新型数值方法来探索二维强关联系统对于现代凝聚态物理学至关重要。
近年的{{{TNS}}} 方法已成为处理二维阻挫系统和费米子系统的强大工具 [[cite:Verstraete2008,Ors2014,Cirac2021]]。
通过捕捉量子多体系统的纠缠结构，{{{TNS}}} 方法能够设计出高效且忠实的系统表示。
张量网络方法在模拟二维强关联系统方面取得了丰硕成果，但迄今为止，这些方法主要应用于零温条件下。

然而，真实的物理系统总是存在于有限温度下。
此外，在有限温度下会出现更丰富的物理现象。
因此，有必要开发能够模拟有限温度下量子多体系统的张量网络方法。
一些研究 [[cite:Czarnik2015,Kshetrimayum2019,Chen2018,Li2023,White2009,Stoudenmire2010,Wietek2021,Schmoll2024]], 在使用张量网络处理二维热量子多体系统方面取得了一些进展。
一类方法是基于无限投影纠缠对态 (iPEPS) 或无限投影纠缠对算子 (iPEPO) 来模拟二维热态 [[cite:Czarnik2015,Kshetrimayum2019,Schmoll2024]] 。
这种方法通过在 {{{PEPS}}} 上施加平移不变性来模拟热力学极限中的热系统。
然而，这种限制使其无法模拟长程相互作用和破坏平移不变性的系统。
另一类方法是使用一维{{{MPS}}} (MPS) 或矩阵乘积算子 (MPO) 来模拟二维量子态 [[cite:Chen2018,Li2023,White2009,Stoudenmire2010,Wietek2021]] 。
然而，为了满足二维面积定律，严格表示二维量子态所需的 {{{MPS}}} 截断维度会随着系统宽度的增加而呈指数增长，从而将该方法限制在准一维系统中。

将{{{PEPS}}}（PEPS）与 {{{VMC}}}（VMC）方法相结合[[cite:Liu2017,Liu2021,Vieijra2021]]，提供了一种可扩展的方法来处理二维强关联系统。
这种方法已被用于求解各种量子自旋系统 [[cite:Liu2018,Liu2022,Liu2022b,Zhang2022]] 和费米子系统[[cite:Dong2019,Dong2020]] 的基态。
最近的研究 [[cite:Lu2024]] 使用了多种{{{Ansatz}}}（包括{{{PEPS}}}）结合{{{VMC}}}方法，通过最小化修正的自由能来获得特定温度下的热态，但模拟仅限于伊辛型模型。

在此工作中，我们基于{{{PEPS}}}的{{{VMC}}}方法 [[cite:Liu2017,Liu2021,Vieijra2021]] ，发展出一套计算有限温系统的方法。
此方法由于使用张量网络态表示波函数，所以可以有效表示阻挫系统，也可以利用 [[ref:sec:::费米子张量]] 中介绍的费米子张量无缝地拓展到费米子系统，
我们通过对密度矩阵进行矢量化 [[cite:Kshetrimayum2019,Kshetrimayum2017]] ，我们将量子多体系统的有限温态的密度矩阵映射为 {{{PEPS}}}。
将自无穷温开始的降温过程，转变成自然梯度、也就是随机重构型 [[cite:Sorella1998,Sorella2001]] 的优化过程。
而降温过程中，我们会得到一系列不同温度的状态。
不同于之前使用简单更新实现近似的虚时间演化​​工作 [[cite:Kshetrimayum2019,Schmoll2024]] ，此方法直接等价于在表示空间中进行虚时间演化 [[cite:Takai2016,Nomura2021,Hendry2022,Nys2023]] 。
其变分地更新 {{{PEPS}}} 网络，保证了精确地降温过程。
本方法继承了变分蒙特卡洛和 {{{PEPS}}} 计算基态的优势[[cite:Liu2017,Liu2021,Vieijra2021]] ，可以大规模并行化实现，并且只需要收缩单层张量网络即可计算观测量与梯度，这些都极大简化了计算的过程。

我们使用 第 [[ref:sec:软件]] 章的 {{{TNSP}}} 实现了此方法，并应用于量子自旋模型和费米 {{{Hubbard}}}模型中。
我们将本方法的结果与其他数值方法在做对比，包括严格对角化、 {{{SSE}}} (SSE) [[cite:Sandvik1991,Sandvik1992]] 和 {{{DQMC}}} (DQMC) [[cite:Blankenbecler1981,Hirsch1983,Hirsch1985]] 。
我们的对比结果显示，此方法的结果于那些基准结果保持一致，证明了此方法的准确性和可靠性。

** 方法

对于给定系统的哈密顿量 $H$ ，温度 $T=1/\beta$ 时，热态密度矩阵（未归一化）为
\begin{equation}
\rho(\beta) = \mathrm{e}^{-\beta H} ,
\end{equation}
故而我们可以写成
\begin{equation} \label{eq:原始降温公式}
\rho(\beta) = \mathrm{e}^{-\frac{\beta}{2} H} I \mathrm{e}^{-\frac{\beta}{2} H} ,
\end{equation}
其中 $I$ 是恒等矩阵，对应着无穷温处的热态( $\beta=0$ )。
可以将公式 [[eqref:eq:原始降温公式]] 写成演化形式，即
\begin{equation} \label{eq:矩阵演化方程}
- \frac{\mathrm{d}}{\mathrm{d} \beta}\rho(\beta) = \frac{H}{2} \rho(\beta) + \rho(\beta) \frac{H}{2}
\end{equation}

而对于希尔伯特空间为 $V$ 的系统， 密度矩阵 $\rho$ 可以被矢量化为 $V \otimes V$ 空间中的向量，即
\begin{equation}
\rho = \sum_{ss'} \rho_{ss'} |s\rangle\langle s'| \to |\rho\rangle_\sharp = \sum_{ss'} \rho_{ss'} |s\rangle \otimes |s'\rangle.
\end{equation}
将公式 [[eqref:eq:矩阵演化方程]] 进行矢量化，我们得到
\begin{equation}
-\frac{\mathrm{d}}{\mathrm{d}\beta} |\rho(\beta)\rangle_\sharp = \frac{H \otimes I + I \otimes H^T}{2} |\rho(\beta)\rangle_\sharp .
\end{equation}

令 $H' =  \frac{H \otimes I + I \otimes H^T}{2}$ ，我们有
\begin{equation} \label{eq:矢量演化方程}
-\frac{\mathrm{d}}{\mathrm{d}\beta} |\rho(\beta)\rangle_\sharp = H' |\rho(\beta)\rangle_\sharp .
\end{equation}
而公式 [[eqref:eq:矢量演化方程]] 正是虚时间演化的演化方程，即
\begin{equation}
|\rho(\beta)\rangle_\sharp = \mathrm{e}^{-\beta H'}|\rho(0)\rangle_\sharp .
\end{equation}
这意味着，我们可以设 $|\rho(0)\rangle_\sharp=|I\rangle_\sharp$ ，即以矢量化的恒等矩阵作为无穷温度的初始状态，并进行虚时间演化，从而得到系统的降温过程。

对于二维的多体系统， $|\rho(\beta)\rangle_\sharp$ 可以被表示为 {{{PEPS}}}:
\begin{equation}
|\rho(\beta)\rangle_\sharp = \sum_{S_0,\cdots,S_{N-1}=0}^{d^2-1} \prod_i T_i^{S_i} |S_0\cdots S_{N-1}\rangle.
\end{equation}
这里由于先前的矢量化，
{{{PEPS}}}网络中每一个物理指标维度为 $d^2$ ，其中 $d$ 为原物理系统的物理指标维度。
而每个格点的构型 $|S_i\rangle = |s_i\rangle |s'_i\rangle$ ，由物理指标和矢量化的共轭物理指标直积得到。
$T_i^{S_i}$ 是第 $i$ 个格点处的张量，其中 $N$ 为总的格点数。

我们可以在 {{{PEPS}}} 表示上使用 {{{SU}}} 方法 [[cite:Jiang2008]] 或者 完整更新方法[[cite:Jordan2008]] 来实现 公式 [[eqref:eq:矢量演化方程]] 的演化。
但是这些方法或有较大误差或计算量太大，本工作选择使用自然梯度法，也就是{{{SR}}}方法 [[cite:Sorella1998,Sorella2001]] 进行变分地降温。
考虑直接在希尔伯特空间中，给定某个态 $|\psi\rangle$ ，给定某个哈密顿量 $O$ ，其能量为
\begin{equation}
E = \langle \psi | O | \psi \rangle .
\end{equation}
直接计算梯度，得到梯度优化的公式
\begin{equation} \label{eq:Hilbert空间的优化}
\Delta |\psi\rangle = - \Delta \tau 2 O |\psi\rangle ,
\end{equation}
其中 $\Delta\tau$ 为梯度下降的步长，$\Delta |\psi\rangle$ 为态的增量。
对比公式 [[eqref:eq:Hilbert空间的优化]] 和公式 [[eqref:eq:矢量演化方程]] ，我们可以发现，若
\begin{equation}
\left\{
\begin{aligned}
|\psi\rangle &= |\rho(\beta)\rangle_\sharp , \\
\tau &= \beta , \\
2O &= H' ,
\end{aligned}
\right.
\end{equation}
则公式 [[eqref:eq:Hilbert空间的优化]] 正是公式 [[eqref:eq:矢量演化方程]] 这个常微分方程的欧拉迭代解。
这意味着，在矢量化后的希尔伯特空间直接使用 $H'/2$ 作为哈密顿量进行标准的梯度优化，相当于在对原系统的密度矩阵进行降温。
另一方面，[[ref:sec:::自然梯度法]] 介绍过的自然梯度法通过诱导度规，可以实现在参数空间中变分得到在希尔伯特空间进行标准的梯度下降的效果。
综上，我们可以通过算法 [[ref:alg:降温]] 实现在参数空间下的降温。

#+begin_export latex
\SetKwComment{Comment}{/* }{ */}
\begin{algorithm}
\caption{基于自然梯度的降温算法}\label{alg:降温}
\KwData{哈密顿量 $H$ ， 降温步长 $\Delta\beta$， 表示函数$\text{PEPS}$}
\KwResult{任意温度下的热态 $\rho(\beta)$}
初始化参数 $\theta$ 使得 $\text{PEPS}(\theta) = |I\rangle_\sharp$\;
$O \gets \frac{H \otimes I + I \otimes H^T}{4}$\;
$\beta \gets 0$\;
\While{$\beta$ 没有降温到目标温度}{
  $\rho(\beta) \gets \text{PEPS}(\theta)$\;
  $E, G, g \gets \texttt{VMC}(O, \rho(\beta))$ \Comment*[r]{用 \ref{sec::各种采样方法} 中的方法得到梯度$G$和度规$g$}
  $\theta \gets \theta - \Delta\beta g^{-1} G$ \;
  $\beta \gets \beta + \Delta\beta$
}
\end{algorithm}
#+end_export

在自然梯度法中，我们需要计算度规的逆乘以梯度，即求解
\begin{equation}
g X = G,
\end{equation}
其中 $g$ 为度规， $G$ 为梯度， $X$ 为更新参数的方向。
$g$ 本身是 $n_p \times n_p$ 的矩阵，其中 $n_p$ 为参数空间大小，直接求逆需要 $O(n_p^3)$ 的时间复杂度。
幸运的是，这个求逆任务可以通过共轭梯度法实现 [[cite:Bjrck1979,Paige1982]]。
在共轭梯度法中，我们不需要知道矩阵 $g$ 的显式形式，只需要知道如何将其作用在向量 $X$ 上，进行多次迭代即可。
而采样方法中， 公式 [[eqref:eq:度规的采样计算]] 给出的度规估计实际上是由 $n_p \times n_s$ 的矩阵乘以 $n_s \times n_p$ 的矩阵得到的，其中 $n_s$ 为采样数目。
我们可以将 $\Delta_s^i$ 和 $\Delta_s^{j*}$ 两部分分别作用在向量 $X$ 上，这样作用 $g$ 矩阵的复杂度只有 $O(n_s n_p)$ 。
故而共轭梯度法的总复杂度为 $O(n_s n_p n_{cg})$ ，其中 $n_{cg}$ 为共轭梯度法的迭代步数。
当 $n_p \gg n_s$ 时，共轭梯度相比于直接求逆 的 $O(n_p^3)$ 复杂度要快很多。
在我们的情形下，$n_{cg}$ 通常数百步即可收敛，而 $n_s \approx 10^4$， $n_p \approx 10^6$ ，所以这里使用共轭梯度法是个好选择。

相较与标准的共轭梯度法，我们可以共轭梯度法内，计算 $X^\dag g X$ 时做一些改进。
我们不需要将 $g$ 完全作用在 $X$ 上，取而代之，我们直接将 $X$ 放入公式 [[eqref:eq:度规的采样计算]] ，得到
\begin{equation}
X^\dag_i \widehat{g}^{ij} X_j = \frac{\sum_{s \sim S} r_s (X^\dag_i \Delta_s^i) (\Delta_s^{j*} X_j)}{\sum_{s \sim S} r_s} - \frac{\sum_{s \sim S} r_s (X^\dag_i \Delta_s^i)}{\sum_{s \sim S} r_s} \frac{\sum_{s \sim S} r_s (\Delta_s^{j*} X_j)}{\sum_{s \sim S} r_s} ,
\end{equation}
这样我们可以复用中间变量 $X_i^\dag \Delta_s^i$，既减少了运算，也提高了数值稳定性。
这是共轭梯度法的一个常见技巧 [[cite:Bjrck1979,Paige1982]] 。

** 基准测试结果

*** 量子自旋系统

我们首先使用二维 {{{L4}}} 上的反铁磁海森堡模型和 $J_{1}-J_{2}$ 模型对我们的方法进行基准测试。
这些模型可以写成如下形式：
\begin{equation}\label{eq:j1-j2}
H = J_{1} \sum_{\langle i, j\rangle} \mathbf{S}_{i} \cdot \mathbf{S}_{j} + J_{2} \sum_{\langle\langle i, j\rangle\rangle} \mathbf{S}_{i} \cdot \mathbf{S}_{j},
\end{equation}
其中 $\mathbf{S}_{i}$ 是位于 $i$ 位置的自旋-1/2算符， $\langle i, j\rangle$ 表示最近邻的格点对， $\langle\langle i, j\rangle\rangle$ 表示次近邻的格点对。

当 $J_{1} = 1$ 且 $J_{2} = 0$ 时，公式 [[eqref:eq:j1-j2]] 即退化为无阻挫的海森堡模型，因此可以通过量子蒙特卡罗（QMC）方法进行模拟而不会遇到符号问题，例如 {{{SSE}}}（SSE） [[cite:Sandvik1991,Sandvik1992]]  方法。
如图 [[ref:fig:thermal-heisenberg]] 所示，我们将得到的结果与 {{{SSE}}} 方法进行比较。
具体的模型和计算参数为： 我们使用大小为 $N = 8 \times 8$ 的方形晶格，采用开放边界条件；
我们设定投影纠缠对态中的虚拟指标维度为 $D=8$ ；
我们使用边界MPS收缩算法 [[cite:Verstraete2008,Liu2021]] 来收缩单层张量网络， 其精度由截断维度 $D_c$ 控制，这里我们设定 $D_c =16$ ；
我们采用了传统的马尔可夫链方法对量子态的构型进行采样，总样本数量为 $40000$ ；
对于高温情况，我们使用 $p_S=\sqrt{_\sharp \langle \rho | S | \rho \rangle_\sharp}$ 的权重进行采样并进行重加权，直到 $\beta \simeq 0.3$ 。
然后使用正常采样方法直到较低温度 $\beta \simeq 10$ 。
我们在高温附近调整了采样权重，这是因为对于非常高的温度， 未归一化的热态 $\rho(\beta)$ 接近恒等矩阵，其对角项接近于一，而非对角线项则接近于零。
而降低温度后，非对角项权重应当扩大，但是由于此时权重过小，难以采样到，所以难以采出其梯度，也就难以扩大其权重，进而导致高温附近降温比真实情况更慢。
另外，我们在初始的矢量化恒等矩阵 $|I\rangle_\sharp$ 上添加了小的随机扰动，以避免初始时梯度为零的情况。
为了与我们的结果进行比较，我们更改了 {{{SSE}}} 代码 [[cite:SSE-code]] 的边界条件。
在 {{{SSE}}} 方法中，我们使用的样本数为 $10^7$ 。

#+begin_export latex
\begin{figure}
\centering
\includegraphics[width=0.8\textwidth]{8x8-heisenberg.pdf}
%\caption{海森堡模型的降温曲线}
%\note{注：
\caption{海森堡模型的降温曲线。
二维反铁磁海森堡模型在 $8 \times 8$ 方格晶格上的表现：(a) 每格点能量，(b) 每格点比热，(c) 均匀磁化率 $\chi$ 随 $\beta = 1/T$ 的变化情况。
}
\label{fig:thermal-heisenberg}
\end{figure}
#+end_export

如图 [[ref:fig:thermal-heisenberg]] (a) 所示，我们的方法计算得到的每点内能在整个温度范围内（ $\beta = [0, 10]$ ）与 {{{SSE}}} 的结果一致，这说明我们的方法即使在非常低的温度下也具有出色的精度。
图 [[ref:fig:thermal-heisenberg]] (b) 显示了比热 $C_v$ 随 $\beta$ 的变化情况。
在此，我们通过数值微分获取 $C_v$。
具体来说，我们首先得到图 [[ref:fig:thermal-heisenberg]] (a) 数据的B样条曲线，然后可以从该曲线的数值导数中获取 $C_v$。
如图 [[ref:fig:thermal-heisenberg]] (b) 所示，我们的结果与 {{{SSE}}} 的结果基本一致。
尽管 $C_v$ 的峰值与 {{{SSE}}} 的结果存在一定的偏差，这主要是由于数值微分带来的误差，但相应的 $\beta$ 值与 {{{SSE}}} 的结果非常吻合。
获取 $C_v$ 的更精确方法是直接计算 $\beta^2 (\langle H^2 \rangle - \langle H \rangle^2)$ ，然而在低温处，由于 $\beta^2$ 会放大采样误差，为了得到同等质量的结果，直接计算效率比数值差分要低。
图 [[ref:fig:thermal-heisenberg]] (c) 展示了均匀磁化率随 $\beta$ 的变化情况，其定义为
\begin{equation}\label{eq:sus}
\chi=\frac{\beta}{N}\left (\left\langle M_{z}^{2}\right\rangle - \left\langle M_{z}\right\rangle^{2}\right ) , \quad M_{z}=\sum_{i=1}^{N} S_{i}^{z},
\end{equation}
这里，我们同{{{SSE}}}方法 [[cite:Sandvik2010]] 一样， 将 $\langle M_z \rangle^2$ 设置为0，因为哈密顿量中不包含磁场。
如图 [[ref:fig:thermal-heisenberg]] (c)所示，均匀磁化率在整个温度范围内与{{{SSE}}}方法的结果高度一致。
实际上，比起磁化强度，磁化率更难估计，因为随着温度下降，公式 [[eqref:eq:sus]] 中的 $\beta$ 增加，这要求对 $\langle M_z^2 \rangle$ 估计的精度有了更高的要求以达到固定的精度。
这也是低温区域内磁化率与精确结果略有偏差的原因，见 图 [[ref:fig:thermal-heisenberg]] (c)和图 [[ref:fig:thermal-heisenberg]] (c)中 $\beta \approx 10$ 的部分。

当公式 [[eqref:eq:j1-j2]] 中的 $J_2$ 不为零时， $J_1-J_2$ 模型是一个阻挫系统，由于符号问题，不适合使用量子蒙特卡罗方法进行计算。
在零温度情况下，多个数值计算研究 [[cite:Liu2018,Liu2022,Jiang2012,Hu2013,Wang2018]] 显示，当 $J_2/J_1 = 0.5$ 时，$J_1-J_2$ 模型呈现出量子自旋液体相。

我们在 $4 \times 4$ 的 {{{L4}}} 上计算了 $J_1-J_2$ 模型，设置 $J_2/J_1 = 0.5$，这允许通过严格对角化方法进行精确计算以用于基准测试。
我们将张量网络虚拟指标的维度设为 $D=8$，边界MPS方法中的截断维度设置为 $D_c=16$，样本数为 80000。
如图 [[ref:fig:thermal-j1j2]] (a)所示，每点的内能在整个温度范围内与严格对角化的结果高度一致。
图 [[ref:fig:thermal-j1j2]] (b)中的比热 $C_v$ 同样是通过B样条曲线法获得的，也与严格对角化结果一致。
图 [[ref:fig:thermal-j1j2]] (c)中显示的磁化率也很好地与{{{ED}}}结果相符。
因此，我们的方法也适用于有限温度下高度阻挫系统的模拟。

#+begin_export latex
\begin{figure}
\centering
\includegraphics[width=0.8\textwidth]{4x4-j1j2.pdf}
%\caption{ $J_1-J_2$ 模型的降温曲线}
%\note{注：
\caption{ $J_1-J_2$ 模型的降温曲线。
二维阻挫的 $J_1-J_2$ 模型在 $4 \times 4$ 方格晶格上的表现：(a) 每格点能量，(b) 每格点比热，(c) 均匀磁化率 $\chi$ 随 $\beta = 1/T$ 的变化情况。
}
\label{fig:thermal-j1j2}
\end{figure}
#+end_export

*** 费米子系统

我们也尝试将此有限温算法应用于方形晶格的费米子{{{Hubbard}}}模型，其哈密顿量为
\begin{equation}\label{eq:hubbard}
    H = -t \sum_{\langle i, j\rangle, \sigma} c_{i\sigma}^\dag c_{j\sigma} + U \sum_{i} n_{i\uparrow} n_{i\downarrow} - \mu \sum_{i\sigma} n_{i\sigma} ,
\end{equation}
其中， $c_{i\sigma}$ 是位于格点 $i$ 上自旋为 $\sigma = \uparrow$ 或 $\downarrow$ 的湮灭算符， $n_{i\sigma} = c_{i\sigma}^\dag c_{i\sigma}$ 是粒子数算符。
在公式 [[eqref:eq:hubbard]] 中，最近邻格点 $\langle i, j \rangle$ 之间的跃迁项幅度为 $t$ ，同一格点 $i$ 上占据两个相反自旋的粒子之间的排斥相互作用参数为 $U$，化学势为 $\mu$。

如第 [[ref:sec:超导]] 章中提到过，{{{Hubbard}}}模型作为描述Mott绝缘体的基本工具，其在寻找超导现象，探究超导机理的计算与分析中极为重要。
在本次测试中，我们使用 $6 \times 6$ 大小的开边界方形晶格， 参数取 $t=1$ ， $U=8$ 以及 $\mu=4$ ，这对应着半满的反铁磁相 [[cite:Zheng2016]] 。
需要注意的是，我们的方法也适用于正则系综，不过在此我们使用的是巨正则系综，以便与{{{DQMC}}}进行比较。
由于这是半满的{{{Hubbard}}}模型，因此对于行列式量子蒙特卡洛算法来说不存在符号问题。

在测试{{{Hubbard}}}模型中，我们发现{{{Hubbard}}}模型高温附近相比自旋系统更加难以及时降温。
在取采样概率 $p_S = \sqrt{{_\sharp} \langle \rho | S | \rho \rangle_\sharp}$ 失败后，我们调整使用直接采样方法 [[cite:Vieijra2021]] 进行采样。
直接采样使用自回归式的概率
\begin{equation}
p_{S_0\cdots S_{N-1}} = p^c_{S_0} p^c_{S_1 | S_0} p^c_{S_2 | S_0 S_1} \cdots,
\end{equation}
其中
\begin{equation}
p^c_{S_i|S_0 \cdots S_{i-1}} = \frac{\sum_{S_{i+1}S_{i+2}\cdots} {_\sharp} \langle \rho | S_0 S_1 \cdots S_{i-1} S_i S_{i+1}\cdots | \rho\rangle_\sharp}{\sum_{S_i S_{i+1}S_{i+2}\cdots}{_\sharp} \langle \rho | S_0 S_1 \cdots S_{i-1} S_i S_{i+1}\cdots | \rho\rangle_\sharp}.
\end{equation}
为了实现类似$p_S = \sqrt{{_\sharp} \langle \rho | S | \rho \rangle_\sharp}$ 的采样，我们选择
\begin{equation}
p_{S_0\cdots S_{N-1}} = p^c_{S_0} p^c_{S_1 | S_0} p^c_{S_2 | S_0 S_1} \cdots,
\end{equation}
其中
\begin{equation}
p^c_{S_i|S_0 \cdots S_{i-1}} = b(S_i)\sqrt{\frac{\sum_{S_{i+1}S_{i+2}\cdots}{_\sharp} \langle \rho | S_0 S_1 \cdots S_{i-1} S_i S_{i+1}\cdots | \rho\rangle_\sharp}{\sum_{S_i S_{i+1}S_{i+2}\cdots}{_\sharp} \langle \rho | S_0 S_1 \cdots S_{i-1} S_i S_{i+1}\cdots | \rho\rangle_\sharp}}.
\end{equation}
其中 $s_i\neq s'_i$ 时 $b(s_i s'_i) = 1$ ， $S_i=s_i s'_i$ 。否则他是一个的每步梯度后动态调整的值，使得对角构型数目不超过总数目的一半。

如图 [[ref:fig:thermal-hubbard]] 所示，我们将{{{Hubbard}}}模型的结果与{{{DQMC}}}方法进行比较。
在优化过程中使用了高达30000次采样，在测量过程中使用了600000次采样。
可以看出，图  [[ref:fig:thermal-hubbard]] (a) 中每格点的内能随着温度下降而降低，并逐渐收敛于基态的能量，在图中使用虚线指示。
我们的结果与 {{{DQMC}}} 结果高度一致。
图  [[ref:fig:thermal-hubbard]] (b) 展示了通过高斯过程回归来拟合能量后进行数值微分得到的 $C_v$ 。
尽管和 {{{DQMC}}} 的结果有小的不同，但这部分不同可能是由于计算 $C_v$ 时对能量计算结果的高精度要求导致的，而那需要更大的虚拟指标截断 $D$ 。
除此之外，我们可以看到两个峰出现在 $C_v$ 的图上，大越分别在 $1/T_1=0.5$ 和 $1/T_2=4.0$ ，这也是和 {{{DQMC}}} 的结果一致的。
这两个峰和文献 [[cite:Li2023]] 的结果一致。
其中高温的峰来源于 {{{Hubbard}}} 带的激发，而低温峰来自于自旋态的激发 [[cite:Duffy1997]] 。
高温峰的估计值为 $1/T_1 \approx \frac{4.8}{U} = 0.6$ 而低温峰的估计值为 $1/T_2 \approx \frac{3U}{8t^2} = 3.0$ [[cite:Paiva2001]] 。
我们的结果和这个估计也比较一致。
我们也计算了 每格点的双占据 $D=\sum_i \langle n_{i\downarrow} n_{i\uparrow} \rangle / N$ ，以及
次近邻格点之间的自旋关联 $F=\sum_{\langle\langle i, j \rangle\rangle}\langle \mathbf{S}_i \cdot \mathbf{S}_j \rangle / M$ ，
，其中 $M$ 是次近邻格点对的数量。
结果分别展示在 图  [[ref:fig:thermal-hubbard]] (c) 和 图  [[ref:fig:thermal-hubbard]] (d) 中，
并且同样和 {{{DQMC}}} 方法获得的结果一致。
双占据在高温时接近 $0.2$ ，随着温度降低，逐渐降低并收敛到了 $0.05$  附近。
而次近邻自旋关联则从无穷温的零变化为 低温时接近的 $0.15$ 。
由于我们的系统尺寸比较小，我们并不能判断这些可能的序的突变。
我们的结果和文献 [[cite:Li2023]] 的结果基本一致，除了一些小的差异，那些差异可能是模拟时系统尺寸不同导致的。

#+begin_export latex
\begin{figure}
\centering
\includegraphics[width=0.8\textwidth]{6x6-hubbard.pdf}
%\caption{ 哈伯德模型的降温曲线 }
%\note{注：
\caption{ 哈伯德模型的降温曲线。
$6 \times 6$ 方形晶格上的费米子哈伯德模型的降温曲线，参数为 $U=8$，$t=1$ 和 $\mu=4$。(a) 每格点的内能 $E/N$ ，(b)每格点比热 ，(c) 每格点的双占据 $D$ ，(d) 次近邻格点之间的自旋关联 $F$ 随着 $\beta = 1/T$ 的变化情况。
}
\label{fig:thermal-hubbard}
\end{figure}
#+end_export

** 小结

我们开发了基于自然梯度法的有限温度 {{{PEPS}}} 变分方案，用于模拟二维量子多体系统的热态。
这个基于{{{NG}}}法的有限温方法中使用的张量网络态，特别是 {{{PEPS}}}，在表示二维系统中具有可扩展性。
我们的方案继承了 基于{{{PEPS}}}的 {{{VMC}}}算法的多个优势，如可以实现大规模并行化。
此外，基准测试结果显示，我们的方法可以应用于量子自旋系统和费米子系统。
相比于直接的简单更新，我们的方法不仅精度更高其更容易控制，还可以直接用于模拟长程相互作用，例如 {{{Rydberg}}} 原子系统。
未来我们还可以使用多个张量网络之和作为变分表示 [[cite:Dong2024]] 来模拟具有周期性边界条件的系统。
总之，我们为 {{{TNS}}} 算法提供了一套变分的有限温相图探索方案。

* 总结与展望 <<sec:总结与展望>>

在本论文中，我们详细介绍了张量网络态的基础知识以及各种计算细节，包括对称性张量和费米子张量，并讨论了张量网络态中常见的各种算法。
我们发展了费米子张量网络的计算方法，定义了费米子张量的底层操作规则，从而可以在无需任何上层修改的情况下将自旋或者玻色子的算法直接应用于费米子张量网络态上。
我们从底层算子的优化入手，全面构建了用于张量网络态计算的 TNSP 套件，可以高效地实现多种张量网络态算法，特别是针对投影纠缠对态的各类方法。
得益于这一费米子张量方案的优势，该套件提供了跨不同类型张量的统一接口，并在上层提供了一套界面，方便用户开发新算法和调整多体系统模型。

我们利用 TNSP 套件实现了 费米子的投影纠缠对态方法，并利用其研究六角晶格上空穴掺杂的哈伯德模型基态性质。
研究结果表明，该模型存在超导准长程序，同时还观察到反铁磁序和电荷密度波序之间的竞争。
此外，我们基于 TNSP 套件开发了一套用于计算多体系统在有限温度下性质的算法。多项基准测试结果表明，该算法能够获得可靠的结果。

张量网络态作为近二十年来的新兴技术，已经在不同系统和各类物理问题中得到了广泛应用。
然而，对于费米子系统，目前存在多种不同的张量网络态实现方案，但尚未形成公认的最优方案。
在未来，张量网络态方法，包括专门针对费米子系统的张量网络态方法，仍将持续发展和不断完善。

目前，张量网络态方法面临的主要挑战包括计算量大、计算复杂度高、优化过程困难以及容易陷入局域极小值问题。
此外，与开边界条件相比，处理周期性边界条件更为复杂，这进一步增加了计算的难度。
为了应对这些挑战，我们需要采取以下措施：改进算法以提高计算效率并降低复杂度，例如在新型异构计算平台上进行加速；
改进优化策略以有效应对局域极小值问题；优化处理周期性边界条件的张量网络结构；
并且跨学科地结合神经网络、机器学习和量子信息等领域的方法，以增强张量网络态的表现能力和适用范围。

展望未来，我们希望基于张量网络态的算法能够逐步实现对真实物理性质的直接模拟，达到可以与实验观测直接对比的精确尺度。
我们期望这些算法能够像密度泛函理论一样，在更广泛的物理和材料科学领域中得到广泛应用。
通过持续的努力和创新，张量网络态有望在探索新奇物理现象、设计新材料以及理解复杂多体系统方面发挥更加重要的作用。
这将进一步推动物理学和材料科学领域的前沿研究，带来更多的创新和突破。

#+begin_export latex
\bibliography{main}
\appendix
#+end_export

#+begin_export latex
\backmatter
#+end_export

#+begin_export latex
\begin{acknowledgements}

在中国科学技术大学攻读博士学位的五年里，我所从事的学习和研究工作，
都是在导师以及系里其他老师和同学的指导和帮助下进行的。在完成论文之际，
请容许我对他们表达诚挚的谢意。

首先感谢我的导师何力新教授。我能取得今天的成绩，与何老师一直以来的
悉心指导、严格要求和启发鼓舞是分不开的。何老师教给了我如何进行科学的思
考和一个科研工作者应该所持有的工作态度。何老师严谨的治学态度、严密的思
维方式、忘我的工作精神和努力开拓勇于进取的精神让我受益匪浅。

感谢韩永建教授长期以来的指导和教诲。韩老师渊博的学识和宽广的胸怀
令人印象深刻。韩老师不仅教给了我专业的知识，也教给了生活中的一些道理，
让我对科研生活有更全面深刻的了解。

感谢实验室主任郭光灿教授。郭老师为我们提供了一个学术氛围浓厚、科研
条件优越的实验室，使我们能够专心于学术研究。正是在这样一个一流的实验室
里，通过和各位老师同学互相交流互相鼓舞，我才能有机会得到锻炼和成长。

感谢实验室的任新国老师、李传锋老师、周正威老师、周祥发老师、涂涛老
师、邹旭波老师、易为老师、龚明老师、孙方稳老师、许金时老师以及其他所有
相关的老师。他们传授了课堂和生活的知识给我，也以他们的品格影响了我。

感谢董少钧、王超和张盟长期以来对我生活、学习和科研上的关心、帮助和指导。
感谢我们研究小组的其他成员韩聿舟在科研方面的探讨与交流。
也感谢我们小组的其他成员的关心与支持。同样感谢实验室的其他同学。

最后，特别感谢我的家人。你们对我一贯的鼓励和支持，
是我追求学业的坚强后盾。这个学位不仅属于我，同样也属于你们。

\hfill 2024年9月1日

\end{acknowledgements}

\begin{publications}

\section*{已发表论文}

\begin{enumerate}
\item Zhang Hao, Dong Shaojun, Wang Chao, Zhang Meng, He Lixin.
TNSP: A framework supporting symmetry and fermion tensors for tensor network state methods[J/OL].
Computer Physics Communications, 2024, 305: 109355.
\item Dong Shaojun, Zhang Hao, Wang Chao, Zhang Meng, Han Yong-Jian, and He Lixin.
A possible quantum spin liquid phase in the kitaev–hubbard model[J/OL].
Chinese Physics Letters, 2023, 40(12): 126403.
\item Zhang Meng, Wang Chao, Dong Shaojun, Zhang Hao, Han Yongjian, and He Lixin.
Entanglement entropy scaling of noisy random quantum circuits in two dimensions[J/OL].
Physical Review A, 2022, 106(5).
\item Tao Si-Jing, Zhang Hao-Qing, Zhang Hao, Chen Zhe, He Ran, Dong Shao-Jun, Han Yong-Jian, Li Chuan-Feng, and Guo Guang-Can.
Generating tensor-network states via combination of phonons and qubits in a trapped-ion platform[J/OL].
Physical Review A, 2022, 106(3).
\item Zhang Meng, Wang Chao, Dong Shaojun, Zhang Hao, Han Yongjian, and He Lixin.
Projected entangled pair states study of anisotropic-exchange magnets on the triangular lattice[J/OL].
Physical Review B, 2022, 105(2).
\end{enumerate}

\section*{待发表论文}

\begin{enumerate}
\item Zhang Hao, Dong Shaojun, He Lixin.
Competing phases and suppression of superconductivity in hole-doped Hubbard model on honeycomb lattice.
\item Zhang Meng, Zhang Hao, Wang Chao, He Lixin.
Scalable tensor network algorithm for thermal quantum many-body systems in two dimension.
\item Dong Shaojun, Wang Chao, Zhang Hao, Zhang Meng, He Lixin.
Beyond Boundaries: efficient Projected Entangled Pair States methods for periodic quantum systems.
\end{enumerate}

\end{publications}
#+end_export
